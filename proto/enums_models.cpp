//------------------------------------------------------------------------------
// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: enums.fbe
// FBE version: 1.14.5.0
//------------------------------------------------------------------------------

#include "enums_models.h"

namespace FBE {

FieldModel<::enums::Enums>::FieldModel(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , byte0(buffer, 4 + 4)
    , byte1(buffer, byte0.fbe_offset() + byte0.fbe_size())
    , byte2(buffer, byte1.fbe_offset() + byte1.fbe_size())
    , byte3(buffer, byte2.fbe_offset() + byte2.fbe_size())
    , byte4(buffer, byte3.fbe_offset() + byte3.fbe_size())
    , byte5(buffer, byte4.fbe_offset() + byte4.fbe_size())
    , char0(buffer, byte5.fbe_offset() + byte5.fbe_size())
    , char1(buffer, char0.fbe_offset() + char0.fbe_size())
    , char2(buffer, char1.fbe_offset() + char1.fbe_size())
    , char3(buffer, char2.fbe_offset() + char2.fbe_size())
    , char4(buffer, char3.fbe_offset() + char3.fbe_size())
    , char5(buffer, char4.fbe_offset() + char4.fbe_size())
    , wchar0(buffer, char5.fbe_offset() + char5.fbe_size())
    , wchar1(buffer, wchar0.fbe_offset() + wchar0.fbe_size())
    , wchar2(buffer, wchar1.fbe_offset() + wchar1.fbe_size())
    , wchar3(buffer, wchar2.fbe_offset() + wchar2.fbe_size())
    , wchar4(buffer, wchar3.fbe_offset() + wchar3.fbe_size())
    , wchar5(buffer, wchar4.fbe_offset() + wchar4.fbe_size())
    , int8b0(buffer, wchar5.fbe_offset() + wchar5.fbe_size())
    , int8b1(buffer, int8b0.fbe_offset() + int8b0.fbe_size())
    , int8b2(buffer, int8b1.fbe_offset() + int8b1.fbe_size())
    , int8b3(buffer, int8b2.fbe_offset() + int8b2.fbe_size())
    , int8b4(buffer, int8b3.fbe_offset() + int8b3.fbe_size())
    , int8b5(buffer, int8b4.fbe_offset() + int8b4.fbe_size())
    , uint8b0(buffer, int8b5.fbe_offset() + int8b5.fbe_size())
    , uint8b1(buffer, uint8b0.fbe_offset() + uint8b0.fbe_size())
    , uint8b2(buffer, uint8b1.fbe_offset() + uint8b1.fbe_size())
    , uint8b3(buffer, uint8b2.fbe_offset() + uint8b2.fbe_size())
    , uint8b4(buffer, uint8b3.fbe_offset() + uint8b3.fbe_size())
    , uint8b5(buffer, uint8b4.fbe_offset() + uint8b4.fbe_size())
    , int16b0(buffer, uint8b5.fbe_offset() + uint8b5.fbe_size())
    , int16b1(buffer, int16b0.fbe_offset() + int16b0.fbe_size())
    , int16b2(buffer, int16b1.fbe_offset() + int16b1.fbe_size())
    , int16b3(buffer, int16b2.fbe_offset() + int16b2.fbe_size())
    , int16b4(buffer, int16b3.fbe_offset() + int16b3.fbe_size())
    , int16b5(buffer, int16b4.fbe_offset() + int16b4.fbe_size())
    , uint16b0(buffer, int16b5.fbe_offset() + int16b5.fbe_size())
    , uint16b1(buffer, uint16b0.fbe_offset() + uint16b0.fbe_size())
    , uint16b2(buffer, uint16b1.fbe_offset() + uint16b1.fbe_size())
    , uint16b3(buffer, uint16b2.fbe_offset() + uint16b2.fbe_size())
    , uint16b4(buffer, uint16b3.fbe_offset() + uint16b3.fbe_size())
    , uint16b5(buffer, uint16b4.fbe_offset() + uint16b4.fbe_size())
    , int32b0(buffer, uint16b5.fbe_offset() + uint16b5.fbe_size())
    , int32b1(buffer, int32b0.fbe_offset() + int32b0.fbe_size())
    , int32b2(buffer, int32b1.fbe_offset() + int32b1.fbe_size())
    , int32b3(buffer, int32b2.fbe_offset() + int32b2.fbe_size())
    , int32b4(buffer, int32b3.fbe_offset() + int32b3.fbe_size())
    , int32b5(buffer, int32b4.fbe_offset() + int32b4.fbe_size())
    , uint32b0(buffer, int32b5.fbe_offset() + int32b5.fbe_size())
    , uint32b1(buffer, uint32b0.fbe_offset() + uint32b0.fbe_size())
    , uint32b2(buffer, uint32b1.fbe_offset() + uint32b1.fbe_size())
    , uint32b3(buffer, uint32b2.fbe_offset() + uint32b2.fbe_size())
    , uint32b4(buffer, uint32b3.fbe_offset() + uint32b3.fbe_size())
    , uint32b5(buffer, uint32b4.fbe_offset() + uint32b4.fbe_size())
    , int64b0(buffer, uint32b5.fbe_offset() + uint32b5.fbe_size())
    , int64b1(buffer, int64b0.fbe_offset() + int64b0.fbe_size())
    , int64b2(buffer, int64b1.fbe_offset() + int64b1.fbe_size())
    , int64b3(buffer, int64b2.fbe_offset() + int64b2.fbe_size())
    , int64b4(buffer, int64b3.fbe_offset() + int64b3.fbe_size())
    , int64b5(buffer, int64b4.fbe_offset() + int64b4.fbe_size())
    , uint64b0(buffer, int64b5.fbe_offset() + int64b5.fbe_size())
    , uint64b1(buffer, uint64b0.fbe_offset() + uint64b0.fbe_size())
    , uint64b2(buffer, uint64b1.fbe_offset() + uint64b1.fbe_size())
    , uint64b3(buffer, uint64b2.fbe_offset() + uint64b2.fbe_size())
    , uint64b4(buffer, uint64b3.fbe_offset() + uint64b3.fbe_size())
    , uint64b5(buffer, uint64b4.fbe_offset() + uint64b4.fbe_size())
{}

size_t FieldModel<::enums::Enums>::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + byte0.fbe_size()
        + byte1.fbe_size()
        + byte2.fbe_size()
        + byte3.fbe_size()
        + byte4.fbe_size()
        + byte5.fbe_size()
        + char0.fbe_size()
        + char1.fbe_size()
        + char2.fbe_size()
        + char3.fbe_size()
        + char4.fbe_size()
        + char5.fbe_size()
        + wchar0.fbe_size()
        + wchar1.fbe_size()
        + wchar2.fbe_size()
        + wchar3.fbe_size()
        + wchar4.fbe_size()
        + wchar5.fbe_size()
        + int8b0.fbe_size()
        + int8b1.fbe_size()
        + int8b2.fbe_size()
        + int8b3.fbe_size()
        + int8b4.fbe_size()
        + int8b5.fbe_size()
        + uint8b0.fbe_size()
        + uint8b1.fbe_size()
        + uint8b2.fbe_size()
        + uint8b3.fbe_size()
        + uint8b4.fbe_size()
        + uint8b5.fbe_size()
        + int16b0.fbe_size()
        + int16b1.fbe_size()
        + int16b2.fbe_size()
        + int16b3.fbe_size()
        + int16b4.fbe_size()
        + int16b5.fbe_size()
        + uint16b0.fbe_size()
        + uint16b1.fbe_size()
        + uint16b2.fbe_size()
        + uint16b3.fbe_size()
        + uint16b4.fbe_size()
        + uint16b5.fbe_size()
        + int32b0.fbe_size()
        + int32b1.fbe_size()
        + int32b2.fbe_size()
        + int32b3.fbe_size()
        + int32b4.fbe_size()
        + int32b5.fbe_size()
        + uint32b0.fbe_size()
        + uint32b1.fbe_size()
        + uint32b2.fbe_size()
        + uint32b3.fbe_size()
        + uint32b4.fbe_size()
        + uint32b5.fbe_size()
        + int64b0.fbe_size()
        + int64b1.fbe_size()
        + int64b2.fbe_size()
        + int64b3.fbe_size()
        + int64b4.fbe_size()
        + int64b5.fbe_size()
        + uint64b0.fbe_size()
        + uint64b1.fbe_size()
        + uint64b2.fbe_size()
        + uint64b3.fbe_size()
        + uint64b4.fbe_size()
        + uint64b5.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel<::enums::Enums>::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + byte0.fbe_extra()
        + byte1.fbe_extra()
        + byte2.fbe_extra()
        + byte3.fbe_extra()
        + byte4.fbe_extra()
        + byte5.fbe_extra()
        + char0.fbe_extra()
        + char1.fbe_extra()
        + char2.fbe_extra()
        + char3.fbe_extra()
        + char4.fbe_extra()
        + char5.fbe_extra()
        + wchar0.fbe_extra()
        + wchar1.fbe_extra()
        + wchar2.fbe_extra()
        + wchar3.fbe_extra()
        + wchar4.fbe_extra()
        + wchar5.fbe_extra()
        + int8b0.fbe_extra()
        + int8b1.fbe_extra()
        + int8b2.fbe_extra()
        + int8b3.fbe_extra()
        + int8b4.fbe_extra()
        + int8b5.fbe_extra()
        + uint8b0.fbe_extra()
        + uint8b1.fbe_extra()
        + uint8b2.fbe_extra()
        + uint8b3.fbe_extra()
        + uint8b4.fbe_extra()
        + uint8b5.fbe_extra()
        + int16b0.fbe_extra()
        + int16b1.fbe_extra()
        + int16b2.fbe_extra()
        + int16b3.fbe_extra()
        + int16b4.fbe_extra()
        + int16b5.fbe_extra()
        + uint16b0.fbe_extra()
        + uint16b1.fbe_extra()
        + uint16b2.fbe_extra()
        + uint16b3.fbe_extra()
        + uint16b4.fbe_extra()
        + uint16b5.fbe_extra()
        + int32b0.fbe_extra()
        + int32b1.fbe_extra()
        + int32b2.fbe_extra()
        + int32b3.fbe_extra()
        + int32b4.fbe_extra()
        + int32b5.fbe_extra()
        + uint32b0.fbe_extra()
        + uint32b1.fbe_extra()
        + uint32b2.fbe_extra()
        + uint32b3.fbe_extra()
        + uint32b4.fbe_extra()
        + uint32b5.fbe_extra()
        + int64b0.fbe_extra()
        + int64b1.fbe_extra()
        + int64b2.fbe_extra()
        + int64b3.fbe_extra()
        + int64b4.fbe_extra()
        + int64b5.fbe_extra()
        + uint64b0.fbe_extra()
        + uint64b1.fbe_extra()
        + uint64b2.fbe_extra()
        + uint64b3.fbe_extra()
        + uint64b4.fbe_extra()
        + uint64b5.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel<::enums::Enums>::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4));
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel<::enums::Enums>::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + byte0.fbe_size()) > fbe_struct_size)
        return true;
    if (!byte0.verify())
        return false;
    fbe_current_size += byte0.fbe_size();

    if ((fbe_current_size + byte1.fbe_size()) > fbe_struct_size)
        return true;
    if (!byte1.verify())
        return false;
    fbe_current_size += byte1.fbe_size();

    if ((fbe_current_size + byte2.fbe_size()) > fbe_struct_size)
        return true;
    if (!byte2.verify())
        return false;
    fbe_current_size += byte2.fbe_size();

    if ((fbe_current_size + byte3.fbe_size()) > fbe_struct_size)
        return true;
    if (!byte3.verify())
        return false;
    fbe_current_size += byte3.fbe_size();

    if ((fbe_current_size + byte4.fbe_size()) > fbe_struct_size)
        return true;
    if (!byte4.verify())
        return false;
    fbe_current_size += byte4.fbe_size();

    if ((fbe_current_size + byte5.fbe_size()) > fbe_struct_size)
        return true;
    if (!byte5.verify())
        return false;
    fbe_current_size += byte5.fbe_size();

    if ((fbe_current_size + char0.fbe_size()) > fbe_struct_size)
        return true;
    if (!char0.verify())
        return false;
    fbe_current_size += char0.fbe_size();

    if ((fbe_current_size + char1.fbe_size()) > fbe_struct_size)
        return true;
    if (!char1.verify())
        return false;
    fbe_current_size += char1.fbe_size();

    if ((fbe_current_size + char2.fbe_size()) > fbe_struct_size)
        return true;
    if (!char2.verify())
        return false;
    fbe_current_size += char2.fbe_size();

    if ((fbe_current_size + char3.fbe_size()) > fbe_struct_size)
        return true;
    if (!char3.verify())
        return false;
    fbe_current_size += char3.fbe_size();

    if ((fbe_current_size + char4.fbe_size()) > fbe_struct_size)
        return true;
    if (!char4.verify())
        return false;
    fbe_current_size += char4.fbe_size();

    if ((fbe_current_size + char5.fbe_size()) > fbe_struct_size)
        return true;
    if (!char5.verify())
        return false;
    fbe_current_size += char5.fbe_size();

    if ((fbe_current_size + wchar0.fbe_size()) > fbe_struct_size)
        return true;
    if (!wchar0.verify())
        return false;
    fbe_current_size += wchar0.fbe_size();

    if ((fbe_current_size + wchar1.fbe_size()) > fbe_struct_size)
        return true;
    if (!wchar1.verify())
        return false;
    fbe_current_size += wchar1.fbe_size();

    if ((fbe_current_size + wchar2.fbe_size()) > fbe_struct_size)
        return true;
    if (!wchar2.verify())
        return false;
    fbe_current_size += wchar2.fbe_size();

    if ((fbe_current_size + wchar3.fbe_size()) > fbe_struct_size)
        return true;
    if (!wchar3.verify())
        return false;
    fbe_current_size += wchar3.fbe_size();

    if ((fbe_current_size + wchar4.fbe_size()) > fbe_struct_size)
        return true;
    if (!wchar4.verify())
        return false;
    fbe_current_size += wchar4.fbe_size();

    if ((fbe_current_size + wchar5.fbe_size()) > fbe_struct_size)
        return true;
    if (!wchar5.verify())
        return false;
    fbe_current_size += wchar5.fbe_size();

    if ((fbe_current_size + int8b0.fbe_size()) > fbe_struct_size)
        return true;
    if (!int8b0.verify())
        return false;
    fbe_current_size += int8b0.fbe_size();

    if ((fbe_current_size + int8b1.fbe_size()) > fbe_struct_size)
        return true;
    if (!int8b1.verify())
        return false;
    fbe_current_size += int8b1.fbe_size();

    if ((fbe_current_size + int8b2.fbe_size()) > fbe_struct_size)
        return true;
    if (!int8b2.verify())
        return false;
    fbe_current_size += int8b2.fbe_size();

    if ((fbe_current_size + int8b3.fbe_size()) > fbe_struct_size)
        return true;
    if (!int8b3.verify())
        return false;
    fbe_current_size += int8b3.fbe_size();

    if ((fbe_current_size + int8b4.fbe_size()) > fbe_struct_size)
        return true;
    if (!int8b4.verify())
        return false;
    fbe_current_size += int8b4.fbe_size();

    if ((fbe_current_size + int8b5.fbe_size()) > fbe_struct_size)
        return true;
    if (!int8b5.verify())
        return false;
    fbe_current_size += int8b5.fbe_size();

    if ((fbe_current_size + uint8b0.fbe_size()) > fbe_struct_size)
        return true;
    if (!uint8b0.verify())
        return false;
    fbe_current_size += uint8b0.fbe_size();

    if ((fbe_current_size + uint8b1.fbe_size()) > fbe_struct_size)
        return true;
    if (!uint8b1.verify())
        return false;
    fbe_current_size += uint8b1.fbe_size();

    if ((fbe_current_size + uint8b2.fbe_size()) > fbe_struct_size)
        return true;
    if (!uint8b2.verify())
        return false;
    fbe_current_size += uint8b2.fbe_size();

    if ((fbe_current_size + uint8b3.fbe_size()) > fbe_struct_size)
        return true;
    if (!uint8b3.verify())
        return false;
    fbe_current_size += uint8b3.fbe_size();

    if ((fbe_current_size + uint8b4.fbe_size()) > fbe_struct_size)
        return true;
    if (!uint8b4.verify())
        return false;
    fbe_current_size += uint8b4.fbe_size();

    if ((fbe_current_size + uint8b5.fbe_size()) > fbe_struct_size)
        return true;
    if (!uint8b5.verify())
        return false;
    fbe_current_size += uint8b5.fbe_size();

    if ((fbe_current_size + int16b0.fbe_size()) > fbe_struct_size)
        return true;
    if (!int16b0.verify())
        return false;
    fbe_current_size += int16b0.fbe_size();

    if ((fbe_current_size + int16b1.fbe_size()) > fbe_struct_size)
        return true;
    if (!int16b1.verify())
        return false;
    fbe_current_size += int16b1.fbe_size();

    if ((fbe_current_size + int16b2.fbe_size()) > fbe_struct_size)
        return true;
    if (!int16b2.verify())
        return false;
    fbe_current_size += int16b2.fbe_size();

    if ((fbe_current_size + int16b3.fbe_size()) > fbe_struct_size)
        return true;
    if (!int16b3.verify())
        return false;
    fbe_current_size += int16b3.fbe_size();

    if ((fbe_current_size + int16b4.fbe_size()) > fbe_struct_size)
        return true;
    if (!int16b4.verify())
        return false;
    fbe_current_size += int16b4.fbe_size();

    if ((fbe_current_size + int16b5.fbe_size()) > fbe_struct_size)
        return true;
    if (!int16b5.verify())
        return false;
    fbe_current_size += int16b5.fbe_size();

    if ((fbe_current_size + uint16b0.fbe_size()) > fbe_struct_size)
        return true;
    if (!uint16b0.verify())
        return false;
    fbe_current_size += uint16b0.fbe_size();

    if ((fbe_current_size + uint16b1.fbe_size()) > fbe_struct_size)
        return true;
    if (!uint16b1.verify())
        return false;
    fbe_current_size += uint16b1.fbe_size();

    if ((fbe_current_size + uint16b2.fbe_size()) > fbe_struct_size)
        return true;
    if (!uint16b2.verify())
        return false;
    fbe_current_size += uint16b2.fbe_size();

    if ((fbe_current_size + uint16b3.fbe_size()) > fbe_struct_size)
        return true;
    if (!uint16b3.verify())
        return false;
    fbe_current_size += uint16b3.fbe_size();

    if ((fbe_current_size + uint16b4.fbe_size()) > fbe_struct_size)
        return true;
    if (!uint16b4.verify())
        return false;
    fbe_current_size += uint16b4.fbe_size();

    if ((fbe_current_size + uint16b5.fbe_size()) > fbe_struct_size)
        return true;
    if (!uint16b5.verify())
        return false;
    fbe_current_size += uint16b5.fbe_size();

    if ((fbe_current_size + int32b0.fbe_size()) > fbe_struct_size)
        return true;
    if (!int32b0.verify())
        return false;
    fbe_current_size += int32b0.fbe_size();

    if ((fbe_current_size + int32b1.fbe_size()) > fbe_struct_size)
        return true;
    if (!int32b1.verify())
        return false;
    fbe_current_size += int32b1.fbe_size();

    if ((fbe_current_size + int32b2.fbe_size()) > fbe_struct_size)
        return true;
    if (!int32b2.verify())
        return false;
    fbe_current_size += int32b2.fbe_size();

    if ((fbe_current_size + int32b3.fbe_size()) > fbe_struct_size)
        return true;
    if (!int32b3.verify())
        return false;
    fbe_current_size += int32b3.fbe_size();

    if ((fbe_current_size + int32b4.fbe_size()) > fbe_struct_size)
        return true;
    if (!int32b4.verify())
        return false;
    fbe_current_size += int32b4.fbe_size();

    if ((fbe_current_size + int32b5.fbe_size()) > fbe_struct_size)
        return true;
    if (!int32b5.verify())
        return false;
    fbe_current_size += int32b5.fbe_size();

    if ((fbe_current_size + uint32b0.fbe_size()) > fbe_struct_size)
        return true;
    if (!uint32b0.verify())
        return false;
    fbe_current_size += uint32b0.fbe_size();

    if ((fbe_current_size + uint32b1.fbe_size()) > fbe_struct_size)
        return true;
    if (!uint32b1.verify())
        return false;
    fbe_current_size += uint32b1.fbe_size();

    if ((fbe_current_size + uint32b2.fbe_size()) > fbe_struct_size)
        return true;
    if (!uint32b2.verify())
        return false;
    fbe_current_size += uint32b2.fbe_size();

    if ((fbe_current_size + uint32b3.fbe_size()) > fbe_struct_size)
        return true;
    if (!uint32b3.verify())
        return false;
    fbe_current_size += uint32b3.fbe_size();

    if ((fbe_current_size + uint32b4.fbe_size()) > fbe_struct_size)
        return true;
    if (!uint32b4.verify())
        return false;
    fbe_current_size += uint32b4.fbe_size();

    if ((fbe_current_size + uint32b5.fbe_size()) > fbe_struct_size)
        return true;
    if (!uint32b5.verify())
        return false;
    fbe_current_size += uint32b5.fbe_size();

    if ((fbe_current_size + int64b0.fbe_size()) > fbe_struct_size)
        return true;
    if (!int64b0.verify())
        return false;
    fbe_current_size += int64b0.fbe_size();

    if ((fbe_current_size + int64b1.fbe_size()) > fbe_struct_size)
        return true;
    if (!int64b1.verify())
        return false;
    fbe_current_size += int64b1.fbe_size();

    if ((fbe_current_size + int64b2.fbe_size()) > fbe_struct_size)
        return true;
    if (!int64b2.verify())
        return false;
    fbe_current_size += int64b2.fbe_size();

    if ((fbe_current_size + int64b3.fbe_size()) > fbe_struct_size)
        return true;
    if (!int64b3.verify())
        return false;
    fbe_current_size += int64b3.fbe_size();

    if ((fbe_current_size + int64b4.fbe_size()) > fbe_struct_size)
        return true;
    if (!int64b4.verify())
        return false;
    fbe_current_size += int64b4.fbe_size();

    if ((fbe_current_size + int64b5.fbe_size()) > fbe_struct_size)
        return true;
    if (!int64b5.verify())
        return false;
    fbe_current_size += int64b5.fbe_size();

    if ((fbe_current_size + uint64b0.fbe_size()) > fbe_struct_size)
        return true;
    if (!uint64b0.verify())
        return false;
    fbe_current_size += uint64b0.fbe_size();

    if ((fbe_current_size + uint64b1.fbe_size()) > fbe_struct_size)
        return true;
    if (!uint64b1.verify())
        return false;
    fbe_current_size += uint64b1.fbe_size();

    if ((fbe_current_size + uint64b2.fbe_size()) > fbe_struct_size)
        return true;
    if (!uint64b2.verify())
        return false;
    fbe_current_size += uint64b2.fbe_size();

    if ((fbe_current_size + uint64b3.fbe_size()) > fbe_struct_size)
        return true;
    if (!uint64b3.verify())
        return false;
    fbe_current_size += uint64b3.fbe_size();

    if ((fbe_current_size + uint64b4.fbe_size()) > fbe_struct_size)
        return true;
    if (!uint64b4.verify())
        return false;
    fbe_current_size += uint64b4.fbe_size();

    if ((fbe_current_size + uint64b5.fbe_size()) > fbe_struct_size)
        return true;
    if (!uint64b5.verify())
        return false;
    fbe_current_size += uint64b5.fbe_size();

    return true;
}

size_t FieldModel<::enums::Enums>::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel<::enums::Enums>::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel<::enums::Enums>::get(::enums::Enums& fbe_value) const noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset()));
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel<::enums::Enums>::get_fields(::enums::Enums& fbe_value, size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + byte0.fbe_size()) <= fbe_struct_size)
        byte0.get(fbe_value.byte0, EnumByte::ENUM_VALUE_0);
    else
        fbe_value.byte0 = EnumByte::ENUM_VALUE_0;
    fbe_current_size += byte0.fbe_size();

    if ((fbe_current_size + byte1.fbe_size()) <= fbe_struct_size)
        byte1.get(fbe_value.byte1, EnumByte::ENUM_VALUE_1);
    else
        fbe_value.byte1 = EnumByte::ENUM_VALUE_1;
    fbe_current_size += byte1.fbe_size();

    if ((fbe_current_size + byte2.fbe_size()) <= fbe_struct_size)
        byte2.get(fbe_value.byte2, EnumByte::ENUM_VALUE_2);
    else
        fbe_value.byte2 = EnumByte::ENUM_VALUE_2;
    fbe_current_size += byte2.fbe_size();

    if ((fbe_current_size + byte3.fbe_size()) <= fbe_struct_size)
        byte3.get(fbe_value.byte3, EnumByte::ENUM_VALUE_3);
    else
        fbe_value.byte3 = EnumByte::ENUM_VALUE_3;
    fbe_current_size += byte3.fbe_size();

    if ((fbe_current_size + byte4.fbe_size()) <= fbe_struct_size)
        byte4.get(fbe_value.byte4, EnumByte::ENUM_VALUE_4);
    else
        fbe_value.byte4 = EnumByte::ENUM_VALUE_4;
    fbe_current_size += byte4.fbe_size();

    if ((fbe_current_size + byte5.fbe_size()) <= fbe_struct_size)
        byte5.get(fbe_value.byte5, EnumByte::ENUM_VALUE_5);
    else
        fbe_value.byte5 = EnumByte::ENUM_VALUE_5;
    fbe_current_size += byte5.fbe_size();

    if ((fbe_current_size + char0.fbe_size()) <= fbe_struct_size)
        char0.get(fbe_value.char0, EnumChar::ENUM_VALUE_0);
    else
        fbe_value.char0 = EnumChar::ENUM_VALUE_0;
    fbe_current_size += char0.fbe_size();

    if ((fbe_current_size + char1.fbe_size()) <= fbe_struct_size)
        char1.get(fbe_value.char1, EnumChar::ENUM_VALUE_1);
    else
        fbe_value.char1 = EnumChar::ENUM_VALUE_1;
    fbe_current_size += char1.fbe_size();

    if ((fbe_current_size + char2.fbe_size()) <= fbe_struct_size)
        char2.get(fbe_value.char2, EnumChar::ENUM_VALUE_2);
    else
        fbe_value.char2 = EnumChar::ENUM_VALUE_2;
    fbe_current_size += char2.fbe_size();

    if ((fbe_current_size + char3.fbe_size()) <= fbe_struct_size)
        char3.get(fbe_value.char3, EnumChar::ENUM_VALUE_3);
    else
        fbe_value.char3 = EnumChar::ENUM_VALUE_3;
    fbe_current_size += char3.fbe_size();

    if ((fbe_current_size + char4.fbe_size()) <= fbe_struct_size)
        char4.get(fbe_value.char4, EnumChar::ENUM_VALUE_4);
    else
        fbe_value.char4 = EnumChar::ENUM_VALUE_4;
    fbe_current_size += char4.fbe_size();

    if ((fbe_current_size + char5.fbe_size()) <= fbe_struct_size)
        char5.get(fbe_value.char5, EnumChar::ENUM_VALUE_5);
    else
        fbe_value.char5 = EnumChar::ENUM_VALUE_5;
    fbe_current_size += char5.fbe_size();

    if ((fbe_current_size + wchar0.fbe_size()) <= fbe_struct_size)
        wchar0.get(fbe_value.wchar0, EnumWChar::ENUM_VALUE_0);
    else
        fbe_value.wchar0 = EnumWChar::ENUM_VALUE_0;
    fbe_current_size += wchar0.fbe_size();

    if ((fbe_current_size + wchar1.fbe_size()) <= fbe_struct_size)
        wchar1.get(fbe_value.wchar1, EnumWChar::ENUM_VALUE_1);
    else
        fbe_value.wchar1 = EnumWChar::ENUM_VALUE_1;
    fbe_current_size += wchar1.fbe_size();

    if ((fbe_current_size + wchar2.fbe_size()) <= fbe_struct_size)
        wchar2.get(fbe_value.wchar2, EnumWChar::ENUM_VALUE_2);
    else
        fbe_value.wchar2 = EnumWChar::ENUM_VALUE_2;
    fbe_current_size += wchar2.fbe_size();

    if ((fbe_current_size + wchar3.fbe_size()) <= fbe_struct_size)
        wchar3.get(fbe_value.wchar3, EnumWChar::ENUM_VALUE_3);
    else
        fbe_value.wchar3 = EnumWChar::ENUM_VALUE_3;
    fbe_current_size += wchar3.fbe_size();

    if ((fbe_current_size + wchar4.fbe_size()) <= fbe_struct_size)
        wchar4.get(fbe_value.wchar4, EnumWChar::ENUM_VALUE_4);
    else
        fbe_value.wchar4 = EnumWChar::ENUM_VALUE_4;
    fbe_current_size += wchar4.fbe_size();

    if ((fbe_current_size + wchar5.fbe_size()) <= fbe_struct_size)
        wchar5.get(fbe_value.wchar5, EnumWChar::ENUM_VALUE_5);
    else
        fbe_value.wchar5 = EnumWChar::ENUM_VALUE_5;
    fbe_current_size += wchar5.fbe_size();

    if ((fbe_current_size + int8b0.fbe_size()) <= fbe_struct_size)
        int8b0.get(fbe_value.int8b0, EnumInt8::ENUM_VALUE_0);
    else
        fbe_value.int8b0 = EnumInt8::ENUM_VALUE_0;
    fbe_current_size += int8b0.fbe_size();

    if ((fbe_current_size + int8b1.fbe_size()) <= fbe_struct_size)
        int8b1.get(fbe_value.int8b1, EnumInt8::ENUM_VALUE_1);
    else
        fbe_value.int8b1 = EnumInt8::ENUM_VALUE_1;
    fbe_current_size += int8b1.fbe_size();

    if ((fbe_current_size + int8b2.fbe_size()) <= fbe_struct_size)
        int8b2.get(fbe_value.int8b2, EnumInt8::ENUM_VALUE_2);
    else
        fbe_value.int8b2 = EnumInt8::ENUM_VALUE_2;
    fbe_current_size += int8b2.fbe_size();

    if ((fbe_current_size + int8b3.fbe_size()) <= fbe_struct_size)
        int8b3.get(fbe_value.int8b3, EnumInt8::ENUM_VALUE_3);
    else
        fbe_value.int8b3 = EnumInt8::ENUM_VALUE_3;
    fbe_current_size += int8b3.fbe_size();

    if ((fbe_current_size + int8b4.fbe_size()) <= fbe_struct_size)
        int8b4.get(fbe_value.int8b4, EnumInt8::ENUM_VALUE_4);
    else
        fbe_value.int8b4 = EnumInt8::ENUM_VALUE_4;
    fbe_current_size += int8b4.fbe_size();

    if ((fbe_current_size + int8b5.fbe_size()) <= fbe_struct_size)
        int8b5.get(fbe_value.int8b5, EnumInt8::ENUM_VALUE_5);
    else
        fbe_value.int8b5 = EnumInt8::ENUM_VALUE_5;
    fbe_current_size += int8b5.fbe_size();

    if ((fbe_current_size + uint8b0.fbe_size()) <= fbe_struct_size)
        uint8b0.get(fbe_value.uint8b0, EnumUInt8::ENUM_VALUE_0);
    else
        fbe_value.uint8b0 = EnumUInt8::ENUM_VALUE_0;
    fbe_current_size += uint8b0.fbe_size();

    if ((fbe_current_size + uint8b1.fbe_size()) <= fbe_struct_size)
        uint8b1.get(fbe_value.uint8b1, EnumUInt8::ENUM_VALUE_1);
    else
        fbe_value.uint8b1 = EnumUInt8::ENUM_VALUE_1;
    fbe_current_size += uint8b1.fbe_size();

    if ((fbe_current_size + uint8b2.fbe_size()) <= fbe_struct_size)
        uint8b2.get(fbe_value.uint8b2, EnumUInt8::ENUM_VALUE_2);
    else
        fbe_value.uint8b2 = EnumUInt8::ENUM_VALUE_2;
    fbe_current_size += uint8b2.fbe_size();

    if ((fbe_current_size + uint8b3.fbe_size()) <= fbe_struct_size)
        uint8b3.get(fbe_value.uint8b3, EnumUInt8::ENUM_VALUE_3);
    else
        fbe_value.uint8b3 = EnumUInt8::ENUM_VALUE_3;
    fbe_current_size += uint8b3.fbe_size();

    if ((fbe_current_size + uint8b4.fbe_size()) <= fbe_struct_size)
        uint8b4.get(fbe_value.uint8b4, EnumUInt8::ENUM_VALUE_4);
    else
        fbe_value.uint8b4 = EnumUInt8::ENUM_VALUE_4;
    fbe_current_size += uint8b4.fbe_size();

    if ((fbe_current_size + uint8b5.fbe_size()) <= fbe_struct_size)
        uint8b5.get(fbe_value.uint8b5, EnumUInt8::ENUM_VALUE_5);
    else
        fbe_value.uint8b5 = EnumUInt8::ENUM_VALUE_5;
    fbe_current_size += uint8b5.fbe_size();

    if ((fbe_current_size + int16b0.fbe_size()) <= fbe_struct_size)
        int16b0.get(fbe_value.int16b0, EnumInt16::ENUM_VALUE_0);
    else
        fbe_value.int16b0 = EnumInt16::ENUM_VALUE_0;
    fbe_current_size += int16b0.fbe_size();

    if ((fbe_current_size + int16b1.fbe_size()) <= fbe_struct_size)
        int16b1.get(fbe_value.int16b1, EnumInt16::ENUM_VALUE_1);
    else
        fbe_value.int16b1 = EnumInt16::ENUM_VALUE_1;
    fbe_current_size += int16b1.fbe_size();

    if ((fbe_current_size + int16b2.fbe_size()) <= fbe_struct_size)
        int16b2.get(fbe_value.int16b2, EnumInt16::ENUM_VALUE_2);
    else
        fbe_value.int16b2 = EnumInt16::ENUM_VALUE_2;
    fbe_current_size += int16b2.fbe_size();

    if ((fbe_current_size + int16b3.fbe_size()) <= fbe_struct_size)
        int16b3.get(fbe_value.int16b3, EnumInt16::ENUM_VALUE_3);
    else
        fbe_value.int16b3 = EnumInt16::ENUM_VALUE_3;
    fbe_current_size += int16b3.fbe_size();

    if ((fbe_current_size + int16b4.fbe_size()) <= fbe_struct_size)
        int16b4.get(fbe_value.int16b4, EnumInt16::ENUM_VALUE_4);
    else
        fbe_value.int16b4 = EnumInt16::ENUM_VALUE_4;
    fbe_current_size += int16b4.fbe_size();

    if ((fbe_current_size + int16b5.fbe_size()) <= fbe_struct_size)
        int16b5.get(fbe_value.int16b5, EnumInt16::ENUM_VALUE_5);
    else
        fbe_value.int16b5 = EnumInt16::ENUM_VALUE_5;
    fbe_current_size += int16b5.fbe_size();

    if ((fbe_current_size + uint16b0.fbe_size()) <= fbe_struct_size)
        uint16b0.get(fbe_value.uint16b0, EnumUInt16::ENUM_VALUE_0);
    else
        fbe_value.uint16b0 = EnumUInt16::ENUM_VALUE_0;
    fbe_current_size += uint16b0.fbe_size();

    if ((fbe_current_size + uint16b1.fbe_size()) <= fbe_struct_size)
        uint16b1.get(fbe_value.uint16b1, EnumUInt16::ENUM_VALUE_1);
    else
        fbe_value.uint16b1 = EnumUInt16::ENUM_VALUE_1;
    fbe_current_size += uint16b1.fbe_size();

    if ((fbe_current_size + uint16b2.fbe_size()) <= fbe_struct_size)
        uint16b2.get(fbe_value.uint16b2, EnumUInt16::ENUM_VALUE_2);
    else
        fbe_value.uint16b2 = EnumUInt16::ENUM_VALUE_2;
    fbe_current_size += uint16b2.fbe_size();

    if ((fbe_current_size + uint16b3.fbe_size()) <= fbe_struct_size)
        uint16b3.get(fbe_value.uint16b3, EnumUInt16::ENUM_VALUE_3);
    else
        fbe_value.uint16b3 = EnumUInt16::ENUM_VALUE_3;
    fbe_current_size += uint16b3.fbe_size();

    if ((fbe_current_size + uint16b4.fbe_size()) <= fbe_struct_size)
        uint16b4.get(fbe_value.uint16b4, EnumUInt16::ENUM_VALUE_4);
    else
        fbe_value.uint16b4 = EnumUInt16::ENUM_VALUE_4;
    fbe_current_size += uint16b4.fbe_size();

    if ((fbe_current_size + uint16b5.fbe_size()) <= fbe_struct_size)
        uint16b5.get(fbe_value.uint16b5, EnumUInt16::ENUM_VALUE_5);
    else
        fbe_value.uint16b5 = EnumUInt16::ENUM_VALUE_5;
    fbe_current_size += uint16b5.fbe_size();

    if ((fbe_current_size + int32b0.fbe_size()) <= fbe_struct_size)
        int32b0.get(fbe_value.int32b0, EnumInt32::ENUM_VALUE_0);
    else
        fbe_value.int32b0 = EnumInt32::ENUM_VALUE_0;
    fbe_current_size += int32b0.fbe_size();

    if ((fbe_current_size + int32b1.fbe_size()) <= fbe_struct_size)
        int32b1.get(fbe_value.int32b1, EnumInt32::ENUM_VALUE_1);
    else
        fbe_value.int32b1 = EnumInt32::ENUM_VALUE_1;
    fbe_current_size += int32b1.fbe_size();

    if ((fbe_current_size + int32b2.fbe_size()) <= fbe_struct_size)
        int32b2.get(fbe_value.int32b2, EnumInt32::ENUM_VALUE_2);
    else
        fbe_value.int32b2 = EnumInt32::ENUM_VALUE_2;
    fbe_current_size += int32b2.fbe_size();

    if ((fbe_current_size + int32b3.fbe_size()) <= fbe_struct_size)
        int32b3.get(fbe_value.int32b3, EnumInt32::ENUM_VALUE_3);
    else
        fbe_value.int32b3 = EnumInt32::ENUM_VALUE_3;
    fbe_current_size += int32b3.fbe_size();

    if ((fbe_current_size + int32b4.fbe_size()) <= fbe_struct_size)
        int32b4.get(fbe_value.int32b4, EnumInt32::ENUM_VALUE_4);
    else
        fbe_value.int32b4 = EnumInt32::ENUM_VALUE_4;
    fbe_current_size += int32b4.fbe_size();

    if ((fbe_current_size + int32b5.fbe_size()) <= fbe_struct_size)
        int32b5.get(fbe_value.int32b5, EnumInt32::ENUM_VALUE_5);
    else
        fbe_value.int32b5 = EnumInt32::ENUM_VALUE_5;
    fbe_current_size += int32b5.fbe_size();

    if ((fbe_current_size + uint32b0.fbe_size()) <= fbe_struct_size)
        uint32b0.get(fbe_value.uint32b0, EnumUInt32::ENUM_VALUE_0);
    else
        fbe_value.uint32b0 = EnumUInt32::ENUM_VALUE_0;
    fbe_current_size += uint32b0.fbe_size();

    if ((fbe_current_size + uint32b1.fbe_size()) <= fbe_struct_size)
        uint32b1.get(fbe_value.uint32b1, EnumUInt32::ENUM_VALUE_1);
    else
        fbe_value.uint32b1 = EnumUInt32::ENUM_VALUE_1;
    fbe_current_size += uint32b1.fbe_size();

    if ((fbe_current_size + uint32b2.fbe_size()) <= fbe_struct_size)
        uint32b2.get(fbe_value.uint32b2, EnumUInt32::ENUM_VALUE_2);
    else
        fbe_value.uint32b2 = EnumUInt32::ENUM_VALUE_2;
    fbe_current_size += uint32b2.fbe_size();

    if ((fbe_current_size + uint32b3.fbe_size()) <= fbe_struct_size)
        uint32b3.get(fbe_value.uint32b3, EnumUInt32::ENUM_VALUE_3);
    else
        fbe_value.uint32b3 = EnumUInt32::ENUM_VALUE_3;
    fbe_current_size += uint32b3.fbe_size();

    if ((fbe_current_size + uint32b4.fbe_size()) <= fbe_struct_size)
        uint32b4.get(fbe_value.uint32b4, EnumUInt32::ENUM_VALUE_4);
    else
        fbe_value.uint32b4 = EnumUInt32::ENUM_VALUE_4;
    fbe_current_size += uint32b4.fbe_size();

    if ((fbe_current_size + uint32b5.fbe_size()) <= fbe_struct_size)
        uint32b5.get(fbe_value.uint32b5, EnumUInt32::ENUM_VALUE_5);
    else
        fbe_value.uint32b5 = EnumUInt32::ENUM_VALUE_5;
    fbe_current_size += uint32b5.fbe_size();

    if ((fbe_current_size + int64b0.fbe_size()) <= fbe_struct_size)
        int64b0.get(fbe_value.int64b0, EnumInt64::ENUM_VALUE_0);
    else
        fbe_value.int64b0 = EnumInt64::ENUM_VALUE_0;
    fbe_current_size += int64b0.fbe_size();

    if ((fbe_current_size + int64b1.fbe_size()) <= fbe_struct_size)
        int64b1.get(fbe_value.int64b1, EnumInt64::ENUM_VALUE_1);
    else
        fbe_value.int64b1 = EnumInt64::ENUM_VALUE_1;
    fbe_current_size += int64b1.fbe_size();

    if ((fbe_current_size + int64b2.fbe_size()) <= fbe_struct_size)
        int64b2.get(fbe_value.int64b2, EnumInt64::ENUM_VALUE_2);
    else
        fbe_value.int64b2 = EnumInt64::ENUM_VALUE_2;
    fbe_current_size += int64b2.fbe_size();

    if ((fbe_current_size + int64b3.fbe_size()) <= fbe_struct_size)
        int64b3.get(fbe_value.int64b3, EnumInt64::ENUM_VALUE_3);
    else
        fbe_value.int64b3 = EnumInt64::ENUM_VALUE_3;
    fbe_current_size += int64b3.fbe_size();

    if ((fbe_current_size + int64b4.fbe_size()) <= fbe_struct_size)
        int64b4.get(fbe_value.int64b4, EnumInt64::ENUM_VALUE_4);
    else
        fbe_value.int64b4 = EnumInt64::ENUM_VALUE_4;
    fbe_current_size += int64b4.fbe_size();

    if ((fbe_current_size + int64b5.fbe_size()) <= fbe_struct_size)
        int64b5.get(fbe_value.int64b5, EnumInt64::ENUM_VALUE_5);
    else
        fbe_value.int64b5 = EnumInt64::ENUM_VALUE_5;
    fbe_current_size += int64b5.fbe_size();

    if ((fbe_current_size + uint64b0.fbe_size()) <= fbe_struct_size)
        uint64b0.get(fbe_value.uint64b0, EnumUInt64::ENUM_VALUE_0);
    else
        fbe_value.uint64b0 = EnumUInt64::ENUM_VALUE_0;
    fbe_current_size += uint64b0.fbe_size();

    if ((fbe_current_size + uint64b1.fbe_size()) <= fbe_struct_size)
        uint64b1.get(fbe_value.uint64b1, EnumUInt64::ENUM_VALUE_1);
    else
        fbe_value.uint64b1 = EnumUInt64::ENUM_VALUE_1;
    fbe_current_size += uint64b1.fbe_size();

    if ((fbe_current_size + uint64b2.fbe_size()) <= fbe_struct_size)
        uint64b2.get(fbe_value.uint64b2, EnumUInt64::ENUM_VALUE_2);
    else
        fbe_value.uint64b2 = EnumUInt64::ENUM_VALUE_2;
    fbe_current_size += uint64b2.fbe_size();

    if ((fbe_current_size + uint64b3.fbe_size()) <= fbe_struct_size)
        uint64b3.get(fbe_value.uint64b3, EnumUInt64::ENUM_VALUE_3);
    else
        fbe_value.uint64b3 = EnumUInt64::ENUM_VALUE_3;
    fbe_current_size += uint64b3.fbe_size();

    if ((fbe_current_size + uint64b4.fbe_size()) <= fbe_struct_size)
        uint64b4.get(fbe_value.uint64b4, EnumUInt64::ENUM_VALUE_4);
    else
        fbe_value.uint64b4 = EnumUInt64::ENUM_VALUE_4;
    fbe_current_size += uint64b4.fbe_size();

    if ((fbe_current_size + uint64b5.fbe_size()) <= fbe_struct_size)
        uint64b5.get(fbe_value.uint64b5, EnumUInt64::ENUM_VALUE_5);
    else
        fbe_value.uint64b5 = EnumUInt64::ENUM_VALUE_5;
    fbe_current_size += uint64b5.fbe_size();
}

size_t FieldModel<::enums::Enums>::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_struct_offset;
    *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset)) = fbe_struct_size;
    *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4)) = (uint32_t)fbe_type();

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel<::enums::Enums>::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel<::enums::Enums>::set(const ::enums::Enums& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel<::enums::Enums>::set_fields(const ::enums::Enums& fbe_value) noexcept
{
    byte0.set(fbe_value.byte0);
    byte1.set(fbe_value.byte1);
    byte2.set(fbe_value.byte2);
    byte3.set(fbe_value.byte3);
    byte4.set(fbe_value.byte4);
    byte5.set(fbe_value.byte5);
    char0.set(fbe_value.char0);
    char1.set(fbe_value.char1);
    char2.set(fbe_value.char2);
    char3.set(fbe_value.char3);
    char4.set(fbe_value.char4);
    char5.set(fbe_value.char5);
    wchar0.set(fbe_value.wchar0);
    wchar1.set(fbe_value.wchar1);
    wchar2.set(fbe_value.wchar2);
    wchar3.set(fbe_value.wchar3);
    wchar4.set(fbe_value.wchar4);
    wchar5.set(fbe_value.wchar5);
    int8b0.set(fbe_value.int8b0);
    int8b1.set(fbe_value.int8b1);
    int8b2.set(fbe_value.int8b2);
    int8b3.set(fbe_value.int8b3);
    int8b4.set(fbe_value.int8b4);
    int8b5.set(fbe_value.int8b5);
    uint8b0.set(fbe_value.uint8b0);
    uint8b1.set(fbe_value.uint8b1);
    uint8b2.set(fbe_value.uint8b2);
    uint8b3.set(fbe_value.uint8b3);
    uint8b4.set(fbe_value.uint8b4);
    uint8b5.set(fbe_value.uint8b5);
    int16b0.set(fbe_value.int16b0);
    int16b1.set(fbe_value.int16b1);
    int16b2.set(fbe_value.int16b2);
    int16b3.set(fbe_value.int16b3);
    int16b4.set(fbe_value.int16b4);
    int16b5.set(fbe_value.int16b5);
    uint16b0.set(fbe_value.uint16b0);
    uint16b1.set(fbe_value.uint16b1);
    uint16b2.set(fbe_value.uint16b2);
    uint16b3.set(fbe_value.uint16b3);
    uint16b4.set(fbe_value.uint16b4);
    uint16b5.set(fbe_value.uint16b5);
    int32b0.set(fbe_value.int32b0);
    int32b1.set(fbe_value.int32b1);
    int32b2.set(fbe_value.int32b2);
    int32b3.set(fbe_value.int32b3);
    int32b4.set(fbe_value.int32b4);
    int32b5.set(fbe_value.int32b5);
    uint32b0.set(fbe_value.uint32b0);
    uint32b1.set(fbe_value.uint32b1);
    uint32b2.set(fbe_value.uint32b2);
    uint32b3.set(fbe_value.uint32b3);
    uint32b4.set(fbe_value.uint32b4);
    uint32b5.set(fbe_value.uint32b5);
    int64b0.set(fbe_value.int64b0);
    int64b1.set(fbe_value.int64b1);
    int64b2.set(fbe_value.int64b2);
    int64b3.set(fbe_value.int64b3);
    int64b4.set(fbe_value.int64b4);
    int64b5.set(fbe_value.int64b5);
    uint64b0.set(fbe_value.uint64b0);
    uint64b1.set(fbe_value.uint64b1);
    uint64b2.set(fbe_value.uint64b2);
    uint64b3.set(fbe_value.uint64b3);
    uint64b4.set(fbe_value.uint64b4);
    uint64b5.set(fbe_value.uint64b5);
}

namespace enums {

bool EnumsModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t EnumsModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t EnumsModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t EnumsModel::serialize(const ::enums::Enums& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t EnumsModel::deserialize(::enums::Enums& value) const noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace enums

} // namespace FBE

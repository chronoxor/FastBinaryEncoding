//------------------------------------------------------------------------------
// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: test.fbe
// FBE version: 1.14.5.0
//------------------------------------------------------------------------------

package com.chronoxor.test;

public class StructHashEx implements Comparable<Object>
{
    public java.util.HashMap<StructSimple, StructNested> f1 = new java.util.HashMap<StructSimple, StructNested>();
    public java.util.HashMap<StructSimple, StructNested> f2 = new java.util.HashMap<StructSimple, StructNested>();

    public static final long fbeTypeConst = 142;
    public long fbeType() { return fbeTypeConst; }

    public StructHashEx() {}

    public StructHashEx(java.util.HashMap<StructSimple, StructNested> f1, java.util.HashMap<StructSimple, StructNested> f2)
    {
        this.f1 = f1;
        this.f2 = f2;
    }

    public StructHashEx(StructHashEx other)
    {
        this.f1 = other.f1;
        this.f2 = other.f2;
    }

    public StructHashEx clone()
    {
        // Serialize the struct to the FBE stream
        var writer = new com.chronoxor.test.fbe.StructHashExModel();
        writer.serialize(this);

        // Deserialize the struct from the FBE stream
        var reader = new com.chronoxor.test.fbe.StructHashExModel();
        reader.attach(writer.getBuffer());
        return reader.deserialize();
    }

    @Override
    public int compareTo(Object other)
    {
        if (other == null)
            return -1;

        if (!StructHashEx.class.isAssignableFrom(other.getClass()))
            return -1;

        final StructHashEx obj = (StructHashEx)other;

        int result = 0;
        return result;
    }

    @Override
    public boolean equals(Object other)
    {
        if (other == null)
            return false;

        if (!StructHashEx.class.isAssignableFrom(other.getClass()))
            return false;

        final StructHashEx obj = (StructHashEx)other;

        return true;
    }

    @Override
    public int hashCode()
    {
        int hash = 17;
        return hash;
    }

    @Override
    public String toString()
    {
        var sb = new StringBuilder();
        sb.append("StructHashEx(");
        if (f1 != null)
        {
            boolean first = true;
            sb.append("f1=[").append(f1.size()).append("][{");
            for (var item : f1.entrySet())
            {
                sb.append(first ? "" : ",").append(item.getKey());
                sb.append("->");
                sb.append(item.getValue());
                first = false;
            }
            sb.append("}]");
        }
        else
            sb.append("f1=[0][{}]");
        if (f2 != null)
        {
            boolean first = true;
            sb.append(",f2=[").append(f2.size()).append("][{");
            for (var item : f2.entrySet())
            {
                sb.append(first ? "" : ",").append(item.getKey());
                sb.append("->");
                if (item.getValue() != null) sb.append(item.getValue()); else sb.append("null");
                first = false;
            }
            sb.append("}]");
        }
        else
            sb.append(",f2=[0][{}]");
        sb.append(")");
        return sb.toString();
    }

    public String toJson() { return com.chronoxor.test.fbe.Json.getEngine().toJson(this); }
    public static StructHashEx fromJson(String json) { return com.chronoxor.test.fbe.Json.getEngine().fromJson(json, StructHashEx.class); }
}

//------------------------------------------------------------------------------
// <auto-generated>
//     Automatically generated by the Fast Binary Encoding compiler, do not modify!
//     https://github.com/chronoxor/FastBinaryEncoding
//     Source: test.fbe
//     FBE version: 1.14.5.0
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Numerics;
using System.Runtime.Serialization;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
#if UTF8JSON
using Utf8Json;
using Utf8Json.Resolvers;
#elif NEWTONSOFTJSON
using Newtonsoft.Json;
#else
using System.Text.Json;
using System.Text.Json.Serialization;
#endif

using com.chronoxor.proto;

namespace com.chronoxor.test {

#if UTF8JSON
    public class EnumSimpleConverter : IJsonFormatter<EnumSimple>
    {
        public void Serialize(ref JsonWriter writer, EnumSimple value, IJsonFormatterResolver jsonFormatterResolver)
        {
            writer.WriteInt32(value.Value);
        }

        public EnumSimple Deserialize(ref JsonReader reader, IJsonFormatterResolver jsonFormatterResolver)
        {
            return new EnumSimple(reader.ReadInt32());
        }
    }

    [JsonFormatter(typeof(EnumSimpleConverter))]
#elif NEWTONSOFTJSON
    public class EnumSimpleConverter : JsonConverter
    {
        public override bool CanConvert(Type objectType)
        {
            return objectType == typeof(EnumSimple);
        }

        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
        {
            writer.WriteValue(((EnumSimple)value).Value);
        }

        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
        {
            if (reader.Value == null)
                return null;

            switch (reader.Value)
            {
                case long longValue:
                    return new EnumSimple((int)longValue);
                case BigInteger bigValue:
                    return new EnumSimple((int)bigValue);
                default:
                    return null;
            }
        }
    }

    [JsonConverter(typeof(EnumSimpleConverter))]
#else
    public class EnumSimpleConverter : JsonConverter<EnumSimple>
    {
        public override void Write(Utf8JsonWriter writer, EnumSimple value, JsonSerializerOptions options) => writer.WriteNumberValue(value.Value);
        public override EnumSimple Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => new EnumSimple(reader.GetInt32());
    }

    [JsonConverter(typeof(EnumSimpleConverter))]
#endif
    public struct EnumSimple : IComparable, IComparable<EnumSimple>, IEquatable<EnumSimple>
    {
        public int Value { get; internal set; }

        public EnumSimple(int value) : this()
        {
            Value = value;
        }

        public EnumSimple(EnumSimple value) : this()
        {
            Value = value.Value;
        }

        public int CompareTo(object other)
        {
            return Value.CompareTo(((EnumSimple)other).Value);
        }

        public int CompareTo(EnumSimple other)
        {
            return Value.CompareTo(other.Value);
        }

        public override bool Equals(object other)
        {
            return (other is EnumSimple value) && Value.Equals(value.Value);
        }

        public bool Equals(EnumSimple other)
        {
            return Value.Equals(other.Value);
        }

        public override int GetHashCode()
        {
            return Value.GetHashCode();
        }

        public static bool operator==(EnumSimple value1, EnumSimple value2)
        {
            return value1.Value == value2.Value;
        }

        public static bool operator!=(EnumSimple value1, EnumSimple value2)
        {
            return value1.Value != value2.Value;
        }

        public static EnumSimple Default => new EnumSimple();

        public static com.chronoxor.FBE.FieldModelValueType<EnumSimple> CreateFieldModel(com.chronoxor.FBE.Buffer buffer, long offset) { return new test.FBE.FieldModelEnumSimple(buffer, offset); }

        public const int _ENUM_VALUE_0_ = (int)0 + 0;
        public const int _ENUM_VALUE_1_ = (int)1 + 0;
        public const int _ENUM_VALUE_2_ = (int)1 + 1;
        public const int _ENUM_VALUE_3_ = (int)3 + 0;
        public const int _ENUM_VALUE_4_ = (int)0x4 + 0;
        public const int _ENUM_VALUE_5_ = _ENUM_VALUE_3_;

        public static EnumSimple ENUM_VALUE_0 = new EnumSimple(_ENUM_VALUE_0_);
        public static EnumSimple ENUM_VALUE_1 = new EnumSimple(_ENUM_VALUE_1_);
        public static EnumSimple ENUM_VALUE_2 = new EnumSimple(_ENUM_VALUE_2_);
        public static EnumSimple ENUM_VALUE_3 = new EnumSimple(_ENUM_VALUE_3_);
        public static EnumSimple ENUM_VALUE_4 = new EnumSimple(_ENUM_VALUE_4_);
        public static EnumSimple ENUM_VALUE_5 = new EnumSimple(_ENUM_VALUE_5_);

        public override string ToString()
        {
            if (this == ENUM_VALUE_0) return "ENUM_VALUE_0";
            if (this == ENUM_VALUE_1) return "ENUM_VALUE_1";
            if (this == ENUM_VALUE_2) return "ENUM_VALUE_2";
            if (this == ENUM_VALUE_3) return "ENUM_VALUE_3";
            if (this == ENUM_VALUE_4) return "ENUM_VALUE_4";
            if (this == ENUM_VALUE_5) return "ENUM_VALUE_5";
            return "<unknown>";
        }
    }

} // namespace com.chronoxor.test

namespace com.chronoxor.test.FBE {

    using global::com.chronoxor.test;

    // Fast Binary Encoding EnumSimple field model
    public class FieldModelEnumSimple : com.chronoxor.FBE.FieldModelValueType<EnumSimple>
    {
        public FieldModelEnumSimple(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset) {}

        // Get the field size
        public override long FBESize => 4;

        // Clone the field model
        public override com.chronoxor.FBE.FieldModelValueType<EnumSimple> Clone() { return new FieldModelEnumSimple(_buffer, _offset); }

        // Get the value
        public override void Get(out EnumSimple value) { Get(out value, EnumSimple.Default); }
        public override void Get(out EnumSimple value, EnumSimple defaults)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
            {
                value = defaults;
                return;
            }

            value = new EnumSimple((int)ReadInt32(FBEOffset));
        }

        // Set the value
        public override void Set(EnumSimple value)
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return;

            Write(FBEOffset, value.Value);
        }
    }

} // namespace com.chronoxor.test.FBE

namespace com.chronoxor.test.FBE {

    using global::com.chronoxor.test;

    // Fast Binary Encoding EnumSimple final model
    public class FinalModelEnumSimple : com.chronoxor.FBE.FinalModelValueType<EnumSimple>
    {
        public FinalModelEnumSimple(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset) {}

        // Get the allocation size
        public override long FBEAllocationSize(EnumSimple value) { return FBESize; }

        // Get the final size
        public override long FBESize => 4;

        // Clone the final model
        public override com.chronoxor.FBE.FinalModelValueType<EnumSimple> Clone() { return new FinalModelEnumSimple(_buffer, _offset); }

        // Check if the value is valid
        public override long Verify()
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return long.MaxValue;

            return FBESize;
        }

        // Get the value
        public override long Get(out EnumSimple value)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
            {
                value = EnumSimple.Default;
                return 0;
            }

            value = new EnumSimple((int)ReadInt32(FBEOffset));
            return FBESize;
        }

        // Set the value
        public override long Set(EnumSimple value)
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            Write(FBEOffset, value.Value);
            return FBESize;
        }
    }

} // namespace com.chronoxor.test.FBE

namespace com.chronoxor.test {

#if UTF8JSON
    public class EnumTypedConverter : IJsonFormatter<EnumTyped>
    {
        public void Serialize(ref JsonWriter writer, EnumTyped value, IJsonFormatterResolver jsonFormatterResolver)
        {
            writer.WriteByte(value.Value);
        }

        public EnumTyped Deserialize(ref JsonReader reader, IJsonFormatterResolver jsonFormatterResolver)
        {
            return new EnumTyped(reader.ReadByte());
        }
    }

    [JsonFormatter(typeof(EnumTypedConverter))]
#elif NEWTONSOFTJSON
    public class EnumTypedConverter : JsonConverter
    {
        public override bool CanConvert(Type objectType)
        {
            return objectType == typeof(EnumTyped);
        }

        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
        {
            writer.WriteValue(((EnumTyped)value).Value);
        }

        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
        {
            if (reader.Value == null)
                return null;

            switch (reader.Value)
            {
                case long longValue:
                    return new EnumTyped((byte)longValue);
                case BigInteger bigValue:
                    return new EnumTyped((byte)bigValue);
                default:
                    return null;
            }
        }
    }

    [JsonConverter(typeof(EnumTypedConverter))]
#else
    public class EnumTypedConverter : JsonConverter<EnumTyped>
    {
        public override void Write(Utf8JsonWriter writer, EnumTyped value, JsonSerializerOptions options) => writer.WriteNumberValue(value.Value);
        public override EnumTyped Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => new EnumTyped(reader.GetByte());
    }

    [JsonConverter(typeof(EnumTypedConverter))]
#endif
    public struct EnumTyped : IComparable, IComparable<EnumTyped>, IEquatable<EnumTyped>
    {
        public byte Value { get; internal set; }

        public EnumTyped(byte value) : this()
        {
            Value = value;
        }

        public EnumTyped(EnumTyped value) : this()
        {
            Value = value.Value;
        }

        public int CompareTo(object other)
        {
            return Value.CompareTo(((EnumTyped)other).Value);
        }

        public int CompareTo(EnumTyped other)
        {
            return Value.CompareTo(other.Value);
        }

        public override bool Equals(object other)
        {
            return (other is EnumTyped value) && Value.Equals(value.Value);
        }

        public bool Equals(EnumTyped other)
        {
            return Value.Equals(other.Value);
        }

        public override int GetHashCode()
        {
            return Value.GetHashCode();
        }

        public static bool operator==(EnumTyped value1, EnumTyped value2)
        {
            return value1.Value == value2.Value;
        }

        public static bool operator!=(EnumTyped value1, EnumTyped value2)
        {
            return value1.Value != value2.Value;
        }

        public static EnumTyped Default => new EnumTyped();

        public static com.chronoxor.FBE.FieldModelValueType<EnumTyped> CreateFieldModel(com.chronoxor.FBE.Buffer buffer, long offset) { return new test.FBE.FieldModelEnumTyped(buffer, offset); }

        public const byte _ENUM_VALUE_0_ = (byte)0 + 0;
        public const byte _ENUM_VALUE_1_ = (byte)'1' + 0;
        public const byte _ENUM_VALUE_2_ = (byte)'1' + 1;
        public const byte _ENUM_VALUE_3_ = (byte)'3' + 0;
        public const byte _ENUM_VALUE_4_ = (byte)'3' + 1;
        public const byte _ENUM_VALUE_5_ = _ENUM_VALUE_3_;

        public static EnumTyped ENUM_VALUE_0 = new EnumTyped(_ENUM_VALUE_0_);
        public static EnumTyped ENUM_VALUE_1 = new EnumTyped(_ENUM_VALUE_1_);
        public static EnumTyped ENUM_VALUE_2 = new EnumTyped(_ENUM_VALUE_2_);
        public static EnumTyped ENUM_VALUE_3 = new EnumTyped(_ENUM_VALUE_3_);
        public static EnumTyped ENUM_VALUE_4 = new EnumTyped(_ENUM_VALUE_4_);
        public static EnumTyped ENUM_VALUE_5 = new EnumTyped(_ENUM_VALUE_5_);

        public override string ToString()
        {
            if (this == ENUM_VALUE_0) return "ENUM_VALUE_0";
            if (this == ENUM_VALUE_1) return "ENUM_VALUE_1";
            if (this == ENUM_VALUE_2) return "ENUM_VALUE_2";
            if (this == ENUM_VALUE_3) return "ENUM_VALUE_3";
            if (this == ENUM_VALUE_4) return "ENUM_VALUE_4";
            if (this == ENUM_VALUE_5) return "ENUM_VALUE_5";
            return "<unknown>";
        }
    }

} // namespace com.chronoxor.test

namespace com.chronoxor.test.FBE {

    using global::com.chronoxor.test;

    // Fast Binary Encoding EnumTyped field model
    public class FieldModelEnumTyped : com.chronoxor.FBE.FieldModelValueType<EnumTyped>
    {
        public FieldModelEnumTyped(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset) {}

        // Get the field size
        public override long FBESize => 1;

        // Clone the field model
        public override com.chronoxor.FBE.FieldModelValueType<EnumTyped> Clone() { return new FieldModelEnumTyped(_buffer, _offset); }

        // Get the value
        public override void Get(out EnumTyped value) { Get(out value, EnumTyped.Default); }
        public override void Get(out EnumTyped value, EnumTyped defaults)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
            {
                value = defaults;
                return;
            }

            value = new EnumTyped((byte)ReadUInt8(FBEOffset));
        }

        // Set the value
        public override void Set(EnumTyped value)
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return;

            Write(FBEOffset, value.Value);
        }
    }

} // namespace com.chronoxor.test.FBE

namespace com.chronoxor.test.FBE {

    using global::com.chronoxor.test;

    // Fast Binary Encoding EnumTyped final model
    public class FinalModelEnumTyped : com.chronoxor.FBE.FinalModelValueType<EnumTyped>
    {
        public FinalModelEnumTyped(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset) {}

        // Get the allocation size
        public override long FBEAllocationSize(EnumTyped value) { return FBESize; }

        // Get the final size
        public override long FBESize => 1;

        // Clone the final model
        public override com.chronoxor.FBE.FinalModelValueType<EnumTyped> Clone() { return new FinalModelEnumTyped(_buffer, _offset); }

        // Check if the value is valid
        public override long Verify()
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return long.MaxValue;

            return FBESize;
        }

        // Get the value
        public override long Get(out EnumTyped value)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
            {
                value = EnumTyped.Default;
                return 0;
            }

            value = new EnumTyped((byte)ReadUInt8(FBEOffset));
            return FBESize;
        }

        // Set the value
        public override long Set(EnumTyped value)
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            Write(FBEOffset, value.Value);
            return FBESize;
        }
    }

} // namespace com.chronoxor.test.FBE

namespace com.chronoxor.test {

#if UTF8JSON
    public class EnumEmptyConverter : IJsonFormatter<EnumEmpty>
    {
        public void Serialize(ref JsonWriter writer, EnumEmpty value, IJsonFormatterResolver jsonFormatterResolver)
        {
            writer.WriteInt32(value.Value);
        }

        public EnumEmpty Deserialize(ref JsonReader reader, IJsonFormatterResolver jsonFormatterResolver)
        {
            return new EnumEmpty(reader.ReadInt32());
        }
    }

    [JsonFormatter(typeof(EnumEmptyConverter))]
#elif NEWTONSOFTJSON
    public class EnumEmptyConverter : JsonConverter
    {
        public override bool CanConvert(Type objectType)
        {
            return objectType == typeof(EnumEmpty);
        }

        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
        {
            writer.WriteValue(((EnumEmpty)value).Value);
        }

        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
        {
            if (reader.Value == null)
                return null;

            switch (reader.Value)
            {
                case long longValue:
                    return new EnumEmpty((int)longValue);
                case BigInteger bigValue:
                    return new EnumEmpty((int)bigValue);
                default:
                    return null;
            }
        }
    }

    [JsonConverter(typeof(EnumEmptyConverter))]
#else
    public class EnumEmptyConverter : JsonConverter<EnumEmpty>
    {
        public override void Write(Utf8JsonWriter writer, EnumEmpty value, JsonSerializerOptions options) => writer.WriteNumberValue(value.Value);
        public override EnumEmpty Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => new EnumEmpty(reader.GetInt32());
    }

    [JsonConverter(typeof(EnumEmptyConverter))]
#endif
    public struct EnumEmpty : IComparable, IComparable<EnumEmpty>, IEquatable<EnumEmpty>
    {
        public int Value { get; internal set; }

        public EnumEmpty(int value) : this()
        {
            Value = value;
        }

        public EnumEmpty(EnumEmpty value) : this()
        {
            Value = value.Value;
        }

        public int CompareTo(object other)
        {
            return Value.CompareTo(((EnumEmpty)other).Value);
        }

        public int CompareTo(EnumEmpty other)
        {
            return Value.CompareTo(other.Value);
        }

        public override bool Equals(object other)
        {
            return (other is EnumEmpty value) && Value.Equals(value.Value);
        }

        public bool Equals(EnumEmpty other)
        {
            return Value.Equals(other.Value);
        }

        public override int GetHashCode()
        {
            return Value.GetHashCode();
        }

        public static bool operator==(EnumEmpty value1, EnumEmpty value2)
        {
            return value1.Value == value2.Value;
        }

        public static bool operator!=(EnumEmpty value1, EnumEmpty value2)
        {
            return value1.Value != value2.Value;
        }

        public static EnumEmpty Default => new EnumEmpty();

        public static com.chronoxor.FBE.FieldModelValueType<EnumEmpty> CreateFieldModel(com.chronoxor.FBE.Buffer buffer, long offset) { return new test.FBE.FieldModelEnumEmpty(buffer, offset); }



        public override string ToString()
        {
            return "<empty>";
        }
    }

} // namespace com.chronoxor.test

namespace com.chronoxor.test.FBE {

    using global::com.chronoxor.test;

    // Fast Binary Encoding EnumEmpty field model
    public class FieldModelEnumEmpty : com.chronoxor.FBE.FieldModelValueType<EnumEmpty>
    {
        public FieldModelEnumEmpty(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset) {}

        // Get the field size
        public override long FBESize => 4;

        // Clone the field model
        public override com.chronoxor.FBE.FieldModelValueType<EnumEmpty> Clone() { return new FieldModelEnumEmpty(_buffer, _offset); }

        // Get the value
        public override void Get(out EnumEmpty value) { Get(out value, EnumEmpty.Default); }
        public override void Get(out EnumEmpty value, EnumEmpty defaults)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
            {
                value = defaults;
                return;
            }

            value = new EnumEmpty((int)ReadInt32(FBEOffset));
        }

        // Set the value
        public override void Set(EnumEmpty value)
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return;

            Write(FBEOffset, value.Value);
        }
    }

} // namespace com.chronoxor.test.FBE

namespace com.chronoxor.test.FBE {

    using global::com.chronoxor.test;

    // Fast Binary Encoding EnumEmpty final model
    public class FinalModelEnumEmpty : com.chronoxor.FBE.FinalModelValueType<EnumEmpty>
    {
        public FinalModelEnumEmpty(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset) {}

        // Get the allocation size
        public override long FBEAllocationSize(EnumEmpty value) { return FBESize; }

        // Get the final size
        public override long FBESize => 4;

        // Clone the final model
        public override com.chronoxor.FBE.FinalModelValueType<EnumEmpty> Clone() { return new FinalModelEnumEmpty(_buffer, _offset); }

        // Check if the value is valid
        public override long Verify()
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return long.MaxValue;

            return FBESize;
        }

        // Get the value
        public override long Get(out EnumEmpty value)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
            {
                value = EnumEmpty.Default;
                return 0;
            }

            value = new EnumEmpty((int)ReadInt32(FBEOffset));
            return FBESize;
        }

        // Set the value
        public override long Set(EnumEmpty value)
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            Write(FBEOffset, value.Value);
            return FBESize;
        }
    }

} // namespace com.chronoxor.test.FBE

namespace com.chronoxor.test {

#if UTF8JSON
    public class FlagsSimpleConverter : IJsonFormatter<FlagsSimple>
    {
        public void Serialize(ref JsonWriter writer, FlagsSimple value, IJsonFormatterResolver jsonFormatterResolver)
        {
            writer.WriteInt32(value.Value);
        }

        public FlagsSimple Deserialize(ref JsonReader reader, IJsonFormatterResolver jsonFormatterResolver)
        {
            return new FlagsSimple(reader.ReadInt32());
        }
    }

    [JsonFormatter(typeof(FlagsSimpleConverter))]
#elif NEWTONSOFTJSON
    public class FlagsSimpleConverter : JsonConverter
    {
        public override bool CanConvert(Type objectType)
        {
            return objectType == typeof(FlagsSimple);
        }

        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
        {
            writer.WriteValue(((FlagsSimple)value).Value);
        }

        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
        {
            if (reader.Value == null)
                return null;

            switch (reader.Value)
            {
                case long longValue:
                    return new FlagsSimple((int)longValue);
                case BigInteger bigValue:
                    return new FlagsSimple((int)bigValue);
                default:
                    return null;
            }
        }
    }

    [JsonConverter(typeof(FlagsSimpleConverter))]
#else
    public class FlagsSimpleConverter : JsonConverter<FlagsSimple>
    {
        public override void Write(Utf8JsonWriter writer, FlagsSimple value, JsonSerializerOptions options) => writer.WriteNumberValue(value.Value);
        public override FlagsSimple Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => new FlagsSimple(reader.GetInt32());
    }

    [JsonConverter(typeof(FlagsSimpleConverter))]
#endif
    public struct FlagsSimple : IComparable, IComparable<FlagsSimple>, IEquatable<FlagsSimple>
    {
        public int Value { get; internal set; }

        public FlagsSimple(int value) : this()
        {
            Value = value;
        }

        public FlagsSimple(FlagsSimple value) : this()
        {
            Value = value.Value;
        }

        public bool HasFlags(FlagsSimple flags)
        {
            return (((Value & flags.Value) != 0) && ((Value & flags.Value) == flags.Value));
        }

        public FlagsSimple SetFlags(FlagsSimple flags)
        {
            Value |= flags.Value;
            return this;
        }

        public FlagsSimple RemoveFlags(FlagsSimple flags)
        {
            Value &= (byte)~flags.Value;
            return this;
        }

        public int CompareTo(object other)
        {
            return Value.CompareTo(((FlagsSimple)other).Value);
        }

        public int CompareTo(FlagsSimple other)
        {
            return Value.CompareTo(other.Value);
        }

        public override bool Equals(object other)
        {
            return (other is FlagsSimple value) && Value.Equals(value.Value);
        }

        public bool Equals(FlagsSimple other)
        {
            return Value.Equals(other.Value);
        }

        public override int GetHashCode()
        {
            return Value.GetHashCode();
        }

        public static bool operator==(FlagsSimple flags1, FlagsSimple flags2)
        {
            return flags1.Value == flags2.Value;
        }

        public static bool operator!=(FlagsSimple flags1, FlagsSimple flags2)
        {
            return flags1.Value != flags2.Value;
        }

        public static FlagsSimple operator&(FlagsSimple flags1, FlagsSimple flags2)
        {
            return new FlagsSimple((byte)(flags1.Value & flags2.Value));
        }

        public static FlagsSimple operator|(FlagsSimple flags1, FlagsSimple flags2)
        {
            return new FlagsSimple((byte)(flags1.Value | flags2.Value));
        }

        public static FlagsSimple operator^(FlagsSimple flags1, FlagsSimple flags2)
        {
            return new FlagsSimple((byte)(flags1.Value ^ flags2.Value));
        }

        public static FlagsSimple Default => new FlagsSimple();

        public static com.chronoxor.FBE.FieldModelValueType<FlagsSimple> CreateFieldModel(com.chronoxor.FBE.Buffer buffer, long offset) { return new test.FBE.FieldModelFlagsSimple(buffer, offset); }

        public const int _FLAG_VALUE_0_ = (int)0x0;
        public const int _FLAG_VALUE_1_ = (int)0x1;
        public const int _FLAG_VALUE_2_ = (int)0x2;
        public const int _FLAG_VALUE_3_ = (int)0x4;
        public const int _FLAG_VALUE_4_ = _FLAG_VALUE_3_;
        public const int _FLAG_VALUE_5_ = _FLAG_VALUE_1_ | _FLAG_VALUE_3_;

        public static FlagsSimple FLAG_VALUE_0 = new FlagsSimple(_FLAG_VALUE_0_);
        public static FlagsSimple FLAG_VALUE_1 = new FlagsSimple(_FLAG_VALUE_1_);
        public static FlagsSimple FLAG_VALUE_2 = new FlagsSimple(_FLAG_VALUE_2_);
        public static FlagsSimple FLAG_VALUE_3 = new FlagsSimple(_FLAG_VALUE_3_);
        public static FlagsSimple FLAG_VALUE_4 = new FlagsSimple(_FLAG_VALUE_4_);
        public static FlagsSimple FLAG_VALUE_5 = new FlagsSimple(_FLAG_VALUE_5_);

        public override string ToString()
        {
            var value = new FlagsSimple(Value);
            var sb = new StringBuilder();
            bool first = true;
            if (HasFlags(FLAG_VALUE_0))
            {
                sb.Append(first ? "" : "|").Append("FLAG_VALUE_0");
                first = false;
            }
            if (HasFlags(FLAG_VALUE_1))
            {
                sb.Append(first ? "" : "|").Append("FLAG_VALUE_1");
                first = false;
            }
            if (HasFlags(FLAG_VALUE_2))
            {
                sb.Append(first ? "" : "|").Append("FLAG_VALUE_2");
                first = false;
            }
            if (HasFlags(FLAG_VALUE_3))
            {
                sb.Append(first ? "" : "|").Append("FLAG_VALUE_3");
                first = false;
            }
            if (HasFlags(FLAG_VALUE_4))
            {
                sb.Append(first ? "" : "|").Append("FLAG_VALUE_4");
                first = false;
            }
            if (HasFlags(FLAG_VALUE_5))
            {
                sb.Append(first ? "" : "|").Append("FLAG_VALUE_5");
                first = false;
            }
            return sb.ToString();
        }
    }

} // namespace com.chronoxor.test

namespace com.chronoxor.test.FBE {

    using global::com.chronoxor.test;

    // Fast Binary Encoding FlagsSimple field model
    public class FieldModelFlagsSimple : com.chronoxor.FBE.FieldModelValueType<FlagsSimple>
    {
        public FieldModelFlagsSimple(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset) {}

        // Get the field size
        public override long FBESize => 4;

        // Clone the field model
        public override com.chronoxor.FBE.FieldModelValueType<FlagsSimple> Clone() { return new FieldModelFlagsSimple(_buffer, _offset); }

        // Get the value
        public override void Get(out FlagsSimple value) { Get(out value, FlagsSimple.Default); }
        public override void Get(out FlagsSimple value, FlagsSimple defaults)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
            {
                value = defaults;
                return;
            }

            value = new FlagsSimple((int)ReadInt32(FBEOffset));
        }

        // Set the value
        public override void Set(FlagsSimple value)
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return;

            Write(FBEOffset, value.Value);
        }
    }

} // namespace com.chronoxor.test.FBE

namespace com.chronoxor.test.FBE {

    using global::com.chronoxor.test;

    // Fast Binary Encoding FlagsSimple final model
    public class FinalModelFlagsSimple : com.chronoxor.FBE.FinalModelValueType<FlagsSimple>
    {
        public FinalModelFlagsSimple(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset) {}

        // Get the allocation size
        public override long FBEAllocationSize(FlagsSimple value) { return FBESize; }

        // Get the final size
        public override long FBESize => 4;

        // Clone the final model
        public override com.chronoxor.FBE.FinalModelValueType<FlagsSimple> Clone() { return new FinalModelFlagsSimple(_buffer, _offset); }

        // Check if the value is valid
        public override long Verify()
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return long.MaxValue;

            return FBESize;
        }

        // Get the value
        public override long Get(out FlagsSimple value)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
            {
                value = FlagsSimple.Default;
                return 0;
            }

            value = new FlagsSimple((int)ReadInt32(FBEOffset));
            return FBESize;
        }

        // Set the value
        public override long Set(FlagsSimple value)
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            Write(FBEOffset, value.Value);
            return FBESize;
        }
    }

} // namespace com.chronoxor.test.FBE

namespace com.chronoxor.test {

#if UTF8JSON
    public class FlagsTypedConverter : IJsonFormatter<FlagsTyped>
    {
        public void Serialize(ref JsonWriter writer, FlagsTyped value, IJsonFormatterResolver jsonFormatterResolver)
        {
            writer.WriteUInt64(value.Value);
        }

        public FlagsTyped Deserialize(ref JsonReader reader, IJsonFormatterResolver jsonFormatterResolver)
        {
            return new FlagsTyped(reader.ReadUInt64());
        }
    }

    [JsonFormatter(typeof(FlagsTypedConverter))]
#elif NEWTONSOFTJSON
    public class FlagsTypedConverter : JsonConverter
    {
        public override bool CanConvert(Type objectType)
        {
            return objectType == typeof(FlagsTyped);
        }

        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
        {
            writer.WriteValue(((FlagsTyped)value).Value);
        }

        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
        {
            if (reader.Value == null)
                return null;

            switch (reader.Value)
            {
                case long longValue:
                    return new FlagsTyped((ulong)longValue);
                case BigInteger bigValue:
                    return new FlagsTyped((ulong)bigValue);
                default:
                    return null;
            }
        }
    }

    [JsonConverter(typeof(FlagsTypedConverter))]
#else
    public class FlagsTypedConverter : JsonConverter<FlagsTyped>
    {
        public override void Write(Utf8JsonWriter writer, FlagsTyped value, JsonSerializerOptions options) => writer.WriteNumberValue(value.Value);
        public override FlagsTyped Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => new FlagsTyped(reader.GetUInt64());
    }

    [JsonConverter(typeof(FlagsTypedConverter))]
#endif
    public struct FlagsTyped : IComparable, IComparable<FlagsTyped>, IEquatable<FlagsTyped>
    {
        public ulong Value { get; internal set; }

        public FlagsTyped(ulong value) : this()
        {
            Value = value;
        }

        public FlagsTyped(FlagsTyped value) : this()
        {
            Value = value.Value;
        }

        public bool HasFlags(FlagsTyped flags)
        {
            return (((Value & flags.Value) != 0) && ((Value & flags.Value) == flags.Value));
        }

        public FlagsTyped SetFlags(FlagsTyped flags)
        {
            Value |= flags.Value;
            return this;
        }

        public FlagsTyped RemoveFlags(FlagsTyped flags)
        {
            Value &= (byte)~flags.Value;
            return this;
        }

        public int CompareTo(object other)
        {
            return Value.CompareTo(((FlagsTyped)other).Value);
        }

        public int CompareTo(FlagsTyped other)
        {
            return Value.CompareTo(other.Value);
        }

        public override bool Equals(object other)
        {
            return (other is FlagsTyped value) && Value.Equals(value.Value);
        }

        public bool Equals(FlagsTyped other)
        {
            return Value.Equals(other.Value);
        }

        public override int GetHashCode()
        {
            return Value.GetHashCode();
        }

        public static bool operator==(FlagsTyped flags1, FlagsTyped flags2)
        {
            return flags1.Value == flags2.Value;
        }

        public static bool operator!=(FlagsTyped flags1, FlagsTyped flags2)
        {
            return flags1.Value != flags2.Value;
        }

        public static FlagsTyped operator&(FlagsTyped flags1, FlagsTyped flags2)
        {
            return new FlagsTyped((byte)(flags1.Value & flags2.Value));
        }

        public static FlagsTyped operator|(FlagsTyped flags1, FlagsTyped flags2)
        {
            return new FlagsTyped((byte)(flags1.Value | flags2.Value));
        }

        public static FlagsTyped operator^(FlagsTyped flags1, FlagsTyped flags2)
        {
            return new FlagsTyped((byte)(flags1.Value ^ flags2.Value));
        }

        public static FlagsTyped Default => new FlagsTyped();

        public static com.chronoxor.FBE.FieldModelValueType<FlagsTyped> CreateFieldModel(com.chronoxor.FBE.Buffer buffer, long offset) { return new test.FBE.FieldModelFlagsTyped(buffer, offset); }

        public const ulong _FLAG_VALUE_0_ = (ulong)0x00UL;
        public const ulong _FLAG_VALUE_1_ = (ulong)0x01UL;
        public const ulong _FLAG_VALUE_2_ = (ulong)0x02UL;
        public const ulong _FLAG_VALUE_3_ = (ulong)0x04UL;
        public const ulong _FLAG_VALUE_4_ = (ulong)0x08UL;
        public const ulong _FLAG_VALUE_5_ = (ulong)0x10UL;
        public const ulong _FLAG_VALUE_6_ = (ulong)0x20UL;
        public const ulong _FLAG_VALUE_7_ = (ulong)0x40UL;
        public const ulong _FLAG_VALUE_8_ = _FLAG_VALUE_7_;
        public const ulong _FLAG_VALUE_9_ = _FLAG_VALUE_2_ | _FLAG_VALUE_4_ | _FLAG_VALUE_6_;

        public static FlagsTyped FLAG_VALUE_0 = new FlagsTyped(_FLAG_VALUE_0_);
        public static FlagsTyped FLAG_VALUE_1 = new FlagsTyped(_FLAG_VALUE_1_);
        public static FlagsTyped FLAG_VALUE_2 = new FlagsTyped(_FLAG_VALUE_2_);
        public static FlagsTyped FLAG_VALUE_3 = new FlagsTyped(_FLAG_VALUE_3_);
        public static FlagsTyped FLAG_VALUE_4 = new FlagsTyped(_FLAG_VALUE_4_);
        public static FlagsTyped FLAG_VALUE_5 = new FlagsTyped(_FLAG_VALUE_5_);
        public static FlagsTyped FLAG_VALUE_6 = new FlagsTyped(_FLAG_VALUE_6_);
        public static FlagsTyped FLAG_VALUE_7 = new FlagsTyped(_FLAG_VALUE_7_);
        public static FlagsTyped FLAG_VALUE_8 = new FlagsTyped(_FLAG_VALUE_8_);
        public static FlagsTyped FLAG_VALUE_9 = new FlagsTyped(_FLAG_VALUE_9_);

        public override string ToString()
        {
            var value = new FlagsTyped(Value);
            var sb = new StringBuilder();
            bool first = true;
            if (HasFlags(FLAG_VALUE_0))
            {
                sb.Append(first ? "" : "|").Append("FLAG_VALUE_0");
                first = false;
            }
            if (HasFlags(FLAG_VALUE_1))
            {
                sb.Append(first ? "" : "|").Append("FLAG_VALUE_1");
                first = false;
            }
            if (HasFlags(FLAG_VALUE_2))
            {
                sb.Append(first ? "" : "|").Append("FLAG_VALUE_2");
                first = false;
            }
            if (HasFlags(FLAG_VALUE_3))
            {
                sb.Append(first ? "" : "|").Append("FLAG_VALUE_3");
                first = false;
            }
            if (HasFlags(FLAG_VALUE_4))
            {
                sb.Append(first ? "" : "|").Append("FLAG_VALUE_4");
                first = false;
            }
            if (HasFlags(FLAG_VALUE_5))
            {
                sb.Append(first ? "" : "|").Append("FLAG_VALUE_5");
                first = false;
            }
            if (HasFlags(FLAG_VALUE_6))
            {
                sb.Append(first ? "" : "|").Append("FLAG_VALUE_6");
                first = false;
            }
            if (HasFlags(FLAG_VALUE_7))
            {
                sb.Append(first ? "" : "|").Append("FLAG_VALUE_7");
                first = false;
            }
            if (HasFlags(FLAG_VALUE_8))
            {
                sb.Append(first ? "" : "|").Append("FLAG_VALUE_8");
                first = false;
            }
            if (HasFlags(FLAG_VALUE_9))
            {
                sb.Append(first ? "" : "|").Append("FLAG_VALUE_9");
                first = false;
            }
            return sb.ToString();
        }
    }

} // namespace com.chronoxor.test

namespace com.chronoxor.test.FBE {

    using global::com.chronoxor.test;

    // Fast Binary Encoding FlagsTyped field model
    public class FieldModelFlagsTyped : com.chronoxor.FBE.FieldModelValueType<FlagsTyped>
    {
        public FieldModelFlagsTyped(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset) {}

        // Get the field size
        public override long FBESize => 8;

        // Clone the field model
        public override com.chronoxor.FBE.FieldModelValueType<FlagsTyped> Clone() { return new FieldModelFlagsTyped(_buffer, _offset); }

        // Get the value
        public override void Get(out FlagsTyped value) { Get(out value, FlagsTyped.Default); }
        public override void Get(out FlagsTyped value, FlagsTyped defaults)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
            {
                value = defaults;
                return;
            }

            value = new FlagsTyped((ulong)ReadUInt64(FBEOffset));
        }

        // Set the value
        public override void Set(FlagsTyped value)
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return;

            Write(FBEOffset, value.Value);
        }
    }

} // namespace com.chronoxor.test.FBE

namespace com.chronoxor.test.FBE {

    using global::com.chronoxor.test;

    // Fast Binary Encoding FlagsTyped final model
    public class FinalModelFlagsTyped : com.chronoxor.FBE.FinalModelValueType<FlagsTyped>
    {
        public FinalModelFlagsTyped(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset) {}

        // Get the allocation size
        public override long FBEAllocationSize(FlagsTyped value) { return FBESize; }

        // Get the final size
        public override long FBESize => 8;

        // Clone the final model
        public override com.chronoxor.FBE.FinalModelValueType<FlagsTyped> Clone() { return new FinalModelFlagsTyped(_buffer, _offset); }

        // Check if the value is valid
        public override long Verify()
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return long.MaxValue;

            return FBESize;
        }

        // Get the value
        public override long Get(out FlagsTyped value)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
            {
                value = FlagsTyped.Default;
                return 0;
            }

            value = new FlagsTyped((ulong)ReadUInt64(FBEOffset));
            return FBESize;
        }

        // Set the value
        public override long Set(FlagsTyped value)
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            Write(FBEOffset, value.Value);
            return FBESize;
        }
    }

} // namespace com.chronoxor.test.FBE

namespace com.chronoxor.test {

#if UTF8JSON
    public class FlagsEmptyConverter : IJsonFormatter<FlagsEmpty>
    {
        public void Serialize(ref JsonWriter writer, FlagsEmpty value, IJsonFormatterResolver jsonFormatterResolver)
        {
            writer.WriteInt32(value.Value);
        }

        public FlagsEmpty Deserialize(ref JsonReader reader, IJsonFormatterResolver jsonFormatterResolver)
        {
            return new FlagsEmpty(reader.ReadInt32());
        }
    }

    [JsonFormatter(typeof(FlagsEmptyConverter))]
#elif NEWTONSOFTJSON
    public class FlagsEmptyConverter : JsonConverter
    {
        public override bool CanConvert(Type objectType)
        {
            return objectType == typeof(FlagsEmpty);
        }

        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
        {
            writer.WriteValue(((FlagsEmpty)value).Value);
        }

        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
        {
            if (reader.Value == null)
                return null;

            switch (reader.Value)
            {
                case long longValue:
                    return new FlagsEmpty((int)longValue);
                case BigInteger bigValue:
                    return new FlagsEmpty((int)bigValue);
                default:
                    return null;
            }
        }
    }

    [JsonConverter(typeof(FlagsEmptyConverter))]
#else
    public class FlagsEmptyConverter : JsonConverter<FlagsEmpty>
    {
        public override void Write(Utf8JsonWriter writer, FlagsEmpty value, JsonSerializerOptions options) => writer.WriteNumberValue(value.Value);
        public override FlagsEmpty Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => new FlagsEmpty(reader.GetInt32());
    }

    [JsonConverter(typeof(FlagsEmptyConverter))]
#endif
    public struct FlagsEmpty : IComparable, IComparable<FlagsEmpty>, IEquatable<FlagsEmpty>
    {
        public int Value { get; internal set; }

        public FlagsEmpty(int value) : this()
        {
            Value = value;
        }

        public FlagsEmpty(FlagsEmpty value) : this()
        {
            Value = value.Value;
        }

        public bool HasFlags(FlagsEmpty flags)
        {
            return (((Value & flags.Value) != 0) && ((Value & flags.Value) == flags.Value));
        }

        public FlagsEmpty SetFlags(FlagsEmpty flags)
        {
            Value |= flags.Value;
            return this;
        }

        public FlagsEmpty RemoveFlags(FlagsEmpty flags)
        {
            Value &= (byte)~flags.Value;
            return this;
        }

        public int CompareTo(object other)
        {
            return Value.CompareTo(((FlagsEmpty)other).Value);
        }

        public int CompareTo(FlagsEmpty other)
        {
            return Value.CompareTo(other.Value);
        }

        public override bool Equals(object other)
        {
            return (other is FlagsEmpty value) && Value.Equals(value.Value);
        }

        public bool Equals(FlagsEmpty other)
        {
            return Value.Equals(other.Value);
        }

        public override int GetHashCode()
        {
            return Value.GetHashCode();
        }

        public static bool operator==(FlagsEmpty flags1, FlagsEmpty flags2)
        {
            return flags1.Value == flags2.Value;
        }

        public static bool operator!=(FlagsEmpty flags1, FlagsEmpty flags2)
        {
            return flags1.Value != flags2.Value;
        }

        public static FlagsEmpty operator&(FlagsEmpty flags1, FlagsEmpty flags2)
        {
            return new FlagsEmpty((byte)(flags1.Value & flags2.Value));
        }

        public static FlagsEmpty operator|(FlagsEmpty flags1, FlagsEmpty flags2)
        {
            return new FlagsEmpty((byte)(flags1.Value | flags2.Value));
        }

        public static FlagsEmpty operator^(FlagsEmpty flags1, FlagsEmpty flags2)
        {
            return new FlagsEmpty((byte)(flags1.Value ^ flags2.Value));
        }

        public static FlagsEmpty Default => new FlagsEmpty();

        public static com.chronoxor.FBE.FieldModelValueType<FlagsEmpty> CreateFieldModel(com.chronoxor.FBE.Buffer buffer, long offset) { return new test.FBE.FieldModelFlagsEmpty(buffer, offset); }



        public override string ToString()
        {
            var value = new FlagsEmpty(Value);
            var sb = new StringBuilder();
            return sb.ToString();
        }
    }

} // namespace com.chronoxor.test

namespace com.chronoxor.test.FBE {

    using global::com.chronoxor.test;

    // Fast Binary Encoding FlagsEmpty field model
    public class FieldModelFlagsEmpty : com.chronoxor.FBE.FieldModelValueType<FlagsEmpty>
    {
        public FieldModelFlagsEmpty(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset) {}

        // Get the field size
        public override long FBESize => 4;

        // Clone the field model
        public override com.chronoxor.FBE.FieldModelValueType<FlagsEmpty> Clone() { return new FieldModelFlagsEmpty(_buffer, _offset); }

        // Get the value
        public override void Get(out FlagsEmpty value) { Get(out value, FlagsEmpty.Default); }
        public override void Get(out FlagsEmpty value, FlagsEmpty defaults)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
            {
                value = defaults;
                return;
            }

            value = new FlagsEmpty((int)ReadInt32(FBEOffset));
        }

        // Set the value
        public override void Set(FlagsEmpty value)
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return;

            Write(FBEOffset, value.Value);
        }
    }

} // namespace com.chronoxor.test.FBE

namespace com.chronoxor.test.FBE {

    using global::com.chronoxor.test;

    // Fast Binary Encoding FlagsEmpty final model
    public class FinalModelFlagsEmpty : com.chronoxor.FBE.FinalModelValueType<FlagsEmpty>
    {
        public FinalModelFlagsEmpty(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset) {}

        // Get the allocation size
        public override long FBEAllocationSize(FlagsEmpty value) { return FBESize; }

        // Get the final size
        public override long FBESize => 4;

        // Clone the final model
        public override com.chronoxor.FBE.FinalModelValueType<FlagsEmpty> Clone() { return new FinalModelFlagsEmpty(_buffer, _offset); }

        // Check if the value is valid
        public override long Verify()
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return long.MaxValue;

            return FBESize;
        }

        // Get the value
        public override long Get(out FlagsEmpty value)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
            {
                value = FlagsEmpty.Default;
                return 0;
            }

            value = new FlagsEmpty((int)ReadInt32(FBEOffset));
            return FBESize;
        }

        // Set the value
        public override long Set(FlagsEmpty value)
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            Write(FBEOffset, value.Value);
            return FBESize;
        }
    }

} // namespace com.chronoxor.test.FBE

namespace com.chronoxor.test {

    public struct StructSimple : IComparable, IComparable<StructSimple>, IEquatable<StructSimple>
    {
        public int id;
        public bool f1;
        public bool f2;
        public byte f3;
        public byte f4;
        public char f5;
        public char f6;
        public char f7;
        public char f8;
        public sbyte f9;
        public sbyte f10;
        public byte f11;
        public byte f12;
        public short f13;
        public short f14;
        public ushort f15;
        public ushort f16;
        public int f17;
        public int f18;
        public uint f19;
        public uint f20;
        public long f21;
        public long f22;
        public ulong f23;
        public ulong f24;
        public float f25;
        public float f26;
        public double f27;
        public double f28;
        public decimal f29;
        public decimal f30;
        public string f31;
        public string f32;
        public DateTime f33;
        public DateTime f34;
        public DateTime f35;
        public Guid f36;
        public Guid f37;
        public Guid f38;
        public proto.OrderSide f39;
        public proto.OrderType f40;
        public proto.Order f41;
        public proto.Balance f42;
        public proto.State f43;
        public proto.Account f44;

        public const long FBETypeConst = 110;
        #if UTF8JSON
        [IgnoreDataMember]
        #else
        [JsonIgnore]
        #endif
        public long FBEType => FBETypeConst;

        public static StructSimple Default => new StructSimple
        {
            id = (int)0
            , f1 = false
            , f2 = true
            , f3 = (byte)0U
            , f4 = Byte.MaxValue
            , f5 = '\0'
            , f6 = (char)'!'
            , f7 = '\0'
            , f8 = (char)0x0444
            , f9 = (sbyte)0
            , f10 = SByte.MaxValue
            , f11 = Byte.MinValue
            , f12 = Byte.MaxValue
            , f13 = (short)0
            , f14 = Int16.MaxValue
            , f15 = UInt16.MinValue
            , f16 = UInt16.MaxValue
            , f17 = (int)0
            , f18 = Int32.MaxValue
            , f19 = UInt32.MinValue
            , f20 = UInt32.MaxValue
            , f21 = (long)0L
            , f22 = Int64.MaxValue
            , f23 = UInt64.MinValue
            , f24 = UInt64.MaxValue
            , f25 = 0.0F
            , f26 = (float)123.456F
            , f27 = 0.0D
            , f28 = (double)-123.456e+123D
            , f29 = 0.0M
            , f30 = (decimal)123456.123456M
            , f31 = ""
            , f32 = "Initial string!"
            , f33 = new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc)
            , f34 = new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc)
            , f35 = DateTime.UtcNow
            , f36 = com.chronoxor.FBE.UuidGenerator.Nil()
            , f37 = com.chronoxor.FBE.UuidGenerator.Sequential()
            , f38 = Guid.Parse("123e4567-e89b-12d3-a456-426655440000")
            , f39 = global::com.chronoxor.proto.OrderSide.Default
            , f40 = global::com.chronoxor.proto.OrderType.Default
            , f41 = global::com.chronoxor.proto.Order.Default
            , f42 = global::com.chronoxor.proto.Balance.Default
            , f43 = global::com.chronoxor.proto.State.Default
            , f44 = global::com.chronoxor.proto.Account.Default
        };

        public StructSimple(int id, bool f1, bool f2, byte f3, byte f4, char f5, char f6, char f7, char f8, sbyte f9, sbyte f10, byte f11, byte f12, short f13, short f14, ushort f15, ushort f16, int f17, int f18, uint f19, uint f20, long f21, long f22, ulong f23, ulong f24, float f25, float f26, double f27, double f28, decimal f29, decimal f30, string f31, string f32, DateTime f33, DateTime f34, DateTime f35, Guid f36, Guid f37, Guid f38, proto.OrderSide f39, proto.OrderType f40, proto.Order f41, proto.Balance f42, proto.State f43, proto.Account f44)
        {
            this.id = id;
            this.f1 = f1;
            this.f2 = f2;
            this.f3 = f3;
            this.f4 = f4;
            this.f5 = f5;
            this.f6 = f6;
            this.f7 = f7;
            this.f8 = f8;
            this.f9 = f9;
            this.f10 = f10;
            this.f11 = f11;
            this.f12 = f12;
            this.f13 = f13;
            this.f14 = f14;
            this.f15 = f15;
            this.f16 = f16;
            this.f17 = f17;
            this.f18 = f18;
            this.f19 = f19;
            this.f20 = f20;
            this.f21 = f21;
            this.f22 = f22;
            this.f23 = f23;
            this.f24 = f24;
            this.f25 = f25;
            this.f26 = f26;
            this.f27 = f27;
            this.f28 = f28;
            this.f29 = f29;
            this.f30 = f30;
            this.f31 = f31;
            this.f32 = f32;
            this.f33 = f33;
            this.f34 = f34;
            this.f35 = f35;
            this.f36 = f36;
            this.f37 = f37;
            this.f38 = f38;
            this.f39 = f39;
            this.f40 = f40;
            this.f41 = f41;
            this.f42 = f42;
            this.f43 = f43;
            this.f44 = f44;
        }

        public StructSimple Clone()
        {
            // Serialize the struct to the FBE stream
            var writer = new com.chronoxor.test.FBE.StructSimpleModel();
            writer.Serialize(this);

            // Deserialize the struct from the FBE stream
            var reader = new com.chronoxor.test.FBE.StructSimpleModel();
            reader.Attach(writer.Buffer);
            reader.Deserialize(out var result);
            return result;
        }

        public int CompareTo(object other)
        {
            int result = 0;
            result = id.CompareTo(((StructSimple)other).id);
            if (result != 0)
                return result;
            return result;
        }

        public int CompareTo(StructSimple other)
        {
            int result = 0;
            result = id.CompareTo(other.id);
            if (result != 0)
                return result;
            return result;
        }

        public override bool Equals(object other)
        {
            if (!(other is StructSimple))
                return false;
            if (!id.Equals(((StructSimple)other).id))
                return false;
            return true;
        }

        public bool Equals(StructSimple other)
        {
            if (!id.Equals(other.id))
                return false;
            return true;
        }

        public override int GetHashCode()
        {
            int hash = 17;
            hash = hash * 31 + id.GetHashCode();
            return hash;
        }

        public static bool operator==(StructSimple lhs, StructSimple rhs) => lhs.Equals(rhs);
        public static bool operator!=(StructSimple lhs, StructSimple rhs) => !(lhs == rhs);

        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("StructSimple(");
            sb.Append("id="); sb.Append(id);
            sb.Append(",f1="); sb.Append(f1 ? "true" : "false");
            sb.Append(",f2="); sb.Append(f2 ? "true" : "false");
            sb.Append(",f3="); sb.Append(f3);
            sb.Append(",f4="); sb.Append(f4);
            sb.Append(",f5="); sb.Append("'").Append(f5).Append("'");
            sb.Append(",f6="); sb.Append("'").Append(f6).Append("'");
            sb.Append(",f7="); sb.Append("'").Append(f7).Append("'");
            sb.Append(",f8="); sb.Append("'").Append(f8).Append("'");
            sb.Append(",f9="); sb.Append(f9);
            sb.Append(",f10="); sb.Append(f10);
            sb.Append(",f11="); sb.Append(f11);
            sb.Append(",f12="); sb.Append(f12);
            sb.Append(",f13="); sb.Append(f13);
            sb.Append(",f14="); sb.Append(f14);
            sb.Append(",f15="); sb.Append(f15);
            sb.Append(",f16="); sb.Append(f16);
            sb.Append(",f17="); sb.Append(f17);
            sb.Append(",f18="); sb.Append(f18);
            sb.Append(",f19="); sb.Append(f19);
            sb.Append(",f20="); sb.Append(f20);
            sb.Append(",f21="); sb.Append(f21);
            sb.Append(",f22="); sb.Append(f22);
            sb.Append(",f23="); sb.Append(f23);
            sb.Append(",f24="); sb.Append(f24);
            sb.Append(",f25="); sb.Append(f25.ToString(CultureInfo.InvariantCulture));
            sb.Append(",f26="); sb.Append(f26.ToString(CultureInfo.InvariantCulture));
            sb.Append(",f27="); sb.Append(f27.ToString(CultureInfo.InvariantCulture));
            sb.Append(",f28="); sb.Append(f28.ToString(CultureInfo.InvariantCulture));
            sb.Append(",f29="); sb.Append(f29.ToString(CultureInfo.InvariantCulture));
            sb.Append(",f30="); sb.Append(f30.ToString(CultureInfo.InvariantCulture));
            sb.Append(",f31="); if (f31 != null) sb.Append("\"").Append(f31).Append("\""); else sb.Append("null");
            sb.Append(",f32="); if (f32 != null) sb.Append("\"").Append(f32).Append("\""); else sb.Append("null");
            sb.Append(",f33="); sb.Append((ulong)((f33.Ticks - 621355968000000000) * 100));
            sb.Append(",f34="); sb.Append((ulong)((f34.Ticks - 621355968000000000) * 100));
            sb.Append(",f35="); sb.Append((ulong)((f35.Ticks - 621355968000000000) * 100));
            sb.Append(",f36="); sb.Append("\"").Append(f36).Append("\"");
            sb.Append(",f37="); sb.Append("\"").Append(f37).Append("\"");
            sb.Append(",f38="); sb.Append("\"").Append(f38).Append("\"");
            sb.Append(",f39="); sb.Append(f39);
            sb.Append(",f40="); sb.Append(f40);
            sb.Append(",f41="); sb.Append(f41);
            sb.Append(",f42="); sb.Append(f42);
            sb.Append(",f43="); sb.Append(f43);
            sb.Append(",f44="); sb.Append(f44);
            sb.Append(")");
            return sb.ToString();
        }

        public string ToJson()
        {
            var json = com.chronoxor.FBE.Json.ToJson(this);
            return json;
        }

        public static StructSimple FromJson(string json)
        {
            var result = com.chronoxor.FBE.Json.FromJson<StructSimple>(json);
            return result;
        }

        public static com.chronoxor.FBE.FieldModelValueType<StructSimple> CreateFieldModel(com.chronoxor.FBE.Buffer buffer, long offset) { return new test.FBE.FieldModelStructSimple(buffer, offset); }
    }

} // namespace com.chronoxor.test

namespace com.chronoxor.test.FBE {

    using global::com.chronoxor.test;

    // Fast Binary Encoding StructSimple field model
    public class FieldModelStructSimple : com.chronoxor.FBE.FieldModelValueType<StructSimple>
    {
        public readonly com.chronoxor.FBE.FieldModelValueType<int> id;
        public readonly com.chronoxor.FBE.FieldModelValueType<bool> f1;
        public readonly com.chronoxor.FBE.FieldModelValueType<bool> f2;
        public readonly com.chronoxor.FBE.FieldModelValueType<byte> f3;
        public readonly com.chronoxor.FBE.FieldModelValueType<byte> f4;
        public readonly com.chronoxor.FBE.FieldModelValueType<char> f5;
        public readonly com.chronoxor.FBE.FieldModelValueType<char> f6;
        public readonly com.chronoxor.FBE.FieldModelValueType<char> f7;
        public readonly com.chronoxor.FBE.FieldModelValueType<char> f8;
        public readonly com.chronoxor.FBE.FieldModelValueType<sbyte> f9;
        public readonly com.chronoxor.FBE.FieldModelValueType<sbyte> f10;
        public readonly com.chronoxor.FBE.FieldModelValueType<byte> f11;
        public readonly com.chronoxor.FBE.FieldModelValueType<byte> f12;
        public readonly com.chronoxor.FBE.FieldModelValueType<short> f13;
        public readonly com.chronoxor.FBE.FieldModelValueType<short> f14;
        public readonly com.chronoxor.FBE.FieldModelValueType<ushort> f15;
        public readonly com.chronoxor.FBE.FieldModelValueType<ushort> f16;
        public readonly com.chronoxor.FBE.FieldModelValueType<int> f17;
        public readonly com.chronoxor.FBE.FieldModelValueType<int> f18;
        public readonly com.chronoxor.FBE.FieldModelValueType<uint> f19;
        public readonly com.chronoxor.FBE.FieldModelValueType<uint> f20;
        public readonly com.chronoxor.FBE.FieldModelValueType<long> f21;
        public readonly com.chronoxor.FBE.FieldModelValueType<long> f22;
        public readonly com.chronoxor.FBE.FieldModelValueType<ulong> f23;
        public readonly com.chronoxor.FBE.FieldModelValueType<ulong> f24;
        public readonly com.chronoxor.FBE.FieldModelValueType<float> f25;
        public readonly com.chronoxor.FBE.FieldModelValueType<float> f26;
        public readonly com.chronoxor.FBE.FieldModelValueType<double> f27;
        public readonly com.chronoxor.FBE.FieldModelValueType<double> f28;
        public readonly com.chronoxor.FBE.FieldModelValueType<decimal> f29;
        public readonly com.chronoxor.FBE.FieldModelValueType<decimal> f30;
        public readonly com.chronoxor.FBE.FieldModelReferenceType<string> f31;
        public readonly com.chronoxor.FBE.FieldModelReferenceType<string> f32;
        public readonly com.chronoxor.FBE.FieldModelValueType<DateTime> f33;
        public readonly com.chronoxor.FBE.FieldModelValueType<DateTime> f34;
        public readonly com.chronoxor.FBE.FieldModelValueType<DateTime> f35;
        public readonly com.chronoxor.FBE.FieldModelValueType<Guid> f36;
        public readonly com.chronoxor.FBE.FieldModelValueType<Guid> f37;
        public readonly com.chronoxor.FBE.FieldModelValueType<Guid> f38;
        public readonly com.chronoxor.proto.FBE.FieldModelOrderSide f39;
        public readonly com.chronoxor.proto.FBE.FieldModelOrderType f40;
        public readonly com.chronoxor.proto.FBE.FieldModelOrder f41;
        public readonly com.chronoxor.proto.FBE.FieldModelBalance f42;
        public readonly com.chronoxor.proto.FBE.FieldModelState f43;
        public readonly com.chronoxor.proto.FBE.FieldModelAccount f44;

        public FieldModelStructSimple(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset)
        {
            id = com.chronoxor.FBE.FieldModelValueType<int>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.INT32, buffer, 4 + 4);
            f1 = com.chronoxor.FBE.FieldModelValueType<bool>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.BOOL, buffer, id.FBEOffset + id.FBESize);
            f2 = com.chronoxor.FBE.FieldModelValueType<bool>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.BOOL, buffer, f1.FBEOffset + f1.FBESize);
            f3 = com.chronoxor.FBE.FieldModelValueType<byte>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.BYTE, buffer, f2.FBEOffset + f2.FBESize);
            f4 = com.chronoxor.FBE.FieldModelValueType<byte>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.BYTE, buffer, f3.FBEOffset + f3.FBESize);
            f5 = com.chronoxor.FBE.FieldModelValueType<char>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.CHAR, buffer, f4.FBEOffset + f4.FBESize);
            f6 = com.chronoxor.FBE.FieldModelValueType<char>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.CHAR, buffer, f5.FBEOffset + f5.FBESize);
            f7 = com.chronoxor.FBE.FieldModelValueType<char>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.WCHAR, buffer, f6.FBEOffset + f6.FBESize);
            f8 = com.chronoxor.FBE.FieldModelValueType<char>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.WCHAR, buffer, f7.FBEOffset + f7.FBESize);
            f9 = com.chronoxor.FBE.FieldModelValueType<sbyte>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.INT8, buffer, f8.FBEOffset + f8.FBESize);
            f10 = com.chronoxor.FBE.FieldModelValueType<sbyte>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.INT8, buffer, f9.FBEOffset + f9.FBESize);
            f11 = com.chronoxor.FBE.FieldModelValueType<byte>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.UINT8, buffer, f10.FBEOffset + f10.FBESize);
            f12 = com.chronoxor.FBE.FieldModelValueType<byte>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.UINT8, buffer, f11.FBEOffset + f11.FBESize);
            f13 = com.chronoxor.FBE.FieldModelValueType<short>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.INT16, buffer, f12.FBEOffset + f12.FBESize);
            f14 = com.chronoxor.FBE.FieldModelValueType<short>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.INT16, buffer, f13.FBEOffset + f13.FBESize);
            f15 = com.chronoxor.FBE.FieldModelValueType<ushort>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.UINT16, buffer, f14.FBEOffset + f14.FBESize);
            f16 = com.chronoxor.FBE.FieldModelValueType<ushort>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.UINT16, buffer, f15.FBEOffset + f15.FBESize);
            f17 = com.chronoxor.FBE.FieldModelValueType<int>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.INT32, buffer, f16.FBEOffset + f16.FBESize);
            f18 = com.chronoxor.FBE.FieldModelValueType<int>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.INT32, buffer, f17.FBEOffset + f17.FBESize);
            f19 = com.chronoxor.FBE.FieldModelValueType<uint>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.UINT32, buffer, f18.FBEOffset + f18.FBESize);
            f20 = com.chronoxor.FBE.FieldModelValueType<uint>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.UINT32, buffer, f19.FBEOffset + f19.FBESize);
            f21 = com.chronoxor.FBE.FieldModelValueType<long>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.INT64, buffer, f20.FBEOffset + f20.FBESize);
            f22 = com.chronoxor.FBE.FieldModelValueType<long>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.INT64, buffer, f21.FBEOffset + f21.FBESize);
            f23 = com.chronoxor.FBE.FieldModelValueType<ulong>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.UINT64, buffer, f22.FBEOffset + f22.FBESize);
            f24 = com.chronoxor.FBE.FieldModelValueType<ulong>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.UINT64, buffer, f23.FBEOffset + f23.FBESize);
            f25 = com.chronoxor.FBE.FieldModelValueType<float>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.FLOAT, buffer, f24.FBEOffset + f24.FBESize);
            f26 = com.chronoxor.FBE.FieldModelValueType<float>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.FLOAT, buffer, f25.FBEOffset + f25.FBESize);
            f27 = com.chronoxor.FBE.FieldModelValueType<double>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.DOUBLE, buffer, f26.FBEOffset + f26.FBESize);
            f28 = com.chronoxor.FBE.FieldModelValueType<double>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.DOUBLE, buffer, f27.FBEOffset + f27.FBESize);
            f29 = com.chronoxor.FBE.FieldModelValueType<decimal>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.DECIMAL, buffer, f28.FBEOffset + f28.FBESize);
            f30 = com.chronoxor.FBE.FieldModelValueType<decimal>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.DECIMAL, buffer, f29.FBEOffset + f29.FBESize);
            f31 = com.chronoxor.FBE.FieldModelReferenceType<string>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.STRING, buffer, f30.FBEOffset + f30.FBESize);
            f32 = com.chronoxor.FBE.FieldModelReferenceType<string>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.STRING, buffer, f31.FBEOffset + f31.FBESize);
            f33 = com.chronoxor.FBE.FieldModelValueType<DateTime>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.TIMESTAMP, buffer, f32.FBEOffset + f32.FBESize);
            f34 = com.chronoxor.FBE.FieldModelValueType<DateTime>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.TIMESTAMP, buffer, f33.FBEOffset + f33.FBESize);
            f35 = com.chronoxor.FBE.FieldModelValueType<DateTime>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.TIMESTAMP, buffer, f34.FBEOffset + f34.FBESize);
            f36 = com.chronoxor.FBE.FieldModelValueType<Guid>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.UUID, buffer, f35.FBEOffset + f35.FBESize);
            f37 = com.chronoxor.FBE.FieldModelValueType<Guid>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.UUID, buffer, f36.FBEOffset + f36.FBESize);
            f38 = com.chronoxor.FBE.FieldModelValueType<Guid>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.UUID, buffer, f37.FBEOffset + f37.FBESize);
            f39 = new com.chronoxor.proto.FBE.FieldModelOrderSide(buffer, f38.FBEOffset + f38.FBESize);
            f40 = new com.chronoxor.proto.FBE.FieldModelOrderType(buffer, f39.FBEOffset + f39.FBESize);
            f41 = new com.chronoxor.proto.FBE.FieldModelOrder(buffer, f40.FBEOffset + f40.FBESize);
            f42 = new com.chronoxor.proto.FBE.FieldModelBalance(buffer, f41.FBEOffset + f41.FBESize);
            f43 = new com.chronoxor.proto.FBE.FieldModelState(buffer, f42.FBEOffset + f42.FBESize);
            f44 = new com.chronoxor.proto.FBE.FieldModelAccount(buffer, f43.FBEOffset + f43.FBESize);
        }

        // Get the field size
        public override long FBESize => 4;
        // Get the field body size
        public long FBEBody
        {
            get
            {
                long fbeResult = 4 + 4
                    + id.FBESize
                    + f1.FBESize
                    + f2.FBESize
                    + f3.FBESize
                    + f4.FBESize
                    + f5.FBESize
                    + f6.FBESize
                    + f7.FBESize
                    + f8.FBESize
                    + f9.FBESize
                    + f10.FBESize
                    + f11.FBESize
                    + f12.FBESize
                    + f13.FBESize
                    + f14.FBESize
                    + f15.FBESize
                    + f16.FBESize
                    + f17.FBESize
                    + f18.FBESize
                    + f19.FBESize
                    + f20.FBESize
                    + f21.FBESize
                    + f22.FBESize
                    + f23.FBESize
                    + f24.FBESize
                    + f25.FBESize
                    + f26.FBESize
                    + f27.FBESize
                    + f28.FBESize
                    + f29.FBESize
                    + f30.FBESize
                    + f31.FBESize
                    + f32.FBESize
                    + f33.FBESize
                    + f34.FBESize
                    + f35.FBESize
                    + f36.FBESize
                    + f37.FBESize
                    + f38.FBESize
                    + f39.FBESize
                    + f40.FBESize
                    + f41.FBESize
                    + f42.FBESize
                    + f43.FBESize
                    + f44.FBESize
                    ;
                return fbeResult;
            }
        }
        // Get the field extra size
        public override long FBEExtra
        {
            get
            {
                if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                    return 0;

                uint fbeStructOffset = ReadUInt32(FBEOffset);
                if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4) > _buffer.Size))
                    return 0;

                _buffer.Shift(fbeStructOffset);

                long fbeResult = FBEBody
                    + id.FBEExtra
                    + f1.FBEExtra
                    + f2.FBEExtra
                    + f3.FBEExtra
                    + f4.FBEExtra
                    + f5.FBEExtra
                    + f6.FBEExtra
                    + f7.FBEExtra
                    + f8.FBEExtra
                    + f9.FBEExtra
                    + f10.FBEExtra
                    + f11.FBEExtra
                    + f12.FBEExtra
                    + f13.FBEExtra
                    + f14.FBEExtra
                    + f15.FBEExtra
                    + f16.FBEExtra
                    + f17.FBEExtra
                    + f18.FBEExtra
                    + f19.FBEExtra
                    + f20.FBEExtra
                    + f21.FBEExtra
                    + f22.FBEExtra
                    + f23.FBEExtra
                    + f24.FBEExtra
                    + f25.FBEExtra
                    + f26.FBEExtra
                    + f27.FBEExtra
                    + f28.FBEExtra
                    + f29.FBEExtra
                    + f30.FBEExtra
                    + f31.FBEExtra
                    + f32.FBEExtra
                    + f33.FBEExtra
                    + f34.FBEExtra
                    + f35.FBEExtra
                    + f36.FBEExtra
                    + f37.FBEExtra
                    + f38.FBEExtra
                    + f39.FBEExtra
                    + f40.FBEExtra
                    + f41.FBEExtra
                    + f42.FBEExtra
                    + f43.FBEExtra
                    + f44.FBEExtra
                    ;

                _buffer.Unshift(fbeStructOffset);

                return fbeResult;
            }
        }
        // Get the field type
        public const long FBETypeConst = 110;
        public long FBEType => FBETypeConst;

        // Clone the field model
        public override com.chronoxor.FBE.FieldModelValueType<StructSimple> Clone() { return new FieldModelStructSimple(_buffer, _offset); }

        // Check if the struct value is valid
        public override bool Verify() { return Verify(true); }
        public bool Verify(bool fbeVerifyType)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return true;

            uint fbeStructOffset = ReadUInt32(FBEOffset);
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
                return false;

            uint fbeStructSize = ReadUInt32(fbeStructOffset);
            if (fbeStructSize < (4 + 4))
                return false;

            uint fbeStructType = ReadUInt32(fbeStructOffset + 4);
            if (fbeVerifyType && (fbeStructType != FBEType))
                return false;

            _buffer.Shift(fbeStructOffset);
            bool fbeResult = VerifyFields(fbeStructSize);
            _buffer.Unshift(fbeStructOffset);
            return fbeResult;
        }

        // Check if the struct fields are valid
        public bool VerifyFields(long fbeStructSize)
        {
            long fbeCurrentSize = 4 + 4;

            if ((fbeCurrentSize + id.FBESize) > fbeStructSize)
                return true;
            if (!id.Verify())
                return false;
            fbeCurrentSize += id.FBESize;

            if ((fbeCurrentSize + f1.FBESize) > fbeStructSize)
                return true;
            if (!f1.Verify())
                return false;
            fbeCurrentSize += f1.FBESize;

            if ((fbeCurrentSize + f2.FBESize) > fbeStructSize)
                return true;
            if (!f2.Verify())
                return false;
            fbeCurrentSize += f2.FBESize;

            if ((fbeCurrentSize + f3.FBESize) > fbeStructSize)
                return true;
            if (!f3.Verify())
                return false;
            fbeCurrentSize += f3.FBESize;

            if ((fbeCurrentSize + f4.FBESize) > fbeStructSize)
                return true;
            if (!f4.Verify())
                return false;
            fbeCurrentSize += f4.FBESize;

            if ((fbeCurrentSize + f5.FBESize) > fbeStructSize)
                return true;
            if (!f5.Verify())
                return false;
            fbeCurrentSize += f5.FBESize;

            if ((fbeCurrentSize + f6.FBESize) > fbeStructSize)
                return true;
            if (!f6.Verify())
                return false;
            fbeCurrentSize += f6.FBESize;

            if ((fbeCurrentSize + f7.FBESize) > fbeStructSize)
                return true;
            if (!f7.Verify())
                return false;
            fbeCurrentSize += f7.FBESize;

            if ((fbeCurrentSize + f8.FBESize) > fbeStructSize)
                return true;
            if (!f8.Verify())
                return false;
            fbeCurrentSize += f8.FBESize;

            if ((fbeCurrentSize + f9.FBESize) > fbeStructSize)
                return true;
            if (!f9.Verify())
                return false;
            fbeCurrentSize += f9.FBESize;

            if ((fbeCurrentSize + f10.FBESize) > fbeStructSize)
                return true;
            if (!f10.Verify())
                return false;
            fbeCurrentSize += f10.FBESize;

            if ((fbeCurrentSize + f11.FBESize) > fbeStructSize)
                return true;
            if (!f11.Verify())
                return false;
            fbeCurrentSize += f11.FBESize;

            if ((fbeCurrentSize + f12.FBESize) > fbeStructSize)
                return true;
            if (!f12.Verify())
                return false;
            fbeCurrentSize += f12.FBESize;

            if ((fbeCurrentSize + f13.FBESize) > fbeStructSize)
                return true;
            if (!f13.Verify())
                return false;
            fbeCurrentSize += f13.FBESize;

            if ((fbeCurrentSize + f14.FBESize) > fbeStructSize)
                return true;
            if (!f14.Verify())
                return false;
            fbeCurrentSize += f14.FBESize;

            if ((fbeCurrentSize + f15.FBESize) > fbeStructSize)
                return true;
            if (!f15.Verify())
                return false;
            fbeCurrentSize += f15.FBESize;

            if ((fbeCurrentSize + f16.FBESize) > fbeStructSize)
                return true;
            if (!f16.Verify())
                return false;
            fbeCurrentSize += f16.FBESize;

            if ((fbeCurrentSize + f17.FBESize) > fbeStructSize)
                return true;
            if (!f17.Verify())
                return false;
            fbeCurrentSize += f17.FBESize;

            if ((fbeCurrentSize + f18.FBESize) > fbeStructSize)
                return true;
            if (!f18.Verify())
                return false;
            fbeCurrentSize += f18.FBESize;

            if ((fbeCurrentSize + f19.FBESize) > fbeStructSize)
                return true;
            if (!f19.Verify())
                return false;
            fbeCurrentSize += f19.FBESize;

            if ((fbeCurrentSize + f20.FBESize) > fbeStructSize)
                return true;
            if (!f20.Verify())
                return false;
            fbeCurrentSize += f20.FBESize;

            if ((fbeCurrentSize + f21.FBESize) > fbeStructSize)
                return true;
            if (!f21.Verify())
                return false;
            fbeCurrentSize += f21.FBESize;

            if ((fbeCurrentSize + f22.FBESize) > fbeStructSize)
                return true;
            if (!f22.Verify())
                return false;
            fbeCurrentSize += f22.FBESize;

            if ((fbeCurrentSize + f23.FBESize) > fbeStructSize)
                return true;
            if (!f23.Verify())
                return false;
            fbeCurrentSize += f23.FBESize;

            if ((fbeCurrentSize + f24.FBESize) > fbeStructSize)
                return true;
            if (!f24.Verify())
                return false;
            fbeCurrentSize += f24.FBESize;

            if ((fbeCurrentSize + f25.FBESize) > fbeStructSize)
                return true;
            if (!f25.Verify())
                return false;
            fbeCurrentSize += f25.FBESize;

            if ((fbeCurrentSize + f26.FBESize) > fbeStructSize)
                return true;
            if (!f26.Verify())
                return false;
            fbeCurrentSize += f26.FBESize;

            if ((fbeCurrentSize + f27.FBESize) > fbeStructSize)
                return true;
            if (!f27.Verify())
                return false;
            fbeCurrentSize += f27.FBESize;

            if ((fbeCurrentSize + f28.FBESize) > fbeStructSize)
                return true;
            if (!f28.Verify())
                return false;
            fbeCurrentSize += f28.FBESize;

            if ((fbeCurrentSize + f29.FBESize) > fbeStructSize)
                return true;
            if (!f29.Verify())
                return false;
            fbeCurrentSize += f29.FBESize;

            if ((fbeCurrentSize + f30.FBESize) > fbeStructSize)
                return true;
            if (!f30.Verify())
                return false;
            fbeCurrentSize += f30.FBESize;

            if ((fbeCurrentSize + f31.FBESize) > fbeStructSize)
                return true;
            if (!f31.Verify())
                return false;
            fbeCurrentSize += f31.FBESize;

            if ((fbeCurrentSize + f32.FBESize) > fbeStructSize)
                return true;
            if (!f32.Verify())
                return false;
            fbeCurrentSize += f32.FBESize;

            if ((fbeCurrentSize + f33.FBESize) > fbeStructSize)
                return true;
            if (!f33.Verify())
                return false;
            fbeCurrentSize += f33.FBESize;

            if ((fbeCurrentSize + f34.FBESize) > fbeStructSize)
                return true;
            if (!f34.Verify())
                return false;
            fbeCurrentSize += f34.FBESize;

            if ((fbeCurrentSize + f35.FBESize) > fbeStructSize)
                return true;
            if (!f35.Verify())
                return false;
            fbeCurrentSize += f35.FBESize;

            if ((fbeCurrentSize + f36.FBESize) > fbeStructSize)
                return true;
            if (!f36.Verify())
                return false;
            fbeCurrentSize += f36.FBESize;

            if ((fbeCurrentSize + f37.FBESize) > fbeStructSize)
                return true;
            if (!f37.Verify())
                return false;
            fbeCurrentSize += f37.FBESize;

            if ((fbeCurrentSize + f38.FBESize) > fbeStructSize)
                return true;
            if (!f38.Verify())
                return false;
            fbeCurrentSize += f38.FBESize;

            if ((fbeCurrentSize + f39.FBESize) > fbeStructSize)
                return true;
            if (!f39.Verify())
                return false;
            fbeCurrentSize += f39.FBESize;

            if ((fbeCurrentSize + f40.FBESize) > fbeStructSize)
                return true;
            if (!f40.Verify())
                return false;
            fbeCurrentSize += f40.FBESize;

            if ((fbeCurrentSize + f41.FBESize) > fbeStructSize)
                return true;
            if (!f41.Verify())
                return false;
            fbeCurrentSize += f41.FBESize;

            if ((fbeCurrentSize + f42.FBESize) > fbeStructSize)
                return true;
            if (!f42.Verify())
                return false;
            fbeCurrentSize += f42.FBESize;

            if ((fbeCurrentSize + f43.FBESize) > fbeStructSize)
                return true;
            if (!f43.Verify())
                return false;
            fbeCurrentSize += f43.FBESize;

            if ((fbeCurrentSize + f44.FBESize) > fbeStructSize)
                return true;
            if (!f44.Verify())
                return false;
            fbeCurrentSize += f44.FBESize;

            return true;
        }

        // Get the struct value (begin phase)
        public long GetBegin()
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            uint fbeStructOffset = ReadUInt32(FBEOffset);
            Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + 4 + 4) <= _buffer.Size)), "Model is broken!");
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
                return 0;

            uint fbeStructSize = ReadUInt32(fbeStructOffset);
            Debug.Assert((fbeStructSize >= (4 + 4)), "Model is broken!");
            if (fbeStructSize < (4 + 4))
                return 0;

            _buffer.Shift(fbeStructOffset);
            return fbeStructOffset;
        }

        // Get the struct value (end phase)
        public void GetEnd(long fbeBegin)
        {
            _buffer.Unshift(fbeBegin);
        }

        // Get the struct value
        public override void Get(out StructSimple fbeValue) { Get(out fbeValue, StructSimple.Default); }
        public override void Get(out StructSimple fbeValue, StructSimple defaults)
        {
            long fbeBegin = GetBegin();
            if (fbeBegin == 0)
            {
                fbeValue = defaults;
                return;
            }

            uint fbeStructSize = ReadUInt32(0);
            GetFields(out fbeValue, fbeStructSize);
            GetEnd(fbeBegin);
        }

        // Get the struct fields values
        public void GetFields(out StructSimple fbeValue, long fbeStructSize)
        {
            long fbeCurrentSize = 4 + 4;

            fbeValue = StructSimple.Default;

            if ((fbeCurrentSize + id.FBESize) <= fbeStructSize)
                id.Get(out fbeValue.id);
            else
                fbeValue.id = (int)0;
            fbeCurrentSize += id.FBESize;

            if ((fbeCurrentSize + f1.FBESize) <= fbeStructSize)
                f1.Get(out fbeValue.f1);
            else
                fbeValue.f1 = false;
            fbeCurrentSize += f1.FBESize;

            if ((fbeCurrentSize + f2.FBESize) <= fbeStructSize)
                f2.Get(out fbeValue.f2, true);
            else
                fbeValue.f2 = true;
            fbeCurrentSize += f2.FBESize;

            if ((fbeCurrentSize + f3.FBESize) <= fbeStructSize)
                f3.Get(out fbeValue.f3);
            else
                fbeValue.f3 = (byte)0U;
            fbeCurrentSize += f3.FBESize;

            if ((fbeCurrentSize + f4.FBESize) <= fbeStructSize)
                f4.Get(out fbeValue.f4, Byte.MaxValue);
            else
                fbeValue.f4 = Byte.MaxValue;
            fbeCurrentSize += f4.FBESize;

            if ((fbeCurrentSize + f5.FBESize) <= fbeStructSize)
                f5.Get(out fbeValue.f5);
            else
                fbeValue.f5 = '\0';
            fbeCurrentSize += f5.FBESize;

            if ((fbeCurrentSize + f6.FBESize) <= fbeStructSize)
                f6.Get(out fbeValue.f6, (char)'!');
            else
                fbeValue.f6 = (char)'!';
            fbeCurrentSize += f6.FBESize;

            if ((fbeCurrentSize + f7.FBESize) <= fbeStructSize)
                f7.Get(out fbeValue.f7);
            else
                fbeValue.f7 = '\0';
            fbeCurrentSize += f7.FBESize;

            if ((fbeCurrentSize + f8.FBESize) <= fbeStructSize)
                f8.Get(out fbeValue.f8, (char)0x0444);
            else
                fbeValue.f8 = (char)0x0444;
            fbeCurrentSize += f8.FBESize;

            if ((fbeCurrentSize + f9.FBESize) <= fbeStructSize)
                f9.Get(out fbeValue.f9);
            else
                fbeValue.f9 = (sbyte)0;
            fbeCurrentSize += f9.FBESize;

            if ((fbeCurrentSize + f10.FBESize) <= fbeStructSize)
                f10.Get(out fbeValue.f10, SByte.MaxValue);
            else
                fbeValue.f10 = SByte.MaxValue;
            fbeCurrentSize += f10.FBESize;

            if ((fbeCurrentSize + f11.FBESize) <= fbeStructSize)
                f11.Get(out fbeValue.f11, Byte.MinValue);
            else
                fbeValue.f11 = Byte.MinValue;
            fbeCurrentSize += f11.FBESize;

            if ((fbeCurrentSize + f12.FBESize) <= fbeStructSize)
                f12.Get(out fbeValue.f12, Byte.MaxValue);
            else
                fbeValue.f12 = Byte.MaxValue;
            fbeCurrentSize += f12.FBESize;

            if ((fbeCurrentSize + f13.FBESize) <= fbeStructSize)
                f13.Get(out fbeValue.f13);
            else
                fbeValue.f13 = (short)0;
            fbeCurrentSize += f13.FBESize;

            if ((fbeCurrentSize + f14.FBESize) <= fbeStructSize)
                f14.Get(out fbeValue.f14, Int16.MaxValue);
            else
                fbeValue.f14 = Int16.MaxValue;
            fbeCurrentSize += f14.FBESize;

            if ((fbeCurrentSize + f15.FBESize) <= fbeStructSize)
                f15.Get(out fbeValue.f15, UInt16.MinValue);
            else
                fbeValue.f15 = UInt16.MinValue;
            fbeCurrentSize += f15.FBESize;

            if ((fbeCurrentSize + f16.FBESize) <= fbeStructSize)
                f16.Get(out fbeValue.f16, UInt16.MaxValue);
            else
                fbeValue.f16 = UInt16.MaxValue;
            fbeCurrentSize += f16.FBESize;

            if ((fbeCurrentSize + f17.FBESize) <= fbeStructSize)
                f17.Get(out fbeValue.f17);
            else
                fbeValue.f17 = (int)0;
            fbeCurrentSize += f17.FBESize;

            if ((fbeCurrentSize + f18.FBESize) <= fbeStructSize)
                f18.Get(out fbeValue.f18, Int32.MaxValue);
            else
                fbeValue.f18 = Int32.MaxValue;
            fbeCurrentSize += f18.FBESize;

            if ((fbeCurrentSize + f19.FBESize) <= fbeStructSize)
                f19.Get(out fbeValue.f19, UInt32.MinValue);
            else
                fbeValue.f19 = UInt32.MinValue;
            fbeCurrentSize += f19.FBESize;

            if ((fbeCurrentSize + f20.FBESize) <= fbeStructSize)
                f20.Get(out fbeValue.f20, UInt32.MaxValue);
            else
                fbeValue.f20 = UInt32.MaxValue;
            fbeCurrentSize += f20.FBESize;

            if ((fbeCurrentSize + f21.FBESize) <= fbeStructSize)
                f21.Get(out fbeValue.f21);
            else
                fbeValue.f21 = (long)0L;
            fbeCurrentSize += f21.FBESize;

            if ((fbeCurrentSize + f22.FBESize) <= fbeStructSize)
                f22.Get(out fbeValue.f22, Int64.MaxValue);
            else
                fbeValue.f22 = Int64.MaxValue;
            fbeCurrentSize += f22.FBESize;

            if ((fbeCurrentSize + f23.FBESize) <= fbeStructSize)
                f23.Get(out fbeValue.f23, UInt64.MinValue);
            else
                fbeValue.f23 = UInt64.MinValue;
            fbeCurrentSize += f23.FBESize;

            if ((fbeCurrentSize + f24.FBESize) <= fbeStructSize)
                f24.Get(out fbeValue.f24, UInt64.MaxValue);
            else
                fbeValue.f24 = UInt64.MaxValue;
            fbeCurrentSize += f24.FBESize;

            if ((fbeCurrentSize + f25.FBESize) <= fbeStructSize)
                f25.Get(out fbeValue.f25);
            else
                fbeValue.f25 = 0.0F;
            fbeCurrentSize += f25.FBESize;

            if ((fbeCurrentSize + f26.FBESize) <= fbeStructSize)
                f26.Get(out fbeValue.f26, (float)123.456F);
            else
                fbeValue.f26 = (float)123.456F;
            fbeCurrentSize += f26.FBESize;

            if ((fbeCurrentSize + f27.FBESize) <= fbeStructSize)
                f27.Get(out fbeValue.f27);
            else
                fbeValue.f27 = 0.0D;
            fbeCurrentSize += f27.FBESize;

            if ((fbeCurrentSize + f28.FBESize) <= fbeStructSize)
                f28.Get(out fbeValue.f28, (double)-123.456e+123D);
            else
                fbeValue.f28 = (double)-123.456e+123D;
            fbeCurrentSize += f28.FBESize;

            if ((fbeCurrentSize + f29.FBESize) <= fbeStructSize)
                f29.Get(out fbeValue.f29);
            else
                fbeValue.f29 = 0.0M;
            fbeCurrentSize += f29.FBESize;

            if ((fbeCurrentSize + f30.FBESize) <= fbeStructSize)
                f30.Get(out fbeValue.f30, (decimal)123456.123456M);
            else
                fbeValue.f30 = (decimal)123456.123456M;
            fbeCurrentSize += f30.FBESize;

            if ((fbeCurrentSize + f31.FBESize) <= fbeStructSize)
                f31.Get(out fbeValue.f31);
            else
                fbeValue.f31 = "";
            fbeCurrentSize += f31.FBESize;

            if ((fbeCurrentSize + f32.FBESize) <= fbeStructSize)
                f32.Get(out fbeValue.f32, "Initial string!");
            else
                fbeValue.f32 = "Initial string!";
            fbeCurrentSize += f32.FBESize;

            if ((fbeCurrentSize + f33.FBESize) <= fbeStructSize)
                f33.Get(out fbeValue.f33);
            else
                fbeValue.f33 = new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc);
            fbeCurrentSize += f33.FBESize;

            if ((fbeCurrentSize + f34.FBESize) <= fbeStructSize)
                f34.Get(out fbeValue.f34, new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc));
            else
                fbeValue.f34 = new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc);
            fbeCurrentSize += f34.FBESize;

            if ((fbeCurrentSize + f35.FBESize) <= fbeStructSize)
                f35.Get(out fbeValue.f35, DateTime.UtcNow);
            else
                fbeValue.f35 = DateTime.UtcNow;
            fbeCurrentSize += f35.FBESize;

            if ((fbeCurrentSize + f36.FBESize) <= fbeStructSize)
                f36.Get(out fbeValue.f36);
            else
                fbeValue.f36 = com.chronoxor.FBE.UuidGenerator.Nil();
            fbeCurrentSize += f36.FBESize;

            if ((fbeCurrentSize + f37.FBESize) <= fbeStructSize)
                f37.Get(out fbeValue.f37, com.chronoxor.FBE.UuidGenerator.Sequential());
            else
                fbeValue.f37 = com.chronoxor.FBE.UuidGenerator.Sequential();
            fbeCurrentSize += f37.FBESize;

            if ((fbeCurrentSize + f38.FBESize) <= fbeStructSize)
                f38.Get(out fbeValue.f38, Guid.Parse("123e4567-e89b-12d3-a456-426655440000"));
            else
                fbeValue.f38 = Guid.Parse("123e4567-e89b-12d3-a456-426655440000");
            fbeCurrentSize += f38.FBESize;

            if ((fbeCurrentSize + f39.FBESize) <= fbeStructSize)
                f39.Get(out fbeValue.f39);
            else
                fbeValue.f39 = global::com.chronoxor.proto.OrderSide.Default;
            fbeCurrentSize += f39.FBESize;

            if ((fbeCurrentSize + f40.FBESize) <= fbeStructSize)
                f40.Get(out fbeValue.f40);
            else
                fbeValue.f40 = global::com.chronoxor.proto.OrderType.Default;
            fbeCurrentSize += f40.FBESize;

            if ((fbeCurrentSize + f41.FBESize) <= fbeStructSize)
                f41.Get(out fbeValue.f41);
            else
                fbeValue.f41 = global::com.chronoxor.proto.Order.Default;
            fbeCurrentSize += f41.FBESize;

            if ((fbeCurrentSize + f42.FBESize) <= fbeStructSize)
                f42.Get(out fbeValue.f42);
            else
                fbeValue.f42 = global::com.chronoxor.proto.Balance.Default;
            fbeCurrentSize += f42.FBESize;

            if ((fbeCurrentSize + f43.FBESize) <= fbeStructSize)
                f43.Get(out fbeValue.f43);
            else
                fbeValue.f43 = global::com.chronoxor.proto.State.Default;
            fbeCurrentSize += f43.FBESize;

            if ((fbeCurrentSize + f44.FBESize) <= fbeStructSize)
                f44.Get(out fbeValue.f44);
            else
                fbeValue.f44 = global::com.chronoxor.proto.Account.Default;
            fbeCurrentSize += f44.FBESize;
        }

        // Set the struct value (begin phase)
        public long SetBegin()
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            uint fbeStructSize = (uint)FBEBody;
            uint fbeStructOffset = (uint)(_buffer.Allocate(fbeStructSize) - _buffer.Offset);
            Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + fbeStructSize) <= _buffer.Size)), "Model is broken!");
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + fbeStructSize) > _buffer.Size))
                return 0;

            Write(FBEOffset, fbeStructOffset);
            Write(fbeStructOffset, fbeStructSize);
            Write(fbeStructOffset + 4, (uint)FBEType);

            _buffer.Shift(fbeStructOffset);
            return fbeStructOffset;
        }

        // Set the struct value (end phase)
        public void SetEnd(long fbeBegin)
        {
            _buffer.Unshift(fbeBegin);
        }

        // Set the struct value
        public override void Set(StructSimple fbeValue)
        {
            long fbeBegin = SetBegin();
            if (fbeBegin == 0)
                return;

            SetFields(fbeValue);
            SetEnd(fbeBegin);
        }

        // Set the struct fields values
        public void SetFields(StructSimple fbeValue)
        {
            id.Set(fbeValue.id);
            f1.Set(fbeValue.f1);
            f2.Set(fbeValue.f2);
            f3.Set(fbeValue.f3);
            f4.Set(fbeValue.f4);
            f5.Set(fbeValue.f5);
            f6.Set(fbeValue.f6);
            f7.Set(fbeValue.f7);
            f8.Set(fbeValue.f8);
            f9.Set(fbeValue.f9);
            f10.Set(fbeValue.f10);
            f11.Set(fbeValue.f11);
            f12.Set(fbeValue.f12);
            f13.Set(fbeValue.f13);
            f14.Set(fbeValue.f14);
            f15.Set(fbeValue.f15);
            f16.Set(fbeValue.f16);
            f17.Set(fbeValue.f17);
            f18.Set(fbeValue.f18);
            f19.Set(fbeValue.f19);
            f20.Set(fbeValue.f20);
            f21.Set(fbeValue.f21);
            f22.Set(fbeValue.f22);
            f23.Set(fbeValue.f23);
            f24.Set(fbeValue.f24);
            f25.Set(fbeValue.f25);
            f26.Set(fbeValue.f26);
            f27.Set(fbeValue.f27);
            f28.Set(fbeValue.f28);
            f29.Set(fbeValue.f29);
            f30.Set(fbeValue.f30);
            f31.Set(fbeValue.f31);
            f32.Set(fbeValue.f32);
            f33.Set(fbeValue.f33);
            f34.Set(fbeValue.f34);
            f35.Set(fbeValue.f35);
            f36.Set(fbeValue.f36);
            f37.Set(fbeValue.f37);
            f38.Set(fbeValue.f38);
            f39.Set(fbeValue.f39);
            f40.Set(fbeValue.f40);
            f41.Set(fbeValue.f41);
            f42.Set(fbeValue.f42);
            f43.Set(fbeValue.f43);
            f44.Set(fbeValue.f44);
        }
    }

} // namespace com.chronoxor.test.FBE

namespace com.chronoxor.test.FBE {

    using global::com.chronoxor.test;

    // Fast Binary Encoding StructSimple model
    public class StructSimpleModel : com.chronoxor.FBE.Model
    {
        public readonly FieldModelStructSimple model;

        public StructSimpleModel() { model = new FieldModelStructSimple(Buffer, 4); }
        public StructSimpleModel(com.chronoxor.FBE.Buffer buffer) : base(buffer) { model = new FieldModelStructSimple(Buffer, 4); }

        // Get the model size
        public long FBESize => model.FBESize + model.FBEExtra;
        // Get the model type
        public const long FBETypeConst = FieldModelStructSimple.FBETypeConst;
        public long FBEType => FBETypeConst;

        // Check if the struct value is valid
        public bool Verify()
        {
            if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
                return false;

            uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
            if (fbeFullSize < model.FBESize)
                return false;

            return model.Verify();
        }

        // Create a new model (begin phase)
        public long CreateBegin()
        {
            long fbeBegin = Buffer.Allocate(4 + model.FBESize);
            return fbeBegin;
        }

        // Create a new model (end phase)
        public long CreateEnd(long fbeBegin)
        {
            long fbeEnd = Buffer.Size;
            uint fbeFullSize = (uint)(fbeEnd - fbeBegin);
            Write(model.FBEOffset - 4, fbeFullSize);
            return fbeFullSize;
        }

        // Serialize the struct value
        public long Serialize(StructSimple value)
        {
            long fbeBegin = CreateBegin();
            model.Set(value);
            long fbeFullSize = CreateEnd(fbeBegin);
            return fbeFullSize;
        }

        // Deserialize the struct value
        public long Deserialize(out StructSimple value)
        {
            if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
            {
                value = StructSimple.Default;
                return 0;
            }

            uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
            Debug.Assert((fbeFullSize >= model.FBESize), "Model is broken!");
            if (fbeFullSize < model.FBESize)
            {
                value = StructSimple.Default;
                return 0;
            }

            model.Get(out value);
            return fbeFullSize;
        }

        // Move to the next struct value
        public void Next(long prev)
        {
            model.FBEShift(prev);
        }
    }

} // namespace com.chronoxor.test.FBE

namespace com.chronoxor.test.FBE {

    using global::com.chronoxor.test;

    // Fast Binary Encoding StructSimple final model
    public class FinalModelStructSimple : com.chronoxor.FBE.FinalModelValueType<StructSimple>
    {
        public readonly com.chronoxor.FBE.FinalModelValueType<int> id;
        public readonly com.chronoxor.FBE.FinalModelValueType<bool> f1;
        public readonly com.chronoxor.FBE.FinalModelValueType<bool> f2;
        public readonly com.chronoxor.FBE.FinalModelValueType<byte> f3;
        public readonly com.chronoxor.FBE.FinalModelValueType<byte> f4;
        public readonly com.chronoxor.FBE.FinalModelValueType<char> f5;
        public readonly com.chronoxor.FBE.FinalModelValueType<char> f6;
        public readonly com.chronoxor.FBE.FinalModelValueType<char> f7;
        public readonly com.chronoxor.FBE.FinalModelValueType<char> f8;
        public readonly com.chronoxor.FBE.FinalModelValueType<sbyte> f9;
        public readonly com.chronoxor.FBE.FinalModelValueType<sbyte> f10;
        public readonly com.chronoxor.FBE.FinalModelValueType<byte> f11;
        public readonly com.chronoxor.FBE.FinalModelValueType<byte> f12;
        public readonly com.chronoxor.FBE.FinalModelValueType<short> f13;
        public readonly com.chronoxor.FBE.FinalModelValueType<short> f14;
        public readonly com.chronoxor.FBE.FinalModelValueType<ushort> f15;
        public readonly com.chronoxor.FBE.FinalModelValueType<ushort> f16;
        public readonly com.chronoxor.FBE.FinalModelValueType<int> f17;
        public readonly com.chronoxor.FBE.FinalModelValueType<int> f18;
        public readonly com.chronoxor.FBE.FinalModelValueType<uint> f19;
        public readonly com.chronoxor.FBE.FinalModelValueType<uint> f20;
        public readonly com.chronoxor.FBE.FinalModelValueType<long> f21;
        public readonly com.chronoxor.FBE.FinalModelValueType<long> f22;
        public readonly com.chronoxor.FBE.FinalModelValueType<ulong> f23;
        public readonly com.chronoxor.FBE.FinalModelValueType<ulong> f24;
        public readonly com.chronoxor.FBE.FinalModelValueType<float> f25;
        public readonly com.chronoxor.FBE.FinalModelValueType<float> f26;
        public readonly com.chronoxor.FBE.FinalModelValueType<double> f27;
        public readonly com.chronoxor.FBE.FinalModelValueType<double> f28;
        public readonly com.chronoxor.FBE.FinalModelValueType<decimal> f29;
        public readonly com.chronoxor.FBE.FinalModelValueType<decimal> f30;
        public readonly com.chronoxor.FBE.FinalModelReferenceType<string> f31;
        public readonly com.chronoxor.FBE.FinalModelReferenceType<string> f32;
        public readonly com.chronoxor.FBE.FinalModelValueType<DateTime> f33;
        public readonly com.chronoxor.FBE.FinalModelValueType<DateTime> f34;
        public readonly com.chronoxor.FBE.FinalModelValueType<DateTime> f35;
        public readonly com.chronoxor.FBE.FinalModelValueType<Guid> f36;
        public readonly com.chronoxor.FBE.FinalModelValueType<Guid> f37;
        public readonly com.chronoxor.FBE.FinalModelValueType<Guid> f38;
        public readonly com.chronoxor.proto.FBE.FinalModelOrderSide f39;
        public readonly com.chronoxor.proto.FBE.FinalModelOrderType f40;
        public readonly com.chronoxor.proto.FBE.FinalModelOrder f41;
        public readonly com.chronoxor.proto.FBE.FinalModelBalance f42;
        public readonly com.chronoxor.proto.FBE.FinalModelState f43;
        public readonly com.chronoxor.proto.FBE.FinalModelAccount f44;

        public FinalModelStructSimple(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset)
        {
            id = com.chronoxor.FBE.FinalModelValueType<int>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.INT32, buffer, 0);
            f1 = com.chronoxor.FBE.FinalModelValueType<bool>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.BOOL, buffer, 0);
            f2 = com.chronoxor.FBE.FinalModelValueType<bool>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.BOOL, buffer, 0);
            f3 = com.chronoxor.FBE.FinalModelValueType<byte>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.BYTE, buffer, 0);
            f4 = com.chronoxor.FBE.FinalModelValueType<byte>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.BYTE, buffer, 0);
            f5 = com.chronoxor.FBE.FinalModelValueType<char>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.CHAR, buffer, 0);
            f6 = com.chronoxor.FBE.FinalModelValueType<char>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.CHAR, buffer, 0);
            f7 = com.chronoxor.FBE.FinalModelValueType<char>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.WCHAR, buffer, 0);
            f8 = com.chronoxor.FBE.FinalModelValueType<char>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.WCHAR, buffer, 0);
            f9 = com.chronoxor.FBE.FinalModelValueType<sbyte>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.INT8, buffer, 0);
            f10 = com.chronoxor.FBE.FinalModelValueType<sbyte>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.INT8, buffer, 0);
            f11 = com.chronoxor.FBE.FinalModelValueType<byte>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.UINT8, buffer, 0);
            f12 = com.chronoxor.FBE.FinalModelValueType<byte>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.UINT8, buffer, 0);
            f13 = com.chronoxor.FBE.FinalModelValueType<short>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.INT16, buffer, 0);
            f14 = com.chronoxor.FBE.FinalModelValueType<short>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.INT16, buffer, 0);
            f15 = com.chronoxor.FBE.FinalModelValueType<ushort>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.UINT16, buffer, 0);
            f16 = com.chronoxor.FBE.FinalModelValueType<ushort>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.UINT16, buffer, 0);
            f17 = com.chronoxor.FBE.FinalModelValueType<int>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.INT32, buffer, 0);
            f18 = com.chronoxor.FBE.FinalModelValueType<int>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.INT32, buffer, 0);
            f19 = com.chronoxor.FBE.FinalModelValueType<uint>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.UINT32, buffer, 0);
            f20 = com.chronoxor.FBE.FinalModelValueType<uint>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.UINT32, buffer, 0);
            f21 = com.chronoxor.FBE.FinalModelValueType<long>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.INT64, buffer, 0);
            f22 = com.chronoxor.FBE.FinalModelValueType<long>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.INT64, buffer, 0);
            f23 = com.chronoxor.FBE.FinalModelValueType<ulong>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.UINT64, buffer, 0);
            f24 = com.chronoxor.FBE.FinalModelValueType<ulong>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.UINT64, buffer, 0);
            f25 = com.chronoxor.FBE.FinalModelValueType<float>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.FLOAT, buffer, 0);
            f26 = com.chronoxor.FBE.FinalModelValueType<float>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.FLOAT, buffer, 0);
            f27 = com.chronoxor.FBE.FinalModelValueType<double>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.DOUBLE, buffer, 0);
            f28 = com.chronoxor.FBE.FinalModelValueType<double>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.DOUBLE, buffer, 0);
            f29 = com.chronoxor.FBE.FinalModelValueType<decimal>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.DECIMAL, buffer, 0);
            f30 = com.chronoxor.FBE.FinalModelValueType<decimal>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.DECIMAL, buffer, 0);
            f31 = com.chronoxor.FBE.FinalModelReferenceType<string>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.STRING, buffer, 0);
            f32 = com.chronoxor.FBE.FinalModelReferenceType<string>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.STRING, buffer, 0);
            f33 = com.chronoxor.FBE.FinalModelValueType<DateTime>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.TIMESTAMP, buffer, 0);
            f34 = com.chronoxor.FBE.FinalModelValueType<DateTime>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.TIMESTAMP, buffer, 0);
            f35 = com.chronoxor.FBE.FinalModelValueType<DateTime>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.TIMESTAMP, buffer, 0);
            f36 = com.chronoxor.FBE.FinalModelValueType<Guid>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.UUID, buffer, 0);
            f37 = com.chronoxor.FBE.FinalModelValueType<Guid>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.UUID, buffer, 0);
            f38 = com.chronoxor.FBE.FinalModelValueType<Guid>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.UUID, buffer, 0);
            f39 = new com.chronoxor.proto.FBE.FinalModelOrderSide(buffer, 0);
            f40 = new com.chronoxor.proto.FBE.FinalModelOrderType(buffer, 0);
            f41 = new com.chronoxor.proto.FBE.FinalModelOrder(buffer, 0);
            f42 = new com.chronoxor.proto.FBE.FinalModelBalance(buffer, 0);
            f43 = new com.chronoxor.proto.FBE.FinalModelState(buffer, 0);
            f44 = new com.chronoxor.proto.FBE.FinalModelAccount(buffer, 0);
        }

        // Get the allocation size
        public override long FBEAllocationSize(StructSimple fbeValue)
        {
            long fbeResult = 0
                + id.FBEAllocationSize(fbeValue.id)
                + f1.FBEAllocationSize(fbeValue.f1)
                + f2.FBEAllocationSize(fbeValue.f2)
                + f3.FBEAllocationSize(fbeValue.f3)
                + f4.FBEAllocationSize(fbeValue.f4)
                + f5.FBEAllocationSize(fbeValue.f5)
                + f6.FBEAllocationSize(fbeValue.f6)
                + f7.FBEAllocationSize(fbeValue.f7)
                + f8.FBEAllocationSize(fbeValue.f8)
                + f9.FBEAllocationSize(fbeValue.f9)
                + f10.FBEAllocationSize(fbeValue.f10)
                + f11.FBEAllocationSize(fbeValue.f11)
                + f12.FBEAllocationSize(fbeValue.f12)
                + f13.FBEAllocationSize(fbeValue.f13)
                + f14.FBEAllocationSize(fbeValue.f14)
                + f15.FBEAllocationSize(fbeValue.f15)
                + f16.FBEAllocationSize(fbeValue.f16)
                + f17.FBEAllocationSize(fbeValue.f17)
                + f18.FBEAllocationSize(fbeValue.f18)
                + f19.FBEAllocationSize(fbeValue.f19)
                + f20.FBEAllocationSize(fbeValue.f20)
                + f21.FBEAllocationSize(fbeValue.f21)
                + f22.FBEAllocationSize(fbeValue.f22)
                + f23.FBEAllocationSize(fbeValue.f23)
                + f24.FBEAllocationSize(fbeValue.f24)
                + f25.FBEAllocationSize(fbeValue.f25)
                + f26.FBEAllocationSize(fbeValue.f26)
                + f27.FBEAllocationSize(fbeValue.f27)
                + f28.FBEAllocationSize(fbeValue.f28)
                + f29.FBEAllocationSize(fbeValue.f29)
                + f30.FBEAllocationSize(fbeValue.f30)
                + f31.FBEAllocationSize(fbeValue.f31)
                + f32.FBEAllocationSize(fbeValue.f32)
                + f33.FBEAllocationSize(fbeValue.f33)
                + f34.FBEAllocationSize(fbeValue.f34)
                + f35.FBEAllocationSize(fbeValue.f35)
                + f36.FBEAllocationSize(fbeValue.f36)
                + f37.FBEAllocationSize(fbeValue.f37)
                + f38.FBEAllocationSize(fbeValue.f38)
                + f39.FBEAllocationSize(fbeValue.f39)
                + f40.FBEAllocationSize(fbeValue.f40)
                + f41.FBEAllocationSize(fbeValue.f41)
                + f42.FBEAllocationSize(fbeValue.f42)
                + f43.FBEAllocationSize(fbeValue.f43)
                + f44.FBEAllocationSize(fbeValue.f44)
                ;
            return fbeResult;
        }

        // Get the final type
        public const long FBETypeConst = 110;
        public long FBEType => FBETypeConst;

        // Clone the final model
        public override com.chronoxor.FBE.FinalModelValueType<StructSimple> Clone() { return new FinalModelStructSimple(_buffer, _offset); }

        // Check if the struct value is valid
        public override long Verify()
        {
            _buffer.Shift(FBEOffset);
            long fbeResult = VerifyFields();
            _buffer.Unshift(FBEOffset);
            return fbeResult;
        }

        // Check if the struct fields are valid
        public long VerifyFields()
        {
            long fbeCurrentOffset = 0;
            long fbeFieldSize;

            id.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = id.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f1.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f1.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f2.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f2.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f3.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f3.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f4.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f4.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f5.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f5.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f6.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f6.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f7.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f7.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f8.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f8.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f9.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f9.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f10.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f10.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f11.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f11.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f12.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f12.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f13.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f13.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f14.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f14.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f15.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f15.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f16.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f16.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f17.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f17.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f18.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f18.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f19.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f19.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f20.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f20.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f21.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f21.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f22.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f22.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f23.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f23.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f24.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f24.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f25.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f25.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f26.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f26.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f27.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f27.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f28.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f28.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f29.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f29.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f30.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f30.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f31.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f31.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f32.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f32.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f33.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f33.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f34.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f34.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f35.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f35.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f36.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f36.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f37.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f37.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f38.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f38.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f39.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f39.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f40.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f40.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f41.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f41.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f42.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f42.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f43.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f43.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f44.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f44.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            return fbeCurrentOffset;
        }

        // Get the struct value
        public override long Get(out StructSimple fbeValue)
        {
            _buffer.Shift(FBEOffset);
            long fbeSize = GetFields(out fbeValue);
            _buffer.Unshift(FBEOffset);
            return fbeSize;
        }

        // Get the struct fields values
        public long GetFields(out StructSimple fbeValue)
        {
            long fbeCurrentOffset = 0;
            long fbeCurrentSize = 0;
            long fbeFieldSize;

            fbeValue = StructSimple.Default;

            id.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = id.Get(out fbeValue.id);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f1.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f1.Get(out fbeValue.f1);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f2.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f2.Get(out fbeValue.f2);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f3.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f3.Get(out fbeValue.f3);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f4.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f4.Get(out fbeValue.f4);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f5.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f5.Get(out fbeValue.f5);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f6.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f6.Get(out fbeValue.f6);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f7.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f7.Get(out fbeValue.f7);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f8.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f8.Get(out fbeValue.f8);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f9.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f9.Get(out fbeValue.f9);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f10.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f10.Get(out fbeValue.f10);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f11.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f11.Get(out fbeValue.f11);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f12.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f12.Get(out fbeValue.f12);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f13.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f13.Get(out fbeValue.f13);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f14.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f14.Get(out fbeValue.f14);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f15.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f15.Get(out fbeValue.f15);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f16.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f16.Get(out fbeValue.f16);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f17.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f17.Get(out fbeValue.f17);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f18.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f18.Get(out fbeValue.f18);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f19.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f19.Get(out fbeValue.f19);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f20.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f20.Get(out fbeValue.f20);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f21.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f21.Get(out fbeValue.f21);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f22.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f22.Get(out fbeValue.f22);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f23.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f23.Get(out fbeValue.f23);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f24.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f24.Get(out fbeValue.f24);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f25.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f25.Get(out fbeValue.f25);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f26.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f26.Get(out fbeValue.f26);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f27.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f27.Get(out fbeValue.f27);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f28.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f28.Get(out fbeValue.f28);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f29.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f29.Get(out fbeValue.f29);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f30.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f30.Get(out fbeValue.f30);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f31.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f31.Get(out fbeValue.f31);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f32.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f32.Get(out fbeValue.f32);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f33.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f33.Get(out fbeValue.f33);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f34.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f34.Get(out fbeValue.f34);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f35.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f35.Get(out fbeValue.f35);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f36.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f36.Get(out fbeValue.f36);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f37.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f37.Get(out fbeValue.f37);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f38.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f38.Get(out fbeValue.f38);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f39.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f39.Get(out fbeValue.f39);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f40.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f40.Get(out fbeValue.f40);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f41.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f41.Get(out fbeValue.f41);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f42.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f42.Get(out fbeValue.f42);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f43.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f43.Get(out fbeValue.f43);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f44.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f44.Get(out fbeValue.f44);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            return fbeCurrentSize;
        }

        // Set the struct value
        public override long Set(StructSimple fbeValue)
        {
            _buffer.Shift(FBEOffset);
            long fbeResult = SetFields(fbeValue);
            _buffer.Unshift(FBEOffset);
            return fbeResult;
        }

        // Set the struct fields values
        public long SetFields(StructSimple fbeValue)
        {
            long fbeCurrentOffset = 0;
            long fbeCurrentSize = 0;
            long fbeFieldSize;

            id.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = id.Set(fbeValue.id);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f1.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f1.Set(fbeValue.f1);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f2.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f2.Set(fbeValue.f2);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f3.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f3.Set(fbeValue.f3);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f4.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f4.Set(fbeValue.f4);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f5.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f5.Set(fbeValue.f5);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f6.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f6.Set(fbeValue.f6);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f7.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f7.Set(fbeValue.f7);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f8.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f8.Set(fbeValue.f8);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f9.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f9.Set(fbeValue.f9);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f10.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f10.Set(fbeValue.f10);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f11.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f11.Set(fbeValue.f11);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f12.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f12.Set(fbeValue.f12);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f13.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f13.Set(fbeValue.f13);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f14.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f14.Set(fbeValue.f14);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f15.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f15.Set(fbeValue.f15);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f16.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f16.Set(fbeValue.f16);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f17.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f17.Set(fbeValue.f17);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f18.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f18.Set(fbeValue.f18);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f19.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f19.Set(fbeValue.f19);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f20.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f20.Set(fbeValue.f20);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f21.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f21.Set(fbeValue.f21);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f22.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f22.Set(fbeValue.f22);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f23.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f23.Set(fbeValue.f23);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f24.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f24.Set(fbeValue.f24);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f25.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f25.Set(fbeValue.f25);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f26.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f26.Set(fbeValue.f26);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f27.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f27.Set(fbeValue.f27);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f28.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f28.Set(fbeValue.f28);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f29.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f29.Set(fbeValue.f29);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f30.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f30.Set(fbeValue.f30);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f31.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f31.Set(fbeValue.f31);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f32.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f32.Set(fbeValue.f32);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f33.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f33.Set(fbeValue.f33);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f34.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f34.Set(fbeValue.f34);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f35.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f35.Set(fbeValue.f35);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f36.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f36.Set(fbeValue.f36);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f37.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f37.Set(fbeValue.f37);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f38.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f38.Set(fbeValue.f38);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f39.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f39.Set(fbeValue.f39);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f40.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f40.Set(fbeValue.f40);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f41.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f41.Set(fbeValue.f41);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f42.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f42.Set(fbeValue.f42);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f43.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f43.Set(fbeValue.f43);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f44.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f44.Set(fbeValue.f44);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            return fbeCurrentSize;
        }
    }

} // namespace com.chronoxor.test.FBE

namespace com.chronoxor.test.FBE {

    using global::com.chronoxor.test;

    // Fast Binary Encoding StructSimple final model
    public class StructSimpleFinalModel : com.chronoxor.FBE.Model
    {
        private readonly FinalModelStructSimple _model;

        public StructSimpleFinalModel() { _model = new FinalModelStructSimple(Buffer, 8); }
        public StructSimpleFinalModel(com.chronoxor.FBE.Buffer buffer) : base(buffer) { _model = new FinalModelStructSimple(Buffer, 8); }

        // Get the model type
        public const long FBETypeConst = FinalModelStructSimple.FBETypeConst;
        public long FBEType => FBETypeConst;

        // Check if the struct value is valid
        public bool Verify()
        {
            if ((Buffer.Offset + _model.FBEOffset) > Buffer.Size)
                return false;

            long fbeStructSize = ReadUInt32(_model.FBEOffset - 8);
            long fbeStructType = ReadUInt32(_model.FBEOffset - 4);
            if ((fbeStructSize <= 0) || (fbeStructType != FBEType))
                return false;

            return ((8 + _model.Verify()) == fbeStructSize);
        }

        // Serialize the struct value
        public long Serialize(StructSimple value)
        {
            long fbeInitialSize = Buffer.Size;

            uint fbeStructType = (uint)FBEType;
            uint fbeStructSize = (uint)(8 + _model.FBEAllocationSize(value));
            uint fbeStructOffset = (uint)(Buffer.Allocate(fbeStructSize) - Buffer.Offset);
            Debug.Assert(((Buffer.Offset + fbeStructOffset + fbeStructSize) <= Buffer.Size), "Model is broken!");
            if ((Buffer.Offset + fbeStructOffset + fbeStructSize) > Buffer.Size)
                return 0;

            fbeStructSize = (uint)(8 + _model.Set(value));
            Buffer.Resize(fbeInitialSize + fbeStructSize);

            Write(_model.FBEOffset - 8, fbeStructSize);
            Write(_model.FBEOffset - 4, fbeStructType);

            return fbeStructSize;
        }

        // Deserialize the struct value
        public long Deserialize(out StructSimple value)
        {
            Debug.Assert(((Buffer.Offset + _model.FBEOffset) <= Buffer.Size), "Model is broken!");
            if ((Buffer.Offset + _model.FBEOffset) > Buffer.Size)
            {
                value = StructSimple.Default;
                return 0;
            }

            long fbeStructSize = ReadUInt32(_model.FBEOffset - 8);
            long fbeStructType = ReadUInt32(_model.FBEOffset - 4);
            Debug.Assert(((fbeStructSize > 0) && (fbeStructType == FBEType)), "Model is broken!");
            if ((fbeStructSize <= 0) || (fbeStructType != FBEType))
            {
                value = StructSimple.Default;
                return 8;
            }

            return 8 + _model.Get(out value);
        }

        // Move to the next struct value
        public void Next(long prev)
        {
            _model.FBEShift(prev);
        }
    }

} // namespace com.chronoxor.test.FBE

namespace com.chronoxor.test {

    public struct StructOptional : IComparable, IComparable<StructOptional>, IEquatable<StructOptional>
    {
        #if UTF8JSON
        [IgnoreDataMember]
        #else
        [JsonIgnore]
        #endif
        public StructSimple parent;
        public bool? f100;
        public bool? f101;
        public bool? f102;
        public byte? f103;
        public byte? f104;
        public byte? f105;
        public char? f106;
        public char? f107;
        public char? f108;
        public char? f109;
        public char? f110;
        public char? f111;
        public sbyte? f112;
        public sbyte? f113;
        public sbyte? f114;
        public byte? f115;
        public byte? f116;
        public byte? f117;
        public short? f118;
        public short? f119;
        public short? f120;
        public ushort? f121;
        public ushort? f122;
        public ushort? f123;
        public int? f124;
        public int? f125;
        public int? f126;
        public uint? f127;
        public uint? f128;
        public uint? f129;
        public long? f130;
        public long? f131;
        public long? f132;
        public ulong? f133;
        public ulong? f134;
        public ulong? f135;
        public float? f136;
        public float? f137;
        public float? f138;
        public double? f139;
        public double? f140;
        public double? f141;
        public decimal? f142;
        public decimal? f143;
        public decimal? f144;
        public string f145;
        public string f146;
        public string f147;
        public DateTime? f148;
        public DateTime? f149;
        public DateTime? f150;
        public Guid? f151;
        public Guid? f152;
        public Guid? f153;
        public proto.OrderSide? f154;
        public proto.OrderSide? f155;
        public proto.OrderType? f156;
        public proto.OrderType? f157;
        public proto.Order? f158;
        public proto.Order? f159;
        public proto.Balance? f160;
        public proto.Balance? f161;
        public proto.State? f162;
        public proto.State? f163;
        public proto.Account? f164;
        public proto.Account? f165;

        public const long FBETypeConst = 111;
        #if UTF8JSON
        [IgnoreDataMember]
        #else
        [JsonIgnore]
        #endif
        public long FBEType => FBETypeConst;

        public static StructOptional Default => new StructOptional
        {
            parent = StructSimple.Default
            , f100 = null
            , f101 = true
            , f102 = null
            , f103 = null
            , f104 = Byte.MaxValue
            , f105 = null
            , f106 = null
            , f107 = (char)'!'
            , f108 = null
            , f109 = null
            , f110 = (char)0x0444
            , f111 = null
            , f112 = null
            , f113 = SByte.MaxValue
            , f114 = null
            , f115 = null
            , f116 = Byte.MaxValue
            , f117 = null
            , f118 = null
            , f119 = Int16.MaxValue
            , f120 = null
            , f121 = null
            , f122 = UInt16.MaxValue
            , f123 = null
            , f124 = null
            , f125 = Int32.MaxValue
            , f126 = null
            , f127 = null
            , f128 = UInt32.MaxValue
            , f129 = null
            , f130 = null
            , f131 = Int64.MaxValue
            , f132 = null
            , f133 = null
            , f134 = UInt64.MaxValue
            , f135 = null
            , f136 = null
            , f137 = (float)123.456F
            , f138 = null
            , f139 = null
            , f140 = (double)-123.456e+123D
            , f141 = null
            , f142 = null
            , f143 = (decimal)123456.123456M
            , f144 = null
            , f145 = null
            , f146 = "Initial string!"
            , f147 = null
            , f148 = null
            , f149 = DateTime.UtcNow
            , f150 = null
            , f151 = null
            , f152 = Guid.Parse("123e4567-e89b-12d3-a456-426655440000")
            , f153 = null
            , f154 = null
            , f155 = null
            , f156 = null
            , f157 = null
            , f158 = null
            , f159 = null
            , f160 = null
            , f161 = null
            , f162 = null
            , f163 = null
            , f164 = null
            , f165 = null
        };

        public StructOptional(StructSimple parent, bool? f100, bool? f101, bool? f102, byte? f103, byte? f104, byte? f105, char? f106, char? f107, char? f108, char? f109, char? f110, char? f111, sbyte? f112, sbyte? f113, sbyte? f114, byte? f115, byte? f116, byte? f117, short? f118, short? f119, short? f120, ushort? f121, ushort? f122, ushort? f123, int? f124, int? f125, int? f126, uint? f127, uint? f128, uint? f129, long? f130, long? f131, long? f132, ulong? f133, ulong? f134, ulong? f135, float? f136, float? f137, float? f138, double? f139, double? f140, double? f141, decimal? f142, decimal? f143, decimal? f144, string f145, string f146, string f147, DateTime? f148, DateTime? f149, DateTime? f150, Guid? f151, Guid? f152, Guid? f153, proto.OrderSide? f154, proto.OrderSide? f155, proto.OrderType? f156, proto.OrderType? f157, proto.Order? f158, proto.Order? f159, proto.Balance? f160, proto.Balance? f161, proto.State? f162, proto.State? f163, proto.Account? f164, proto.Account? f165)
        {
            this.parent = parent;
            this.f100 = f100;
            this.f101 = f101;
            this.f102 = f102;
            this.f103 = f103;
            this.f104 = f104;
            this.f105 = f105;
            this.f106 = f106;
            this.f107 = f107;
            this.f108 = f108;
            this.f109 = f109;
            this.f110 = f110;
            this.f111 = f111;
            this.f112 = f112;
            this.f113 = f113;
            this.f114 = f114;
            this.f115 = f115;
            this.f116 = f116;
            this.f117 = f117;
            this.f118 = f118;
            this.f119 = f119;
            this.f120 = f120;
            this.f121 = f121;
            this.f122 = f122;
            this.f123 = f123;
            this.f124 = f124;
            this.f125 = f125;
            this.f126 = f126;
            this.f127 = f127;
            this.f128 = f128;
            this.f129 = f129;
            this.f130 = f130;
            this.f131 = f131;
            this.f132 = f132;
            this.f133 = f133;
            this.f134 = f134;
            this.f135 = f135;
            this.f136 = f136;
            this.f137 = f137;
            this.f138 = f138;
            this.f139 = f139;
            this.f140 = f140;
            this.f141 = f141;
            this.f142 = f142;
            this.f143 = f143;
            this.f144 = f144;
            this.f145 = f145;
            this.f146 = f146;
            this.f147 = f147;
            this.f148 = f148;
            this.f149 = f149;
            this.f150 = f150;
            this.f151 = f151;
            this.f152 = f152;
            this.f153 = f153;
            this.f154 = f154;
            this.f155 = f155;
            this.f156 = f156;
            this.f157 = f157;
            this.f158 = f158;
            this.f159 = f159;
            this.f160 = f160;
            this.f161 = f161;
            this.f162 = f162;
            this.f163 = f163;
            this.f164 = f164;
            this.f165 = f165;
        }

        public StructOptional Clone()
        {
            // Serialize the struct to the FBE stream
            var writer = new com.chronoxor.test.FBE.StructOptionalModel();
            writer.Serialize(this);

            // Deserialize the struct from the FBE stream
            var reader = new com.chronoxor.test.FBE.StructOptionalModel();
            reader.Attach(writer.Buffer);
            reader.Deserialize(out var result);
            return result;
        }

        public int CompareTo(object other)
        {
            int result = 0;
            result = parent.CompareTo(other);
            if (result != 0)
                return result;
            return result;
        }

        public int CompareTo(StructOptional other)
        {
            int result = 0;
            result = parent.CompareTo(other);
            if (result != 0)
                return result;
            return result;
        }

        public override bool Equals(object other)
        {
            if (!(other is StructOptional))
                return false;
            if (!parent.Equals(other))
                return false;
            return true;
        }

        public bool Equals(StructOptional other)
        {
            if (!parent.Equals(other))
                return false;
            return true;
        }

        public override int GetHashCode()
        {
            int hash = 17;
            hash = hash * 31 + parent.GetHashCode();
            return hash;
        }

        public static bool operator==(StructOptional lhs, StructOptional rhs) => lhs.Equals(rhs);
        public static bool operator!=(StructOptional lhs, StructOptional rhs) => !(lhs == rhs);

        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("StructOptional(");
            sb.Append(parent.ToString());
            sb.Append(",f100="); if (f100 != null) sb.Append(f100.Value ? "true" : "false"); else sb.Append("null");
            sb.Append(",f101="); if (f101 != null) sb.Append(f101.Value ? "true" : "false"); else sb.Append("null");
            sb.Append(",f102="); if (f102 != null) sb.Append(f102.Value ? "true" : "false"); else sb.Append("null");
            sb.Append(",f103="); if (f103 != null) sb.Append(f103); else sb.Append("null");
            sb.Append(",f104="); if (f104 != null) sb.Append(f104); else sb.Append("null");
            sb.Append(",f105="); if (f105 != null) sb.Append(f105); else sb.Append("null");
            sb.Append(",f106="); if (f106 != null) sb.Append("'").Append(f106).Append("'"); else sb.Append("null");
            sb.Append(",f107="); if (f107 != null) sb.Append("'").Append(f107).Append("'"); else sb.Append("null");
            sb.Append(",f108="); if (f108 != null) sb.Append("'").Append(f108).Append("'"); else sb.Append("null");
            sb.Append(",f109="); if (f109 != null) sb.Append("'").Append(f109).Append("'"); else sb.Append("null");
            sb.Append(",f110="); if (f110 != null) sb.Append("'").Append(f110).Append("'"); else sb.Append("null");
            sb.Append(",f111="); if (f111 != null) sb.Append("'").Append(f111).Append("'"); else sb.Append("null");
            sb.Append(",f112="); if (f112 != null) sb.Append(f112); else sb.Append("null");
            sb.Append(",f113="); if (f113 != null) sb.Append(f113); else sb.Append("null");
            sb.Append(",f114="); if (f114 != null) sb.Append(f114); else sb.Append("null");
            sb.Append(",f115="); if (f115 != null) sb.Append(f115); else sb.Append("null");
            sb.Append(",f116="); if (f116 != null) sb.Append(f116); else sb.Append("null");
            sb.Append(",f117="); if (f117 != null) sb.Append(f117); else sb.Append("null");
            sb.Append(",f118="); if (f118 != null) sb.Append(f118); else sb.Append("null");
            sb.Append(",f119="); if (f119 != null) sb.Append(f119); else sb.Append("null");
            sb.Append(",f120="); if (f120 != null) sb.Append(f120); else sb.Append("null");
            sb.Append(",f121="); if (f121 != null) sb.Append(f121); else sb.Append("null");
            sb.Append(",f122="); if (f122 != null) sb.Append(f122); else sb.Append("null");
            sb.Append(",f123="); if (f123 != null) sb.Append(f123); else sb.Append("null");
            sb.Append(",f124="); if (f124 != null) sb.Append(f124); else sb.Append("null");
            sb.Append(",f125="); if (f125 != null) sb.Append(f125); else sb.Append("null");
            sb.Append(",f126="); if (f126 != null) sb.Append(f126); else sb.Append("null");
            sb.Append(",f127="); if (f127 != null) sb.Append(f127); else sb.Append("null");
            sb.Append(",f128="); if (f128 != null) sb.Append(f128); else sb.Append("null");
            sb.Append(",f129="); if (f129 != null) sb.Append(f129); else sb.Append("null");
            sb.Append(",f130="); if (f130 != null) sb.Append(f130); else sb.Append("null");
            sb.Append(",f131="); if (f131 != null) sb.Append(f131); else sb.Append("null");
            sb.Append(",f132="); if (f132 != null) sb.Append(f132); else sb.Append("null");
            sb.Append(",f133="); if (f133 != null) sb.Append(f133); else sb.Append("null");
            sb.Append(",f134="); if (f134 != null) sb.Append(f134); else sb.Append("null");
            sb.Append(",f135="); if (f135 != null) sb.Append(f135); else sb.Append("null");
            sb.Append(",f136="); if (f136 != null) sb.Append(f136.Value.ToString(CultureInfo.InvariantCulture)); else sb.Append("null");
            sb.Append(",f137="); if (f137 != null) sb.Append(f137.Value.ToString(CultureInfo.InvariantCulture)); else sb.Append("null");
            sb.Append(",f138="); if (f138 != null) sb.Append(f138.Value.ToString(CultureInfo.InvariantCulture)); else sb.Append("null");
            sb.Append(",f139="); if (f139 != null) sb.Append(f139.Value.ToString(CultureInfo.InvariantCulture)); else sb.Append("null");
            sb.Append(",f140="); if (f140 != null) sb.Append(f140.Value.ToString(CultureInfo.InvariantCulture)); else sb.Append("null");
            sb.Append(",f141="); if (f141 != null) sb.Append(f141.Value.ToString(CultureInfo.InvariantCulture)); else sb.Append("null");
            sb.Append(",f142="); if (f142 != null) sb.Append(f142.Value.ToString(CultureInfo.InvariantCulture)); else sb.Append("null");
            sb.Append(",f143="); if (f143 != null) sb.Append(f143.Value.ToString(CultureInfo.InvariantCulture)); else sb.Append("null");
            sb.Append(",f144="); if (f144 != null) sb.Append(f144.Value.ToString(CultureInfo.InvariantCulture)); else sb.Append("null");
            sb.Append(",f145="); if (f145 != null) sb.Append("\"").Append(f145).Append("\""); else sb.Append("null");
            sb.Append(",f146="); if (f146 != null) sb.Append("\"").Append(f146).Append("\""); else sb.Append("null");
            sb.Append(",f147="); if (f147 != null) sb.Append("\"").Append(f147).Append("\""); else sb.Append("null");
            sb.Append(",f148="); if (f148 != null) sb.Append((ulong)((f148.Value.Ticks - 621355968000000000) * 100)); else sb.Append("null");
            sb.Append(",f149="); if (f149 != null) sb.Append((ulong)((f149.Value.Ticks - 621355968000000000) * 100)); else sb.Append("null");
            sb.Append(",f150="); if (f150 != null) sb.Append((ulong)((f150.Value.Ticks - 621355968000000000) * 100)); else sb.Append("null");
            sb.Append(",f151="); if (f151 != null) sb.Append("\"").Append(f151).Append("\""); else sb.Append("null");
            sb.Append(",f152="); if (f152 != null) sb.Append("\"").Append(f152).Append("\""); else sb.Append("null");
            sb.Append(",f153="); if (f153 != null) sb.Append("\"").Append(f153).Append("\""); else sb.Append("null");
            sb.Append(",f154="); if (f154 != null) sb.Append(f154); else sb.Append("null");
            sb.Append(",f155="); if (f155 != null) sb.Append(f155); else sb.Append("null");
            sb.Append(",f156="); if (f156 != null) sb.Append(f156); else sb.Append("null");
            sb.Append(",f157="); if (f157 != null) sb.Append(f157); else sb.Append("null");
            sb.Append(",f158="); if (f158 != null) sb.Append(f158); else sb.Append("null");
            sb.Append(",f159="); if (f159 != null) sb.Append(f159); else sb.Append("null");
            sb.Append(",f160="); if (f160 != null) sb.Append(f160); else sb.Append("null");
            sb.Append(",f161="); if (f161 != null) sb.Append(f161); else sb.Append("null");
            sb.Append(",f162="); if (f162 != null) sb.Append(f162); else sb.Append("null");
            sb.Append(",f163="); if (f163 != null) sb.Append(f163); else sb.Append("null");
            sb.Append(",f164="); if (f164 != null) sb.Append(f164); else sb.Append("null");
            sb.Append(",f165="); if (f165 != null) sb.Append(f165); else sb.Append("null");
            sb.Append(")");
            return sb.ToString();
        }

        public string ToJson()
        {
            var json = com.chronoxor.FBE.Json.ToJson(this);
            var jsonParent = parent.ToJson();
            json = json.Substring(0, json.Length - 1) + "," + jsonParent.Substring(1, jsonParent.Length - 2) + "}";
            return json;
        }

        public static StructOptional FromJson(string json)
        {
            var result = com.chronoxor.FBE.Json.FromJson<StructOptional>(json);
            result.parent = StructSimple.FromJson(json);
            return result;
        }

        public static com.chronoxor.FBE.FieldModelValueType<StructOptional> CreateFieldModel(com.chronoxor.FBE.Buffer buffer, long offset) { return new test.FBE.FieldModelStructOptional(buffer, offset); }
    }

} // namespace com.chronoxor.test

namespace com.chronoxor.test.FBE {

    using global::com.chronoxor.test;

    // Fast Binary Encoding StructOptional field model
    public class FieldModelStructOptional : com.chronoxor.FBE.FieldModelValueType<StructOptional>
    {
        public readonly com.chronoxor.test.FBE.FieldModelStructSimple parent;
        public readonly com.chronoxor.FBE.FieldModelOptionalValueType<bool, com.chronoxor.FBE.FieldModelValueType<bool>> f100;
        public readonly com.chronoxor.FBE.FieldModelOptionalValueType<bool, com.chronoxor.FBE.FieldModelValueType<bool>> f101;
        public readonly com.chronoxor.FBE.FieldModelOptionalValueType<bool, com.chronoxor.FBE.FieldModelValueType<bool>> f102;
        public readonly com.chronoxor.FBE.FieldModelOptionalValueType<byte, com.chronoxor.FBE.FieldModelValueType<byte>> f103;
        public readonly com.chronoxor.FBE.FieldModelOptionalValueType<byte, com.chronoxor.FBE.FieldModelValueType<byte>> f104;
        public readonly com.chronoxor.FBE.FieldModelOptionalValueType<byte, com.chronoxor.FBE.FieldModelValueType<byte>> f105;
        public readonly com.chronoxor.FBE.FieldModelOptionalValueType<char, com.chronoxor.FBE.FieldModelValueType<char>> f106;
        public readonly com.chronoxor.FBE.FieldModelOptionalValueType<char, com.chronoxor.FBE.FieldModelValueType<char>> f107;
        public readonly com.chronoxor.FBE.FieldModelOptionalValueType<char, com.chronoxor.FBE.FieldModelValueType<char>> f108;
        public readonly com.chronoxor.FBE.FieldModelOptionalValueType<char, com.chronoxor.FBE.FieldModelValueType<char>> f109;
        public readonly com.chronoxor.FBE.FieldModelOptionalValueType<char, com.chronoxor.FBE.FieldModelValueType<char>> f110;
        public readonly com.chronoxor.FBE.FieldModelOptionalValueType<char, com.chronoxor.FBE.FieldModelValueType<char>> f111;
        public readonly com.chronoxor.FBE.FieldModelOptionalValueType<sbyte, com.chronoxor.FBE.FieldModelValueType<sbyte>> f112;
        public readonly com.chronoxor.FBE.FieldModelOptionalValueType<sbyte, com.chronoxor.FBE.FieldModelValueType<sbyte>> f113;
        public readonly com.chronoxor.FBE.FieldModelOptionalValueType<sbyte, com.chronoxor.FBE.FieldModelValueType<sbyte>> f114;
        public readonly com.chronoxor.FBE.FieldModelOptionalValueType<byte, com.chronoxor.FBE.FieldModelValueType<byte>> f115;
        public readonly com.chronoxor.FBE.FieldModelOptionalValueType<byte, com.chronoxor.FBE.FieldModelValueType<byte>> f116;
        public readonly com.chronoxor.FBE.FieldModelOptionalValueType<byte, com.chronoxor.FBE.FieldModelValueType<byte>> f117;
        public readonly com.chronoxor.FBE.FieldModelOptionalValueType<short, com.chronoxor.FBE.FieldModelValueType<short>> f118;
        public readonly com.chronoxor.FBE.FieldModelOptionalValueType<short, com.chronoxor.FBE.FieldModelValueType<short>> f119;
        public readonly com.chronoxor.FBE.FieldModelOptionalValueType<short, com.chronoxor.FBE.FieldModelValueType<short>> f120;
        public readonly com.chronoxor.FBE.FieldModelOptionalValueType<ushort, com.chronoxor.FBE.FieldModelValueType<ushort>> f121;
        public readonly com.chronoxor.FBE.FieldModelOptionalValueType<ushort, com.chronoxor.FBE.FieldModelValueType<ushort>> f122;
        public readonly com.chronoxor.FBE.FieldModelOptionalValueType<ushort, com.chronoxor.FBE.FieldModelValueType<ushort>> f123;
        public readonly com.chronoxor.FBE.FieldModelOptionalValueType<int, com.chronoxor.FBE.FieldModelValueType<int>> f124;
        public readonly com.chronoxor.FBE.FieldModelOptionalValueType<int, com.chronoxor.FBE.FieldModelValueType<int>> f125;
        public readonly com.chronoxor.FBE.FieldModelOptionalValueType<int, com.chronoxor.FBE.FieldModelValueType<int>> f126;
        public readonly com.chronoxor.FBE.FieldModelOptionalValueType<uint, com.chronoxor.FBE.FieldModelValueType<uint>> f127;
        public readonly com.chronoxor.FBE.FieldModelOptionalValueType<uint, com.chronoxor.FBE.FieldModelValueType<uint>> f128;
        public readonly com.chronoxor.FBE.FieldModelOptionalValueType<uint, com.chronoxor.FBE.FieldModelValueType<uint>> f129;
        public readonly com.chronoxor.FBE.FieldModelOptionalValueType<long, com.chronoxor.FBE.FieldModelValueType<long>> f130;
        public readonly com.chronoxor.FBE.FieldModelOptionalValueType<long, com.chronoxor.FBE.FieldModelValueType<long>> f131;
        public readonly com.chronoxor.FBE.FieldModelOptionalValueType<long, com.chronoxor.FBE.FieldModelValueType<long>> f132;
        public readonly com.chronoxor.FBE.FieldModelOptionalValueType<ulong, com.chronoxor.FBE.FieldModelValueType<ulong>> f133;
        public readonly com.chronoxor.FBE.FieldModelOptionalValueType<ulong, com.chronoxor.FBE.FieldModelValueType<ulong>> f134;
        public readonly com.chronoxor.FBE.FieldModelOptionalValueType<ulong, com.chronoxor.FBE.FieldModelValueType<ulong>> f135;
        public readonly com.chronoxor.FBE.FieldModelOptionalValueType<float, com.chronoxor.FBE.FieldModelValueType<float>> f136;
        public readonly com.chronoxor.FBE.FieldModelOptionalValueType<float, com.chronoxor.FBE.FieldModelValueType<float>> f137;
        public readonly com.chronoxor.FBE.FieldModelOptionalValueType<float, com.chronoxor.FBE.FieldModelValueType<float>> f138;
        public readonly com.chronoxor.FBE.FieldModelOptionalValueType<double, com.chronoxor.FBE.FieldModelValueType<double>> f139;
        public readonly com.chronoxor.FBE.FieldModelOptionalValueType<double, com.chronoxor.FBE.FieldModelValueType<double>> f140;
        public readonly com.chronoxor.FBE.FieldModelOptionalValueType<double, com.chronoxor.FBE.FieldModelValueType<double>> f141;
        public readonly com.chronoxor.FBE.FieldModelOptionalValueType<decimal, com.chronoxor.FBE.FieldModelValueType<decimal>> f142;
        public readonly com.chronoxor.FBE.FieldModelOptionalValueType<decimal, com.chronoxor.FBE.FieldModelValueType<decimal>> f143;
        public readonly com.chronoxor.FBE.FieldModelOptionalValueType<decimal, com.chronoxor.FBE.FieldModelValueType<decimal>> f144;
        public readonly com.chronoxor.FBE.FieldModelOptionalReferenceType<string, com.chronoxor.FBE.FieldModelReferenceType<string>> f145;
        public readonly com.chronoxor.FBE.FieldModelOptionalReferenceType<string, com.chronoxor.FBE.FieldModelReferenceType<string>> f146;
        public readonly com.chronoxor.FBE.FieldModelOptionalReferenceType<string, com.chronoxor.FBE.FieldModelReferenceType<string>> f147;
        public readonly com.chronoxor.FBE.FieldModelOptionalValueType<DateTime, com.chronoxor.FBE.FieldModelValueType<DateTime>> f148;
        public readonly com.chronoxor.FBE.FieldModelOptionalValueType<DateTime, com.chronoxor.FBE.FieldModelValueType<DateTime>> f149;
        public readonly com.chronoxor.FBE.FieldModelOptionalValueType<DateTime, com.chronoxor.FBE.FieldModelValueType<DateTime>> f150;
        public readonly com.chronoxor.FBE.FieldModelOptionalValueType<Guid, com.chronoxor.FBE.FieldModelValueType<Guid>> f151;
        public readonly com.chronoxor.FBE.FieldModelOptionalValueType<Guid, com.chronoxor.FBE.FieldModelValueType<Guid>> f152;
        public readonly com.chronoxor.FBE.FieldModelOptionalValueType<Guid, com.chronoxor.FBE.FieldModelValueType<Guid>> f153;
        public readonly com.chronoxor.FBE.FieldModelOptionalValueType<proto.OrderSide, com.chronoxor.proto.FBE.FieldModelOrderSide> f154;
        public readonly com.chronoxor.FBE.FieldModelOptionalValueType<proto.OrderSide, com.chronoxor.proto.FBE.FieldModelOrderSide> f155;
        public readonly com.chronoxor.FBE.FieldModelOptionalValueType<proto.OrderType, com.chronoxor.proto.FBE.FieldModelOrderType> f156;
        public readonly com.chronoxor.FBE.FieldModelOptionalValueType<proto.OrderType, com.chronoxor.proto.FBE.FieldModelOrderType> f157;
        public readonly com.chronoxor.FBE.FieldModelOptionalValueType<proto.Order, com.chronoxor.proto.FBE.FieldModelOrder> f158;
        public readonly com.chronoxor.FBE.FieldModelOptionalValueType<proto.Order, com.chronoxor.proto.FBE.FieldModelOrder> f159;
        public readonly com.chronoxor.FBE.FieldModelOptionalValueType<proto.Balance, com.chronoxor.proto.FBE.FieldModelBalance> f160;
        public readonly com.chronoxor.FBE.FieldModelOptionalValueType<proto.Balance, com.chronoxor.proto.FBE.FieldModelBalance> f161;
        public readonly com.chronoxor.FBE.FieldModelOptionalValueType<proto.State, com.chronoxor.proto.FBE.FieldModelState> f162;
        public readonly com.chronoxor.FBE.FieldModelOptionalValueType<proto.State, com.chronoxor.proto.FBE.FieldModelState> f163;
        public readonly com.chronoxor.FBE.FieldModelOptionalValueType<proto.Account, com.chronoxor.proto.FBE.FieldModelAccount> f164;
        public readonly com.chronoxor.FBE.FieldModelOptionalValueType<proto.Account, com.chronoxor.proto.FBE.FieldModelAccount> f165;

        public FieldModelStructOptional(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset)
        {
            parent = new com.chronoxor.test.FBE.FieldModelStructSimple(buffer, 4 + 4);
            f100 = new com.chronoxor.FBE.FieldModelOptionalValueType<bool, com.chronoxor.FBE.FieldModelValueType<bool>>(com.chronoxor.FBE.FieldModelValueType<bool>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.BOOL, buffer, parent.FBEOffset + parent.FBEBody - 4 - 4), buffer, parent.FBEOffset + parent.FBEBody - 4 - 4);
            f101 = new com.chronoxor.FBE.FieldModelOptionalValueType<bool, com.chronoxor.FBE.FieldModelValueType<bool>>(com.chronoxor.FBE.FieldModelValueType<bool>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.BOOL, buffer, f100.FBEOffset + f100.FBESize), buffer, f100.FBEOffset + f100.FBESize);
            f102 = new com.chronoxor.FBE.FieldModelOptionalValueType<bool, com.chronoxor.FBE.FieldModelValueType<bool>>(com.chronoxor.FBE.FieldModelValueType<bool>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.BOOL, buffer, f101.FBEOffset + f101.FBESize), buffer, f101.FBEOffset + f101.FBESize);
            f103 = new com.chronoxor.FBE.FieldModelOptionalValueType<byte, com.chronoxor.FBE.FieldModelValueType<byte>>(com.chronoxor.FBE.FieldModelValueType<byte>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.BYTE, buffer, f102.FBEOffset + f102.FBESize), buffer, f102.FBEOffset + f102.FBESize);
            f104 = new com.chronoxor.FBE.FieldModelOptionalValueType<byte, com.chronoxor.FBE.FieldModelValueType<byte>>(com.chronoxor.FBE.FieldModelValueType<byte>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.BYTE, buffer, f103.FBEOffset + f103.FBESize), buffer, f103.FBEOffset + f103.FBESize);
            f105 = new com.chronoxor.FBE.FieldModelOptionalValueType<byte, com.chronoxor.FBE.FieldModelValueType<byte>>(com.chronoxor.FBE.FieldModelValueType<byte>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.BYTE, buffer, f104.FBEOffset + f104.FBESize), buffer, f104.FBEOffset + f104.FBESize);
            f106 = new com.chronoxor.FBE.FieldModelOptionalValueType<char, com.chronoxor.FBE.FieldModelValueType<char>>(com.chronoxor.FBE.FieldModelValueType<char>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.CHAR, buffer, f105.FBEOffset + f105.FBESize), buffer, f105.FBEOffset + f105.FBESize);
            f107 = new com.chronoxor.FBE.FieldModelOptionalValueType<char, com.chronoxor.FBE.FieldModelValueType<char>>(com.chronoxor.FBE.FieldModelValueType<char>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.CHAR, buffer, f106.FBEOffset + f106.FBESize), buffer, f106.FBEOffset + f106.FBESize);
            f108 = new com.chronoxor.FBE.FieldModelOptionalValueType<char, com.chronoxor.FBE.FieldModelValueType<char>>(com.chronoxor.FBE.FieldModelValueType<char>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.CHAR, buffer, f107.FBEOffset + f107.FBESize), buffer, f107.FBEOffset + f107.FBESize);
            f109 = new com.chronoxor.FBE.FieldModelOptionalValueType<char, com.chronoxor.FBE.FieldModelValueType<char>>(com.chronoxor.FBE.FieldModelValueType<char>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.WCHAR, buffer, f108.FBEOffset + f108.FBESize), buffer, f108.FBEOffset + f108.FBESize);
            f110 = new com.chronoxor.FBE.FieldModelOptionalValueType<char, com.chronoxor.FBE.FieldModelValueType<char>>(com.chronoxor.FBE.FieldModelValueType<char>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.WCHAR, buffer, f109.FBEOffset + f109.FBESize), buffer, f109.FBEOffset + f109.FBESize);
            f111 = new com.chronoxor.FBE.FieldModelOptionalValueType<char, com.chronoxor.FBE.FieldModelValueType<char>>(com.chronoxor.FBE.FieldModelValueType<char>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.WCHAR, buffer, f110.FBEOffset + f110.FBESize), buffer, f110.FBEOffset + f110.FBESize);
            f112 = new com.chronoxor.FBE.FieldModelOptionalValueType<sbyte, com.chronoxor.FBE.FieldModelValueType<sbyte>>(com.chronoxor.FBE.FieldModelValueType<sbyte>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.INT8, buffer, f111.FBEOffset + f111.FBESize), buffer, f111.FBEOffset + f111.FBESize);
            f113 = new com.chronoxor.FBE.FieldModelOptionalValueType<sbyte, com.chronoxor.FBE.FieldModelValueType<sbyte>>(com.chronoxor.FBE.FieldModelValueType<sbyte>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.INT8, buffer, f112.FBEOffset + f112.FBESize), buffer, f112.FBEOffset + f112.FBESize);
            f114 = new com.chronoxor.FBE.FieldModelOptionalValueType<sbyte, com.chronoxor.FBE.FieldModelValueType<sbyte>>(com.chronoxor.FBE.FieldModelValueType<sbyte>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.INT8, buffer, f113.FBEOffset + f113.FBESize), buffer, f113.FBEOffset + f113.FBESize);
            f115 = new com.chronoxor.FBE.FieldModelOptionalValueType<byte, com.chronoxor.FBE.FieldModelValueType<byte>>(com.chronoxor.FBE.FieldModelValueType<byte>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.UINT8, buffer, f114.FBEOffset + f114.FBESize), buffer, f114.FBEOffset + f114.FBESize);
            f116 = new com.chronoxor.FBE.FieldModelOptionalValueType<byte, com.chronoxor.FBE.FieldModelValueType<byte>>(com.chronoxor.FBE.FieldModelValueType<byte>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.UINT8, buffer, f115.FBEOffset + f115.FBESize), buffer, f115.FBEOffset + f115.FBESize);
            f117 = new com.chronoxor.FBE.FieldModelOptionalValueType<byte, com.chronoxor.FBE.FieldModelValueType<byte>>(com.chronoxor.FBE.FieldModelValueType<byte>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.UINT8, buffer, f116.FBEOffset + f116.FBESize), buffer, f116.FBEOffset + f116.FBESize);
            f118 = new com.chronoxor.FBE.FieldModelOptionalValueType<short, com.chronoxor.FBE.FieldModelValueType<short>>(com.chronoxor.FBE.FieldModelValueType<short>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.INT16, buffer, f117.FBEOffset + f117.FBESize), buffer, f117.FBEOffset + f117.FBESize);
            f119 = new com.chronoxor.FBE.FieldModelOptionalValueType<short, com.chronoxor.FBE.FieldModelValueType<short>>(com.chronoxor.FBE.FieldModelValueType<short>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.INT16, buffer, f118.FBEOffset + f118.FBESize), buffer, f118.FBEOffset + f118.FBESize);
            f120 = new com.chronoxor.FBE.FieldModelOptionalValueType<short, com.chronoxor.FBE.FieldModelValueType<short>>(com.chronoxor.FBE.FieldModelValueType<short>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.INT16, buffer, f119.FBEOffset + f119.FBESize), buffer, f119.FBEOffset + f119.FBESize);
            f121 = new com.chronoxor.FBE.FieldModelOptionalValueType<ushort, com.chronoxor.FBE.FieldModelValueType<ushort>>(com.chronoxor.FBE.FieldModelValueType<ushort>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.UINT16, buffer, f120.FBEOffset + f120.FBESize), buffer, f120.FBEOffset + f120.FBESize);
            f122 = new com.chronoxor.FBE.FieldModelOptionalValueType<ushort, com.chronoxor.FBE.FieldModelValueType<ushort>>(com.chronoxor.FBE.FieldModelValueType<ushort>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.UINT16, buffer, f121.FBEOffset + f121.FBESize), buffer, f121.FBEOffset + f121.FBESize);
            f123 = new com.chronoxor.FBE.FieldModelOptionalValueType<ushort, com.chronoxor.FBE.FieldModelValueType<ushort>>(com.chronoxor.FBE.FieldModelValueType<ushort>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.UINT16, buffer, f122.FBEOffset + f122.FBESize), buffer, f122.FBEOffset + f122.FBESize);
            f124 = new com.chronoxor.FBE.FieldModelOptionalValueType<int, com.chronoxor.FBE.FieldModelValueType<int>>(com.chronoxor.FBE.FieldModelValueType<int>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.INT32, buffer, f123.FBEOffset + f123.FBESize), buffer, f123.FBEOffset + f123.FBESize);
            f125 = new com.chronoxor.FBE.FieldModelOptionalValueType<int, com.chronoxor.FBE.FieldModelValueType<int>>(com.chronoxor.FBE.FieldModelValueType<int>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.INT32, buffer, f124.FBEOffset + f124.FBESize), buffer, f124.FBEOffset + f124.FBESize);
            f126 = new com.chronoxor.FBE.FieldModelOptionalValueType<int, com.chronoxor.FBE.FieldModelValueType<int>>(com.chronoxor.FBE.FieldModelValueType<int>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.INT32, buffer, f125.FBEOffset + f125.FBESize), buffer, f125.FBEOffset + f125.FBESize);
            f127 = new com.chronoxor.FBE.FieldModelOptionalValueType<uint, com.chronoxor.FBE.FieldModelValueType<uint>>(com.chronoxor.FBE.FieldModelValueType<uint>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.UINT32, buffer, f126.FBEOffset + f126.FBESize), buffer, f126.FBEOffset + f126.FBESize);
            f128 = new com.chronoxor.FBE.FieldModelOptionalValueType<uint, com.chronoxor.FBE.FieldModelValueType<uint>>(com.chronoxor.FBE.FieldModelValueType<uint>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.UINT32, buffer, f127.FBEOffset + f127.FBESize), buffer, f127.FBEOffset + f127.FBESize);
            f129 = new com.chronoxor.FBE.FieldModelOptionalValueType<uint, com.chronoxor.FBE.FieldModelValueType<uint>>(com.chronoxor.FBE.FieldModelValueType<uint>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.UINT32, buffer, f128.FBEOffset + f128.FBESize), buffer, f128.FBEOffset + f128.FBESize);
            f130 = new com.chronoxor.FBE.FieldModelOptionalValueType<long, com.chronoxor.FBE.FieldModelValueType<long>>(com.chronoxor.FBE.FieldModelValueType<long>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.INT64, buffer, f129.FBEOffset + f129.FBESize), buffer, f129.FBEOffset + f129.FBESize);
            f131 = new com.chronoxor.FBE.FieldModelOptionalValueType<long, com.chronoxor.FBE.FieldModelValueType<long>>(com.chronoxor.FBE.FieldModelValueType<long>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.INT64, buffer, f130.FBEOffset + f130.FBESize), buffer, f130.FBEOffset + f130.FBESize);
            f132 = new com.chronoxor.FBE.FieldModelOptionalValueType<long, com.chronoxor.FBE.FieldModelValueType<long>>(com.chronoxor.FBE.FieldModelValueType<long>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.INT64, buffer, f131.FBEOffset + f131.FBESize), buffer, f131.FBEOffset + f131.FBESize);
            f133 = new com.chronoxor.FBE.FieldModelOptionalValueType<ulong, com.chronoxor.FBE.FieldModelValueType<ulong>>(com.chronoxor.FBE.FieldModelValueType<ulong>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.UINT64, buffer, f132.FBEOffset + f132.FBESize), buffer, f132.FBEOffset + f132.FBESize);
            f134 = new com.chronoxor.FBE.FieldModelOptionalValueType<ulong, com.chronoxor.FBE.FieldModelValueType<ulong>>(com.chronoxor.FBE.FieldModelValueType<ulong>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.UINT64, buffer, f133.FBEOffset + f133.FBESize), buffer, f133.FBEOffset + f133.FBESize);
            f135 = new com.chronoxor.FBE.FieldModelOptionalValueType<ulong, com.chronoxor.FBE.FieldModelValueType<ulong>>(com.chronoxor.FBE.FieldModelValueType<ulong>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.UINT64, buffer, f134.FBEOffset + f134.FBESize), buffer, f134.FBEOffset + f134.FBESize);
            f136 = new com.chronoxor.FBE.FieldModelOptionalValueType<float, com.chronoxor.FBE.FieldModelValueType<float>>(com.chronoxor.FBE.FieldModelValueType<float>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.FLOAT, buffer, f135.FBEOffset + f135.FBESize), buffer, f135.FBEOffset + f135.FBESize);
            f137 = new com.chronoxor.FBE.FieldModelOptionalValueType<float, com.chronoxor.FBE.FieldModelValueType<float>>(com.chronoxor.FBE.FieldModelValueType<float>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.FLOAT, buffer, f136.FBEOffset + f136.FBESize), buffer, f136.FBEOffset + f136.FBESize);
            f138 = new com.chronoxor.FBE.FieldModelOptionalValueType<float, com.chronoxor.FBE.FieldModelValueType<float>>(com.chronoxor.FBE.FieldModelValueType<float>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.FLOAT, buffer, f137.FBEOffset + f137.FBESize), buffer, f137.FBEOffset + f137.FBESize);
            f139 = new com.chronoxor.FBE.FieldModelOptionalValueType<double, com.chronoxor.FBE.FieldModelValueType<double>>(com.chronoxor.FBE.FieldModelValueType<double>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.DOUBLE, buffer, f138.FBEOffset + f138.FBESize), buffer, f138.FBEOffset + f138.FBESize);
            f140 = new com.chronoxor.FBE.FieldModelOptionalValueType<double, com.chronoxor.FBE.FieldModelValueType<double>>(com.chronoxor.FBE.FieldModelValueType<double>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.DOUBLE, buffer, f139.FBEOffset + f139.FBESize), buffer, f139.FBEOffset + f139.FBESize);
            f141 = new com.chronoxor.FBE.FieldModelOptionalValueType<double, com.chronoxor.FBE.FieldModelValueType<double>>(com.chronoxor.FBE.FieldModelValueType<double>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.DOUBLE, buffer, f140.FBEOffset + f140.FBESize), buffer, f140.FBEOffset + f140.FBESize);
            f142 = new com.chronoxor.FBE.FieldModelOptionalValueType<decimal, com.chronoxor.FBE.FieldModelValueType<decimal>>(com.chronoxor.FBE.FieldModelValueType<decimal>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.DECIMAL, buffer, f141.FBEOffset + f141.FBESize), buffer, f141.FBEOffset + f141.FBESize);
            f143 = new com.chronoxor.FBE.FieldModelOptionalValueType<decimal, com.chronoxor.FBE.FieldModelValueType<decimal>>(com.chronoxor.FBE.FieldModelValueType<decimal>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.DECIMAL, buffer, f142.FBEOffset + f142.FBESize), buffer, f142.FBEOffset + f142.FBESize);
            f144 = new com.chronoxor.FBE.FieldModelOptionalValueType<decimal, com.chronoxor.FBE.FieldModelValueType<decimal>>(com.chronoxor.FBE.FieldModelValueType<decimal>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.DECIMAL, buffer, f143.FBEOffset + f143.FBESize), buffer, f143.FBEOffset + f143.FBESize);
            f145 = new com.chronoxor.FBE.FieldModelOptionalReferenceType<string, com.chronoxor.FBE.FieldModelReferenceType<string>>(com.chronoxor.FBE.FieldModelReferenceType<string>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.STRING, buffer, f144.FBEOffset + f144.FBESize), buffer, f144.FBEOffset + f144.FBESize);
            f146 = new com.chronoxor.FBE.FieldModelOptionalReferenceType<string, com.chronoxor.FBE.FieldModelReferenceType<string>>(com.chronoxor.FBE.FieldModelReferenceType<string>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.STRING, buffer, f145.FBEOffset + f145.FBESize), buffer, f145.FBEOffset + f145.FBESize);
            f147 = new com.chronoxor.FBE.FieldModelOptionalReferenceType<string, com.chronoxor.FBE.FieldModelReferenceType<string>>(com.chronoxor.FBE.FieldModelReferenceType<string>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.STRING, buffer, f146.FBEOffset + f146.FBESize), buffer, f146.FBEOffset + f146.FBESize);
            f148 = new com.chronoxor.FBE.FieldModelOptionalValueType<DateTime, com.chronoxor.FBE.FieldModelValueType<DateTime>>(com.chronoxor.FBE.FieldModelValueType<DateTime>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.TIMESTAMP, buffer, f147.FBEOffset + f147.FBESize), buffer, f147.FBEOffset + f147.FBESize);
            f149 = new com.chronoxor.FBE.FieldModelOptionalValueType<DateTime, com.chronoxor.FBE.FieldModelValueType<DateTime>>(com.chronoxor.FBE.FieldModelValueType<DateTime>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.TIMESTAMP, buffer, f148.FBEOffset + f148.FBESize), buffer, f148.FBEOffset + f148.FBESize);
            f150 = new com.chronoxor.FBE.FieldModelOptionalValueType<DateTime, com.chronoxor.FBE.FieldModelValueType<DateTime>>(com.chronoxor.FBE.FieldModelValueType<DateTime>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.TIMESTAMP, buffer, f149.FBEOffset + f149.FBESize), buffer, f149.FBEOffset + f149.FBESize);
            f151 = new com.chronoxor.FBE.FieldModelOptionalValueType<Guid, com.chronoxor.FBE.FieldModelValueType<Guid>>(com.chronoxor.FBE.FieldModelValueType<Guid>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.UUID, buffer, f150.FBEOffset + f150.FBESize), buffer, f150.FBEOffset + f150.FBESize);
            f152 = new com.chronoxor.FBE.FieldModelOptionalValueType<Guid, com.chronoxor.FBE.FieldModelValueType<Guid>>(com.chronoxor.FBE.FieldModelValueType<Guid>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.UUID, buffer, f151.FBEOffset + f151.FBESize), buffer, f151.FBEOffset + f151.FBESize);
            f153 = new com.chronoxor.FBE.FieldModelOptionalValueType<Guid, com.chronoxor.FBE.FieldModelValueType<Guid>>(com.chronoxor.FBE.FieldModelValueType<Guid>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.UUID, buffer, f152.FBEOffset + f152.FBESize), buffer, f152.FBEOffset + f152.FBESize);
            f154 = new com.chronoxor.FBE.FieldModelOptionalValueType<proto.OrderSide, com.chronoxor.proto.FBE.FieldModelOrderSide>(new com.chronoxor.proto.FBE.FieldModelOrderSide(buffer, f153.FBEOffset + f153.FBESize), buffer, f153.FBEOffset + f153.FBESize);
            f155 = new com.chronoxor.FBE.FieldModelOptionalValueType<proto.OrderSide, com.chronoxor.proto.FBE.FieldModelOrderSide>(new com.chronoxor.proto.FBE.FieldModelOrderSide(buffer, f154.FBEOffset + f154.FBESize), buffer, f154.FBEOffset + f154.FBESize);
            f156 = new com.chronoxor.FBE.FieldModelOptionalValueType<proto.OrderType, com.chronoxor.proto.FBE.FieldModelOrderType>(new com.chronoxor.proto.FBE.FieldModelOrderType(buffer, f155.FBEOffset + f155.FBESize), buffer, f155.FBEOffset + f155.FBESize);
            f157 = new com.chronoxor.FBE.FieldModelOptionalValueType<proto.OrderType, com.chronoxor.proto.FBE.FieldModelOrderType>(new com.chronoxor.proto.FBE.FieldModelOrderType(buffer, f156.FBEOffset + f156.FBESize), buffer, f156.FBEOffset + f156.FBESize);
            f158 = new com.chronoxor.FBE.FieldModelOptionalValueType<proto.Order, com.chronoxor.proto.FBE.FieldModelOrder>(new com.chronoxor.proto.FBE.FieldModelOrder(buffer, f157.FBEOffset + f157.FBESize), buffer, f157.FBEOffset + f157.FBESize);
            f159 = new com.chronoxor.FBE.FieldModelOptionalValueType<proto.Order, com.chronoxor.proto.FBE.FieldModelOrder>(new com.chronoxor.proto.FBE.FieldModelOrder(buffer, f158.FBEOffset + f158.FBESize), buffer, f158.FBEOffset + f158.FBESize);
            f160 = new com.chronoxor.FBE.FieldModelOptionalValueType<proto.Balance, com.chronoxor.proto.FBE.FieldModelBalance>(new com.chronoxor.proto.FBE.FieldModelBalance(buffer, f159.FBEOffset + f159.FBESize), buffer, f159.FBEOffset + f159.FBESize);
            f161 = new com.chronoxor.FBE.FieldModelOptionalValueType<proto.Balance, com.chronoxor.proto.FBE.FieldModelBalance>(new com.chronoxor.proto.FBE.FieldModelBalance(buffer, f160.FBEOffset + f160.FBESize), buffer, f160.FBEOffset + f160.FBESize);
            f162 = new com.chronoxor.FBE.FieldModelOptionalValueType<proto.State, com.chronoxor.proto.FBE.FieldModelState>(new com.chronoxor.proto.FBE.FieldModelState(buffer, f161.FBEOffset + f161.FBESize), buffer, f161.FBEOffset + f161.FBESize);
            f163 = new com.chronoxor.FBE.FieldModelOptionalValueType<proto.State, com.chronoxor.proto.FBE.FieldModelState>(new com.chronoxor.proto.FBE.FieldModelState(buffer, f162.FBEOffset + f162.FBESize), buffer, f162.FBEOffset + f162.FBESize);
            f164 = new com.chronoxor.FBE.FieldModelOptionalValueType<proto.Account, com.chronoxor.proto.FBE.FieldModelAccount>(new com.chronoxor.proto.FBE.FieldModelAccount(buffer, f163.FBEOffset + f163.FBESize), buffer, f163.FBEOffset + f163.FBESize);
            f165 = new com.chronoxor.FBE.FieldModelOptionalValueType<proto.Account, com.chronoxor.proto.FBE.FieldModelAccount>(new com.chronoxor.proto.FBE.FieldModelAccount(buffer, f164.FBEOffset + f164.FBESize), buffer, f164.FBEOffset + f164.FBESize);
        }

        // Get the field size
        public override long FBESize => 4;
        // Get the field body size
        public long FBEBody
        {
            get
            {
                long fbeResult = 4 + 4
                    + parent.FBEBody - 4 - 4
                    + f100.FBESize
                    + f101.FBESize
                    + f102.FBESize
                    + f103.FBESize
                    + f104.FBESize
                    + f105.FBESize
                    + f106.FBESize
                    + f107.FBESize
                    + f108.FBESize
                    + f109.FBESize
                    + f110.FBESize
                    + f111.FBESize
                    + f112.FBESize
                    + f113.FBESize
                    + f114.FBESize
                    + f115.FBESize
                    + f116.FBESize
                    + f117.FBESize
                    + f118.FBESize
                    + f119.FBESize
                    + f120.FBESize
                    + f121.FBESize
                    + f122.FBESize
                    + f123.FBESize
                    + f124.FBESize
                    + f125.FBESize
                    + f126.FBESize
                    + f127.FBESize
                    + f128.FBESize
                    + f129.FBESize
                    + f130.FBESize
                    + f131.FBESize
                    + f132.FBESize
                    + f133.FBESize
                    + f134.FBESize
                    + f135.FBESize
                    + f136.FBESize
                    + f137.FBESize
                    + f138.FBESize
                    + f139.FBESize
                    + f140.FBESize
                    + f141.FBESize
                    + f142.FBESize
                    + f143.FBESize
                    + f144.FBESize
                    + f145.FBESize
                    + f146.FBESize
                    + f147.FBESize
                    + f148.FBESize
                    + f149.FBESize
                    + f150.FBESize
                    + f151.FBESize
                    + f152.FBESize
                    + f153.FBESize
                    + f154.FBESize
                    + f155.FBESize
                    + f156.FBESize
                    + f157.FBESize
                    + f158.FBESize
                    + f159.FBESize
                    + f160.FBESize
                    + f161.FBESize
                    + f162.FBESize
                    + f163.FBESize
                    + f164.FBESize
                    + f165.FBESize
                    ;
                return fbeResult;
            }
        }
        // Get the field extra size
        public override long FBEExtra
        {
            get
            {
                if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                    return 0;

                uint fbeStructOffset = ReadUInt32(FBEOffset);
                if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4) > _buffer.Size))
                    return 0;

                _buffer.Shift(fbeStructOffset);

                long fbeResult = FBEBody
                    + parent.FBEExtra
                    + f100.FBEExtra
                    + f101.FBEExtra
                    + f102.FBEExtra
                    + f103.FBEExtra
                    + f104.FBEExtra
                    + f105.FBEExtra
                    + f106.FBEExtra
                    + f107.FBEExtra
                    + f108.FBEExtra
                    + f109.FBEExtra
                    + f110.FBEExtra
                    + f111.FBEExtra
                    + f112.FBEExtra
                    + f113.FBEExtra
                    + f114.FBEExtra
                    + f115.FBEExtra
                    + f116.FBEExtra
                    + f117.FBEExtra
                    + f118.FBEExtra
                    + f119.FBEExtra
                    + f120.FBEExtra
                    + f121.FBEExtra
                    + f122.FBEExtra
                    + f123.FBEExtra
                    + f124.FBEExtra
                    + f125.FBEExtra
                    + f126.FBEExtra
                    + f127.FBEExtra
                    + f128.FBEExtra
                    + f129.FBEExtra
                    + f130.FBEExtra
                    + f131.FBEExtra
                    + f132.FBEExtra
                    + f133.FBEExtra
                    + f134.FBEExtra
                    + f135.FBEExtra
                    + f136.FBEExtra
                    + f137.FBEExtra
                    + f138.FBEExtra
                    + f139.FBEExtra
                    + f140.FBEExtra
                    + f141.FBEExtra
                    + f142.FBEExtra
                    + f143.FBEExtra
                    + f144.FBEExtra
                    + f145.FBEExtra
                    + f146.FBEExtra
                    + f147.FBEExtra
                    + f148.FBEExtra
                    + f149.FBEExtra
                    + f150.FBEExtra
                    + f151.FBEExtra
                    + f152.FBEExtra
                    + f153.FBEExtra
                    + f154.FBEExtra
                    + f155.FBEExtra
                    + f156.FBEExtra
                    + f157.FBEExtra
                    + f158.FBEExtra
                    + f159.FBEExtra
                    + f160.FBEExtra
                    + f161.FBEExtra
                    + f162.FBEExtra
                    + f163.FBEExtra
                    + f164.FBEExtra
                    + f165.FBEExtra
                    ;

                _buffer.Unshift(fbeStructOffset);

                return fbeResult;
            }
        }
        // Get the field type
        public const long FBETypeConst = 111;
        public long FBEType => FBETypeConst;

        // Clone the field model
        public override com.chronoxor.FBE.FieldModelValueType<StructOptional> Clone() { return new FieldModelStructOptional(_buffer, _offset); }

        // Check if the struct value is valid
        public override bool Verify() { return Verify(true); }
        public bool Verify(bool fbeVerifyType)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return true;

            uint fbeStructOffset = ReadUInt32(FBEOffset);
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
                return false;

            uint fbeStructSize = ReadUInt32(fbeStructOffset);
            if (fbeStructSize < (4 + 4))
                return false;

            uint fbeStructType = ReadUInt32(fbeStructOffset + 4);
            if (fbeVerifyType && (fbeStructType != FBEType))
                return false;

            _buffer.Shift(fbeStructOffset);
            bool fbeResult = VerifyFields(fbeStructSize);
            _buffer.Unshift(fbeStructOffset);
            return fbeResult;
        }

        // Check if the struct fields are valid
        public bool VerifyFields(long fbeStructSize)
        {
            long fbeCurrentSize = 4 + 4;

            if ((fbeCurrentSize + parent.FBEBody - 4 - 4) > fbeStructSize)
                return true;
            if (!parent.VerifyFields(fbeStructSize))
                return false;
            fbeCurrentSize += parent.FBEBody - 4 - 4;

            if ((fbeCurrentSize + f100.FBESize) > fbeStructSize)
                return true;
            if (!f100.Verify())
                return false;
            fbeCurrentSize += f100.FBESize;

            if ((fbeCurrentSize + f101.FBESize) > fbeStructSize)
                return true;
            if (!f101.Verify())
                return false;
            fbeCurrentSize += f101.FBESize;

            if ((fbeCurrentSize + f102.FBESize) > fbeStructSize)
                return true;
            if (!f102.Verify())
                return false;
            fbeCurrentSize += f102.FBESize;

            if ((fbeCurrentSize + f103.FBESize) > fbeStructSize)
                return true;
            if (!f103.Verify())
                return false;
            fbeCurrentSize += f103.FBESize;

            if ((fbeCurrentSize + f104.FBESize) > fbeStructSize)
                return true;
            if (!f104.Verify())
                return false;
            fbeCurrentSize += f104.FBESize;

            if ((fbeCurrentSize + f105.FBESize) > fbeStructSize)
                return true;
            if (!f105.Verify())
                return false;
            fbeCurrentSize += f105.FBESize;

            if ((fbeCurrentSize + f106.FBESize) > fbeStructSize)
                return true;
            if (!f106.Verify())
                return false;
            fbeCurrentSize += f106.FBESize;

            if ((fbeCurrentSize + f107.FBESize) > fbeStructSize)
                return true;
            if (!f107.Verify())
                return false;
            fbeCurrentSize += f107.FBESize;

            if ((fbeCurrentSize + f108.FBESize) > fbeStructSize)
                return true;
            if (!f108.Verify())
                return false;
            fbeCurrentSize += f108.FBESize;

            if ((fbeCurrentSize + f109.FBESize) > fbeStructSize)
                return true;
            if (!f109.Verify())
                return false;
            fbeCurrentSize += f109.FBESize;

            if ((fbeCurrentSize + f110.FBESize) > fbeStructSize)
                return true;
            if (!f110.Verify())
                return false;
            fbeCurrentSize += f110.FBESize;

            if ((fbeCurrentSize + f111.FBESize) > fbeStructSize)
                return true;
            if (!f111.Verify())
                return false;
            fbeCurrentSize += f111.FBESize;

            if ((fbeCurrentSize + f112.FBESize) > fbeStructSize)
                return true;
            if (!f112.Verify())
                return false;
            fbeCurrentSize += f112.FBESize;

            if ((fbeCurrentSize + f113.FBESize) > fbeStructSize)
                return true;
            if (!f113.Verify())
                return false;
            fbeCurrentSize += f113.FBESize;

            if ((fbeCurrentSize + f114.FBESize) > fbeStructSize)
                return true;
            if (!f114.Verify())
                return false;
            fbeCurrentSize += f114.FBESize;

            if ((fbeCurrentSize + f115.FBESize) > fbeStructSize)
                return true;
            if (!f115.Verify())
                return false;
            fbeCurrentSize += f115.FBESize;

            if ((fbeCurrentSize + f116.FBESize) > fbeStructSize)
                return true;
            if (!f116.Verify())
                return false;
            fbeCurrentSize += f116.FBESize;

            if ((fbeCurrentSize + f117.FBESize) > fbeStructSize)
                return true;
            if (!f117.Verify())
                return false;
            fbeCurrentSize += f117.FBESize;

            if ((fbeCurrentSize + f118.FBESize) > fbeStructSize)
                return true;
            if (!f118.Verify())
                return false;
            fbeCurrentSize += f118.FBESize;

            if ((fbeCurrentSize + f119.FBESize) > fbeStructSize)
                return true;
            if (!f119.Verify())
                return false;
            fbeCurrentSize += f119.FBESize;

            if ((fbeCurrentSize + f120.FBESize) > fbeStructSize)
                return true;
            if (!f120.Verify())
                return false;
            fbeCurrentSize += f120.FBESize;

            if ((fbeCurrentSize + f121.FBESize) > fbeStructSize)
                return true;
            if (!f121.Verify())
                return false;
            fbeCurrentSize += f121.FBESize;

            if ((fbeCurrentSize + f122.FBESize) > fbeStructSize)
                return true;
            if (!f122.Verify())
                return false;
            fbeCurrentSize += f122.FBESize;

            if ((fbeCurrentSize + f123.FBESize) > fbeStructSize)
                return true;
            if (!f123.Verify())
                return false;
            fbeCurrentSize += f123.FBESize;

            if ((fbeCurrentSize + f124.FBESize) > fbeStructSize)
                return true;
            if (!f124.Verify())
                return false;
            fbeCurrentSize += f124.FBESize;

            if ((fbeCurrentSize + f125.FBESize) > fbeStructSize)
                return true;
            if (!f125.Verify())
                return false;
            fbeCurrentSize += f125.FBESize;

            if ((fbeCurrentSize + f126.FBESize) > fbeStructSize)
                return true;
            if (!f126.Verify())
                return false;
            fbeCurrentSize += f126.FBESize;

            if ((fbeCurrentSize + f127.FBESize) > fbeStructSize)
                return true;
            if (!f127.Verify())
                return false;
            fbeCurrentSize += f127.FBESize;

            if ((fbeCurrentSize + f128.FBESize) > fbeStructSize)
                return true;
            if (!f128.Verify())
                return false;
            fbeCurrentSize += f128.FBESize;

            if ((fbeCurrentSize + f129.FBESize) > fbeStructSize)
                return true;
            if (!f129.Verify())
                return false;
            fbeCurrentSize += f129.FBESize;

            if ((fbeCurrentSize + f130.FBESize) > fbeStructSize)
                return true;
            if (!f130.Verify())
                return false;
            fbeCurrentSize += f130.FBESize;

            if ((fbeCurrentSize + f131.FBESize) > fbeStructSize)
                return true;
            if (!f131.Verify())
                return false;
            fbeCurrentSize += f131.FBESize;

            if ((fbeCurrentSize + f132.FBESize) > fbeStructSize)
                return true;
            if (!f132.Verify())
                return false;
            fbeCurrentSize += f132.FBESize;

            if ((fbeCurrentSize + f133.FBESize) > fbeStructSize)
                return true;
            if (!f133.Verify())
                return false;
            fbeCurrentSize += f133.FBESize;

            if ((fbeCurrentSize + f134.FBESize) > fbeStructSize)
                return true;
            if (!f134.Verify())
                return false;
            fbeCurrentSize += f134.FBESize;

            if ((fbeCurrentSize + f135.FBESize) > fbeStructSize)
                return true;
            if (!f135.Verify())
                return false;
            fbeCurrentSize += f135.FBESize;

            if ((fbeCurrentSize + f136.FBESize) > fbeStructSize)
                return true;
            if (!f136.Verify())
                return false;
            fbeCurrentSize += f136.FBESize;

            if ((fbeCurrentSize + f137.FBESize) > fbeStructSize)
                return true;
            if (!f137.Verify())
                return false;
            fbeCurrentSize += f137.FBESize;

            if ((fbeCurrentSize + f138.FBESize) > fbeStructSize)
                return true;
            if (!f138.Verify())
                return false;
            fbeCurrentSize += f138.FBESize;

            if ((fbeCurrentSize + f139.FBESize) > fbeStructSize)
                return true;
            if (!f139.Verify())
                return false;
            fbeCurrentSize += f139.FBESize;

            if ((fbeCurrentSize + f140.FBESize) > fbeStructSize)
                return true;
            if (!f140.Verify())
                return false;
            fbeCurrentSize += f140.FBESize;

            if ((fbeCurrentSize + f141.FBESize) > fbeStructSize)
                return true;
            if (!f141.Verify())
                return false;
            fbeCurrentSize += f141.FBESize;

            if ((fbeCurrentSize + f142.FBESize) > fbeStructSize)
                return true;
            if (!f142.Verify())
                return false;
            fbeCurrentSize += f142.FBESize;

            if ((fbeCurrentSize + f143.FBESize) > fbeStructSize)
                return true;
            if (!f143.Verify())
                return false;
            fbeCurrentSize += f143.FBESize;

            if ((fbeCurrentSize + f144.FBESize) > fbeStructSize)
                return true;
            if (!f144.Verify())
                return false;
            fbeCurrentSize += f144.FBESize;

            if ((fbeCurrentSize + f145.FBESize) > fbeStructSize)
                return true;
            if (!f145.Verify())
                return false;
            fbeCurrentSize += f145.FBESize;

            if ((fbeCurrentSize + f146.FBESize) > fbeStructSize)
                return true;
            if (!f146.Verify())
                return false;
            fbeCurrentSize += f146.FBESize;

            if ((fbeCurrentSize + f147.FBESize) > fbeStructSize)
                return true;
            if (!f147.Verify())
                return false;
            fbeCurrentSize += f147.FBESize;

            if ((fbeCurrentSize + f148.FBESize) > fbeStructSize)
                return true;
            if (!f148.Verify())
                return false;
            fbeCurrentSize += f148.FBESize;

            if ((fbeCurrentSize + f149.FBESize) > fbeStructSize)
                return true;
            if (!f149.Verify())
                return false;
            fbeCurrentSize += f149.FBESize;

            if ((fbeCurrentSize + f150.FBESize) > fbeStructSize)
                return true;
            if (!f150.Verify())
                return false;
            fbeCurrentSize += f150.FBESize;

            if ((fbeCurrentSize + f151.FBESize) > fbeStructSize)
                return true;
            if (!f151.Verify())
                return false;
            fbeCurrentSize += f151.FBESize;

            if ((fbeCurrentSize + f152.FBESize) > fbeStructSize)
                return true;
            if (!f152.Verify())
                return false;
            fbeCurrentSize += f152.FBESize;

            if ((fbeCurrentSize + f153.FBESize) > fbeStructSize)
                return true;
            if (!f153.Verify())
                return false;
            fbeCurrentSize += f153.FBESize;

            if ((fbeCurrentSize + f154.FBESize) > fbeStructSize)
                return true;
            if (!f154.Verify())
                return false;
            fbeCurrentSize += f154.FBESize;

            if ((fbeCurrentSize + f155.FBESize) > fbeStructSize)
                return true;
            if (!f155.Verify())
                return false;
            fbeCurrentSize += f155.FBESize;

            if ((fbeCurrentSize + f156.FBESize) > fbeStructSize)
                return true;
            if (!f156.Verify())
                return false;
            fbeCurrentSize += f156.FBESize;

            if ((fbeCurrentSize + f157.FBESize) > fbeStructSize)
                return true;
            if (!f157.Verify())
                return false;
            fbeCurrentSize += f157.FBESize;

            if ((fbeCurrentSize + f158.FBESize) > fbeStructSize)
                return true;
            if (!f158.Verify())
                return false;
            fbeCurrentSize += f158.FBESize;

            if ((fbeCurrentSize + f159.FBESize) > fbeStructSize)
                return true;
            if (!f159.Verify())
                return false;
            fbeCurrentSize += f159.FBESize;

            if ((fbeCurrentSize + f160.FBESize) > fbeStructSize)
                return true;
            if (!f160.Verify())
                return false;
            fbeCurrentSize += f160.FBESize;

            if ((fbeCurrentSize + f161.FBESize) > fbeStructSize)
                return true;
            if (!f161.Verify())
                return false;
            fbeCurrentSize += f161.FBESize;

            if ((fbeCurrentSize + f162.FBESize) > fbeStructSize)
                return true;
            if (!f162.Verify())
                return false;
            fbeCurrentSize += f162.FBESize;

            if ((fbeCurrentSize + f163.FBESize) > fbeStructSize)
                return true;
            if (!f163.Verify())
                return false;
            fbeCurrentSize += f163.FBESize;

            if ((fbeCurrentSize + f164.FBESize) > fbeStructSize)
                return true;
            if (!f164.Verify())
                return false;
            fbeCurrentSize += f164.FBESize;

            if ((fbeCurrentSize + f165.FBESize) > fbeStructSize)
                return true;
            if (!f165.Verify())
                return false;
            fbeCurrentSize += f165.FBESize;

            return true;
        }

        // Get the struct value (begin phase)
        public long GetBegin()
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            uint fbeStructOffset = ReadUInt32(FBEOffset);
            Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + 4 + 4) <= _buffer.Size)), "Model is broken!");
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
                return 0;

            uint fbeStructSize = ReadUInt32(fbeStructOffset);
            Debug.Assert((fbeStructSize >= (4 + 4)), "Model is broken!");
            if (fbeStructSize < (4 + 4))
                return 0;

            _buffer.Shift(fbeStructOffset);
            return fbeStructOffset;
        }

        // Get the struct value (end phase)
        public void GetEnd(long fbeBegin)
        {
            _buffer.Unshift(fbeBegin);
        }

        // Get the struct value
        public override void Get(out StructOptional fbeValue) { Get(out fbeValue, StructOptional.Default); }
        public override void Get(out StructOptional fbeValue, StructOptional defaults)
        {
            long fbeBegin = GetBegin();
            if (fbeBegin == 0)
            {
                fbeValue = defaults;
                return;
            }

            uint fbeStructSize = ReadUInt32(0);
            GetFields(out fbeValue, fbeStructSize);
            GetEnd(fbeBegin);
        }

        // Get the struct fields values
        public void GetFields(out StructOptional fbeValue, long fbeStructSize)
        {
            long fbeCurrentSize = 4 + 4;

            fbeValue = StructOptional.Default;

            if ((fbeCurrentSize + parent.FBEBody - 4 - 4) <= fbeStructSize)
                parent.GetFields(out fbeValue.parent, fbeStructSize);
            fbeCurrentSize += parent.FBEBody - 4 - 4;

            if ((fbeCurrentSize + f100.FBESize) <= fbeStructSize)
                f100.Get(out fbeValue.f100);
            else
                fbeValue.f100 = null;
            fbeCurrentSize += f100.FBESize;

            if ((fbeCurrentSize + f101.FBESize) <= fbeStructSize)
                f101.Get(out fbeValue.f101, true);
            else
                fbeValue.f101 = true;
            fbeCurrentSize += f101.FBESize;

            if ((fbeCurrentSize + f102.FBESize) <= fbeStructSize)
                f102.Get(out fbeValue.f102, null);
            else
                fbeValue.f102 = null;
            fbeCurrentSize += f102.FBESize;

            if ((fbeCurrentSize + f103.FBESize) <= fbeStructSize)
                f103.Get(out fbeValue.f103);
            else
                fbeValue.f103 = null;
            fbeCurrentSize += f103.FBESize;

            if ((fbeCurrentSize + f104.FBESize) <= fbeStructSize)
                f104.Get(out fbeValue.f104, Byte.MaxValue);
            else
                fbeValue.f104 = Byte.MaxValue;
            fbeCurrentSize += f104.FBESize;

            if ((fbeCurrentSize + f105.FBESize) <= fbeStructSize)
                f105.Get(out fbeValue.f105, null);
            else
                fbeValue.f105 = null;
            fbeCurrentSize += f105.FBESize;

            if ((fbeCurrentSize + f106.FBESize) <= fbeStructSize)
                f106.Get(out fbeValue.f106);
            else
                fbeValue.f106 = null;
            fbeCurrentSize += f106.FBESize;

            if ((fbeCurrentSize + f107.FBESize) <= fbeStructSize)
                f107.Get(out fbeValue.f107, (char)'!');
            else
                fbeValue.f107 = (char)'!';
            fbeCurrentSize += f107.FBESize;

            if ((fbeCurrentSize + f108.FBESize) <= fbeStructSize)
                f108.Get(out fbeValue.f108, null);
            else
                fbeValue.f108 = null;
            fbeCurrentSize += f108.FBESize;

            if ((fbeCurrentSize + f109.FBESize) <= fbeStructSize)
                f109.Get(out fbeValue.f109);
            else
                fbeValue.f109 = null;
            fbeCurrentSize += f109.FBESize;

            if ((fbeCurrentSize + f110.FBESize) <= fbeStructSize)
                f110.Get(out fbeValue.f110, (char)0x0444);
            else
                fbeValue.f110 = (char)0x0444;
            fbeCurrentSize += f110.FBESize;

            if ((fbeCurrentSize + f111.FBESize) <= fbeStructSize)
                f111.Get(out fbeValue.f111, null);
            else
                fbeValue.f111 = null;
            fbeCurrentSize += f111.FBESize;

            if ((fbeCurrentSize + f112.FBESize) <= fbeStructSize)
                f112.Get(out fbeValue.f112);
            else
                fbeValue.f112 = null;
            fbeCurrentSize += f112.FBESize;

            if ((fbeCurrentSize + f113.FBESize) <= fbeStructSize)
                f113.Get(out fbeValue.f113, SByte.MaxValue);
            else
                fbeValue.f113 = SByte.MaxValue;
            fbeCurrentSize += f113.FBESize;

            if ((fbeCurrentSize + f114.FBESize) <= fbeStructSize)
                f114.Get(out fbeValue.f114, null);
            else
                fbeValue.f114 = null;
            fbeCurrentSize += f114.FBESize;

            if ((fbeCurrentSize + f115.FBESize) <= fbeStructSize)
                f115.Get(out fbeValue.f115);
            else
                fbeValue.f115 = null;
            fbeCurrentSize += f115.FBESize;

            if ((fbeCurrentSize + f116.FBESize) <= fbeStructSize)
                f116.Get(out fbeValue.f116, Byte.MaxValue);
            else
                fbeValue.f116 = Byte.MaxValue;
            fbeCurrentSize += f116.FBESize;

            if ((fbeCurrentSize + f117.FBESize) <= fbeStructSize)
                f117.Get(out fbeValue.f117, null);
            else
                fbeValue.f117 = null;
            fbeCurrentSize += f117.FBESize;

            if ((fbeCurrentSize + f118.FBESize) <= fbeStructSize)
                f118.Get(out fbeValue.f118);
            else
                fbeValue.f118 = null;
            fbeCurrentSize += f118.FBESize;

            if ((fbeCurrentSize + f119.FBESize) <= fbeStructSize)
                f119.Get(out fbeValue.f119, Int16.MaxValue);
            else
                fbeValue.f119 = Int16.MaxValue;
            fbeCurrentSize += f119.FBESize;

            if ((fbeCurrentSize + f120.FBESize) <= fbeStructSize)
                f120.Get(out fbeValue.f120, null);
            else
                fbeValue.f120 = null;
            fbeCurrentSize += f120.FBESize;

            if ((fbeCurrentSize + f121.FBESize) <= fbeStructSize)
                f121.Get(out fbeValue.f121);
            else
                fbeValue.f121 = null;
            fbeCurrentSize += f121.FBESize;

            if ((fbeCurrentSize + f122.FBESize) <= fbeStructSize)
                f122.Get(out fbeValue.f122, UInt16.MaxValue);
            else
                fbeValue.f122 = UInt16.MaxValue;
            fbeCurrentSize += f122.FBESize;

            if ((fbeCurrentSize + f123.FBESize) <= fbeStructSize)
                f123.Get(out fbeValue.f123, null);
            else
                fbeValue.f123 = null;
            fbeCurrentSize += f123.FBESize;

            if ((fbeCurrentSize + f124.FBESize) <= fbeStructSize)
                f124.Get(out fbeValue.f124);
            else
                fbeValue.f124 = null;
            fbeCurrentSize += f124.FBESize;

            if ((fbeCurrentSize + f125.FBESize) <= fbeStructSize)
                f125.Get(out fbeValue.f125, Int32.MaxValue);
            else
                fbeValue.f125 = Int32.MaxValue;
            fbeCurrentSize += f125.FBESize;

            if ((fbeCurrentSize + f126.FBESize) <= fbeStructSize)
                f126.Get(out fbeValue.f126, null);
            else
                fbeValue.f126 = null;
            fbeCurrentSize += f126.FBESize;

            if ((fbeCurrentSize + f127.FBESize) <= fbeStructSize)
                f127.Get(out fbeValue.f127);
            else
                fbeValue.f127 = null;
            fbeCurrentSize += f127.FBESize;

            if ((fbeCurrentSize + f128.FBESize) <= fbeStructSize)
                f128.Get(out fbeValue.f128, UInt32.MaxValue);
            else
                fbeValue.f128 = UInt32.MaxValue;
            fbeCurrentSize += f128.FBESize;

            if ((fbeCurrentSize + f129.FBESize) <= fbeStructSize)
                f129.Get(out fbeValue.f129, null);
            else
                fbeValue.f129 = null;
            fbeCurrentSize += f129.FBESize;

            if ((fbeCurrentSize + f130.FBESize) <= fbeStructSize)
                f130.Get(out fbeValue.f130);
            else
                fbeValue.f130 = null;
            fbeCurrentSize += f130.FBESize;

            if ((fbeCurrentSize + f131.FBESize) <= fbeStructSize)
                f131.Get(out fbeValue.f131, Int64.MaxValue);
            else
                fbeValue.f131 = Int64.MaxValue;
            fbeCurrentSize += f131.FBESize;

            if ((fbeCurrentSize + f132.FBESize) <= fbeStructSize)
                f132.Get(out fbeValue.f132, null);
            else
                fbeValue.f132 = null;
            fbeCurrentSize += f132.FBESize;

            if ((fbeCurrentSize + f133.FBESize) <= fbeStructSize)
                f133.Get(out fbeValue.f133);
            else
                fbeValue.f133 = null;
            fbeCurrentSize += f133.FBESize;

            if ((fbeCurrentSize + f134.FBESize) <= fbeStructSize)
                f134.Get(out fbeValue.f134, UInt64.MaxValue);
            else
                fbeValue.f134 = UInt64.MaxValue;
            fbeCurrentSize += f134.FBESize;

            if ((fbeCurrentSize + f135.FBESize) <= fbeStructSize)
                f135.Get(out fbeValue.f135, null);
            else
                fbeValue.f135 = null;
            fbeCurrentSize += f135.FBESize;

            if ((fbeCurrentSize + f136.FBESize) <= fbeStructSize)
                f136.Get(out fbeValue.f136);
            else
                fbeValue.f136 = null;
            fbeCurrentSize += f136.FBESize;

            if ((fbeCurrentSize + f137.FBESize) <= fbeStructSize)
                f137.Get(out fbeValue.f137, (float)123.456F);
            else
                fbeValue.f137 = (float)123.456F;
            fbeCurrentSize += f137.FBESize;

            if ((fbeCurrentSize + f138.FBESize) <= fbeStructSize)
                f138.Get(out fbeValue.f138, null);
            else
                fbeValue.f138 = null;
            fbeCurrentSize += f138.FBESize;

            if ((fbeCurrentSize + f139.FBESize) <= fbeStructSize)
                f139.Get(out fbeValue.f139);
            else
                fbeValue.f139 = null;
            fbeCurrentSize += f139.FBESize;

            if ((fbeCurrentSize + f140.FBESize) <= fbeStructSize)
                f140.Get(out fbeValue.f140, (double)-123.456e+123D);
            else
                fbeValue.f140 = (double)-123.456e+123D;
            fbeCurrentSize += f140.FBESize;

            if ((fbeCurrentSize + f141.FBESize) <= fbeStructSize)
                f141.Get(out fbeValue.f141, null);
            else
                fbeValue.f141 = null;
            fbeCurrentSize += f141.FBESize;

            if ((fbeCurrentSize + f142.FBESize) <= fbeStructSize)
                f142.Get(out fbeValue.f142);
            else
                fbeValue.f142 = null;
            fbeCurrentSize += f142.FBESize;

            if ((fbeCurrentSize + f143.FBESize) <= fbeStructSize)
                f143.Get(out fbeValue.f143, (decimal)123456.123456M);
            else
                fbeValue.f143 = (decimal)123456.123456M;
            fbeCurrentSize += f143.FBESize;

            if ((fbeCurrentSize + f144.FBESize) <= fbeStructSize)
                f144.Get(out fbeValue.f144, null);
            else
                fbeValue.f144 = null;
            fbeCurrentSize += f144.FBESize;

            if ((fbeCurrentSize + f145.FBESize) <= fbeStructSize)
                f145.Get(out fbeValue.f145);
            else
                fbeValue.f145 = null;
            fbeCurrentSize += f145.FBESize;

            if ((fbeCurrentSize + f146.FBESize) <= fbeStructSize)
                f146.Get(out fbeValue.f146, "Initial string!");
            else
                fbeValue.f146 = "Initial string!";
            fbeCurrentSize += f146.FBESize;

            if ((fbeCurrentSize + f147.FBESize) <= fbeStructSize)
                f147.Get(out fbeValue.f147, null);
            else
                fbeValue.f147 = null;
            fbeCurrentSize += f147.FBESize;

            if ((fbeCurrentSize + f148.FBESize) <= fbeStructSize)
                f148.Get(out fbeValue.f148);
            else
                fbeValue.f148 = null;
            fbeCurrentSize += f148.FBESize;

            if ((fbeCurrentSize + f149.FBESize) <= fbeStructSize)
                f149.Get(out fbeValue.f149, DateTime.UtcNow);
            else
                fbeValue.f149 = DateTime.UtcNow;
            fbeCurrentSize += f149.FBESize;

            if ((fbeCurrentSize + f150.FBESize) <= fbeStructSize)
                f150.Get(out fbeValue.f150, null);
            else
                fbeValue.f150 = null;
            fbeCurrentSize += f150.FBESize;

            if ((fbeCurrentSize + f151.FBESize) <= fbeStructSize)
                f151.Get(out fbeValue.f151);
            else
                fbeValue.f151 = null;
            fbeCurrentSize += f151.FBESize;

            if ((fbeCurrentSize + f152.FBESize) <= fbeStructSize)
                f152.Get(out fbeValue.f152, Guid.Parse("123e4567-e89b-12d3-a456-426655440000"));
            else
                fbeValue.f152 = Guid.Parse("123e4567-e89b-12d3-a456-426655440000");
            fbeCurrentSize += f152.FBESize;

            if ((fbeCurrentSize + f153.FBESize) <= fbeStructSize)
                f153.Get(out fbeValue.f153, null);
            else
                fbeValue.f153 = null;
            fbeCurrentSize += f153.FBESize;

            if ((fbeCurrentSize + f154.FBESize) <= fbeStructSize)
                f154.Get(out fbeValue.f154);
            else
                fbeValue.f154 = null;
            fbeCurrentSize += f154.FBESize;

            if ((fbeCurrentSize + f155.FBESize) <= fbeStructSize)
                f155.Get(out fbeValue.f155, null);
            else
                fbeValue.f155 = null;
            fbeCurrentSize += f155.FBESize;

            if ((fbeCurrentSize + f156.FBESize) <= fbeStructSize)
                f156.Get(out fbeValue.f156);
            else
                fbeValue.f156 = null;
            fbeCurrentSize += f156.FBESize;

            if ((fbeCurrentSize + f157.FBESize) <= fbeStructSize)
                f157.Get(out fbeValue.f157, null);
            else
                fbeValue.f157 = null;
            fbeCurrentSize += f157.FBESize;

            if ((fbeCurrentSize + f158.FBESize) <= fbeStructSize)
                f158.Get(out fbeValue.f158);
            else
                fbeValue.f158 = null;
            fbeCurrentSize += f158.FBESize;

            if ((fbeCurrentSize + f159.FBESize) <= fbeStructSize)
                f159.Get(out fbeValue.f159, null);
            else
                fbeValue.f159 = null;
            fbeCurrentSize += f159.FBESize;

            if ((fbeCurrentSize + f160.FBESize) <= fbeStructSize)
                f160.Get(out fbeValue.f160);
            else
                fbeValue.f160 = null;
            fbeCurrentSize += f160.FBESize;

            if ((fbeCurrentSize + f161.FBESize) <= fbeStructSize)
                f161.Get(out fbeValue.f161, null);
            else
                fbeValue.f161 = null;
            fbeCurrentSize += f161.FBESize;

            if ((fbeCurrentSize + f162.FBESize) <= fbeStructSize)
                f162.Get(out fbeValue.f162);
            else
                fbeValue.f162 = null;
            fbeCurrentSize += f162.FBESize;

            if ((fbeCurrentSize + f163.FBESize) <= fbeStructSize)
                f163.Get(out fbeValue.f163, null);
            else
                fbeValue.f163 = null;
            fbeCurrentSize += f163.FBESize;

            if ((fbeCurrentSize + f164.FBESize) <= fbeStructSize)
                f164.Get(out fbeValue.f164);
            else
                fbeValue.f164 = null;
            fbeCurrentSize += f164.FBESize;

            if ((fbeCurrentSize + f165.FBESize) <= fbeStructSize)
                f165.Get(out fbeValue.f165, null);
            else
                fbeValue.f165 = null;
            fbeCurrentSize += f165.FBESize;
        }

        // Set the struct value (begin phase)
        public long SetBegin()
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            uint fbeStructSize = (uint)FBEBody;
            uint fbeStructOffset = (uint)(_buffer.Allocate(fbeStructSize) - _buffer.Offset);
            Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + fbeStructSize) <= _buffer.Size)), "Model is broken!");
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + fbeStructSize) > _buffer.Size))
                return 0;

            Write(FBEOffset, fbeStructOffset);
            Write(fbeStructOffset, fbeStructSize);
            Write(fbeStructOffset + 4, (uint)FBEType);

            _buffer.Shift(fbeStructOffset);
            return fbeStructOffset;
        }

        // Set the struct value (end phase)
        public void SetEnd(long fbeBegin)
        {
            _buffer.Unshift(fbeBegin);
        }

        // Set the struct value
        public override void Set(StructOptional fbeValue)
        {
            long fbeBegin = SetBegin();
            if (fbeBegin == 0)
                return;

            SetFields(fbeValue);
            SetEnd(fbeBegin);
        }

        // Set the struct fields values
        public void SetFields(StructOptional fbeValue)
        {
            parent.SetFields(fbeValue.parent);
            f100.Set(fbeValue.f100);
            f101.Set(fbeValue.f101);
            f102.Set(fbeValue.f102);
            f103.Set(fbeValue.f103);
            f104.Set(fbeValue.f104);
            f105.Set(fbeValue.f105);
            f106.Set(fbeValue.f106);
            f107.Set(fbeValue.f107);
            f108.Set(fbeValue.f108);
            f109.Set(fbeValue.f109);
            f110.Set(fbeValue.f110);
            f111.Set(fbeValue.f111);
            f112.Set(fbeValue.f112);
            f113.Set(fbeValue.f113);
            f114.Set(fbeValue.f114);
            f115.Set(fbeValue.f115);
            f116.Set(fbeValue.f116);
            f117.Set(fbeValue.f117);
            f118.Set(fbeValue.f118);
            f119.Set(fbeValue.f119);
            f120.Set(fbeValue.f120);
            f121.Set(fbeValue.f121);
            f122.Set(fbeValue.f122);
            f123.Set(fbeValue.f123);
            f124.Set(fbeValue.f124);
            f125.Set(fbeValue.f125);
            f126.Set(fbeValue.f126);
            f127.Set(fbeValue.f127);
            f128.Set(fbeValue.f128);
            f129.Set(fbeValue.f129);
            f130.Set(fbeValue.f130);
            f131.Set(fbeValue.f131);
            f132.Set(fbeValue.f132);
            f133.Set(fbeValue.f133);
            f134.Set(fbeValue.f134);
            f135.Set(fbeValue.f135);
            f136.Set(fbeValue.f136);
            f137.Set(fbeValue.f137);
            f138.Set(fbeValue.f138);
            f139.Set(fbeValue.f139);
            f140.Set(fbeValue.f140);
            f141.Set(fbeValue.f141);
            f142.Set(fbeValue.f142);
            f143.Set(fbeValue.f143);
            f144.Set(fbeValue.f144);
            f145.Set(fbeValue.f145);
            f146.Set(fbeValue.f146);
            f147.Set(fbeValue.f147);
            f148.Set(fbeValue.f148);
            f149.Set(fbeValue.f149);
            f150.Set(fbeValue.f150);
            f151.Set(fbeValue.f151);
            f152.Set(fbeValue.f152);
            f153.Set(fbeValue.f153);
            f154.Set(fbeValue.f154);
            f155.Set(fbeValue.f155);
            f156.Set(fbeValue.f156);
            f157.Set(fbeValue.f157);
            f158.Set(fbeValue.f158);
            f159.Set(fbeValue.f159);
            f160.Set(fbeValue.f160);
            f161.Set(fbeValue.f161);
            f162.Set(fbeValue.f162);
            f163.Set(fbeValue.f163);
            f164.Set(fbeValue.f164);
            f165.Set(fbeValue.f165);
        }
    }

} // namespace com.chronoxor.test.FBE

namespace com.chronoxor.test.FBE {

    using global::com.chronoxor.test;

    // Fast Binary Encoding StructOptional model
    public class StructOptionalModel : com.chronoxor.FBE.Model
    {
        public readonly FieldModelStructOptional model;

        public StructOptionalModel() { model = new FieldModelStructOptional(Buffer, 4); }
        public StructOptionalModel(com.chronoxor.FBE.Buffer buffer) : base(buffer) { model = new FieldModelStructOptional(Buffer, 4); }

        // Get the model size
        public long FBESize => model.FBESize + model.FBEExtra;
        // Get the model type
        public const long FBETypeConst = FieldModelStructOptional.FBETypeConst;
        public long FBEType => FBETypeConst;

        // Check if the struct value is valid
        public bool Verify()
        {
            if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
                return false;

            uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
            if (fbeFullSize < model.FBESize)
                return false;

            return model.Verify();
        }

        // Create a new model (begin phase)
        public long CreateBegin()
        {
            long fbeBegin = Buffer.Allocate(4 + model.FBESize);
            return fbeBegin;
        }

        // Create a new model (end phase)
        public long CreateEnd(long fbeBegin)
        {
            long fbeEnd = Buffer.Size;
            uint fbeFullSize = (uint)(fbeEnd - fbeBegin);
            Write(model.FBEOffset - 4, fbeFullSize);
            return fbeFullSize;
        }

        // Serialize the struct value
        public long Serialize(StructOptional value)
        {
            long fbeBegin = CreateBegin();
            model.Set(value);
            long fbeFullSize = CreateEnd(fbeBegin);
            return fbeFullSize;
        }

        // Deserialize the struct value
        public long Deserialize(out StructOptional value)
        {
            if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
            {
                value = StructOptional.Default;
                return 0;
            }

            uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
            Debug.Assert((fbeFullSize >= model.FBESize), "Model is broken!");
            if (fbeFullSize < model.FBESize)
            {
                value = StructOptional.Default;
                return 0;
            }

            model.Get(out value);
            return fbeFullSize;
        }

        // Move to the next struct value
        public void Next(long prev)
        {
            model.FBEShift(prev);
        }
    }

} // namespace com.chronoxor.test.FBE

namespace com.chronoxor.test.FBE {

    using global::com.chronoxor.test;

    // Fast Binary Encoding StructOptional final model
    public class FinalModelStructOptional : com.chronoxor.FBE.FinalModelValueType<StructOptional>
    {
        public readonly com.chronoxor.test.FBE.FinalModelStructSimple parent;
        public readonly com.chronoxor.FBE.FinalModelOptionalValueType<bool, com.chronoxor.FBE.FinalModelValueType<bool>> f100;
        public readonly com.chronoxor.FBE.FinalModelOptionalValueType<bool, com.chronoxor.FBE.FinalModelValueType<bool>> f101;
        public readonly com.chronoxor.FBE.FinalModelOptionalValueType<bool, com.chronoxor.FBE.FinalModelValueType<bool>> f102;
        public readonly com.chronoxor.FBE.FinalModelOptionalValueType<byte, com.chronoxor.FBE.FinalModelValueType<byte>> f103;
        public readonly com.chronoxor.FBE.FinalModelOptionalValueType<byte, com.chronoxor.FBE.FinalModelValueType<byte>> f104;
        public readonly com.chronoxor.FBE.FinalModelOptionalValueType<byte, com.chronoxor.FBE.FinalModelValueType<byte>> f105;
        public readonly com.chronoxor.FBE.FinalModelOptionalValueType<char, com.chronoxor.FBE.FinalModelValueType<char>> f106;
        public readonly com.chronoxor.FBE.FinalModelOptionalValueType<char, com.chronoxor.FBE.FinalModelValueType<char>> f107;
        public readonly com.chronoxor.FBE.FinalModelOptionalValueType<char, com.chronoxor.FBE.FinalModelValueType<char>> f108;
        public readonly com.chronoxor.FBE.FinalModelOptionalValueType<char, com.chronoxor.FBE.FinalModelValueType<char>> f109;
        public readonly com.chronoxor.FBE.FinalModelOptionalValueType<char, com.chronoxor.FBE.FinalModelValueType<char>> f110;
        public readonly com.chronoxor.FBE.FinalModelOptionalValueType<char, com.chronoxor.FBE.FinalModelValueType<char>> f111;
        public readonly com.chronoxor.FBE.FinalModelOptionalValueType<sbyte, com.chronoxor.FBE.FinalModelValueType<sbyte>> f112;
        public readonly com.chronoxor.FBE.FinalModelOptionalValueType<sbyte, com.chronoxor.FBE.FinalModelValueType<sbyte>> f113;
        public readonly com.chronoxor.FBE.FinalModelOptionalValueType<sbyte, com.chronoxor.FBE.FinalModelValueType<sbyte>> f114;
        public readonly com.chronoxor.FBE.FinalModelOptionalValueType<byte, com.chronoxor.FBE.FinalModelValueType<byte>> f115;
        public readonly com.chronoxor.FBE.FinalModelOptionalValueType<byte, com.chronoxor.FBE.FinalModelValueType<byte>> f116;
        public readonly com.chronoxor.FBE.FinalModelOptionalValueType<byte, com.chronoxor.FBE.FinalModelValueType<byte>> f117;
        public readonly com.chronoxor.FBE.FinalModelOptionalValueType<short, com.chronoxor.FBE.FinalModelValueType<short>> f118;
        public readonly com.chronoxor.FBE.FinalModelOptionalValueType<short, com.chronoxor.FBE.FinalModelValueType<short>> f119;
        public readonly com.chronoxor.FBE.FinalModelOptionalValueType<short, com.chronoxor.FBE.FinalModelValueType<short>> f120;
        public readonly com.chronoxor.FBE.FinalModelOptionalValueType<ushort, com.chronoxor.FBE.FinalModelValueType<ushort>> f121;
        public readonly com.chronoxor.FBE.FinalModelOptionalValueType<ushort, com.chronoxor.FBE.FinalModelValueType<ushort>> f122;
        public readonly com.chronoxor.FBE.FinalModelOptionalValueType<ushort, com.chronoxor.FBE.FinalModelValueType<ushort>> f123;
        public readonly com.chronoxor.FBE.FinalModelOptionalValueType<int, com.chronoxor.FBE.FinalModelValueType<int>> f124;
        public readonly com.chronoxor.FBE.FinalModelOptionalValueType<int, com.chronoxor.FBE.FinalModelValueType<int>> f125;
        public readonly com.chronoxor.FBE.FinalModelOptionalValueType<int, com.chronoxor.FBE.FinalModelValueType<int>> f126;
        public readonly com.chronoxor.FBE.FinalModelOptionalValueType<uint, com.chronoxor.FBE.FinalModelValueType<uint>> f127;
        public readonly com.chronoxor.FBE.FinalModelOptionalValueType<uint, com.chronoxor.FBE.FinalModelValueType<uint>> f128;
        public readonly com.chronoxor.FBE.FinalModelOptionalValueType<uint, com.chronoxor.FBE.FinalModelValueType<uint>> f129;
        public readonly com.chronoxor.FBE.FinalModelOptionalValueType<long, com.chronoxor.FBE.FinalModelValueType<long>> f130;
        public readonly com.chronoxor.FBE.FinalModelOptionalValueType<long, com.chronoxor.FBE.FinalModelValueType<long>> f131;
        public readonly com.chronoxor.FBE.FinalModelOptionalValueType<long, com.chronoxor.FBE.FinalModelValueType<long>> f132;
        public readonly com.chronoxor.FBE.FinalModelOptionalValueType<ulong, com.chronoxor.FBE.FinalModelValueType<ulong>> f133;
        public readonly com.chronoxor.FBE.FinalModelOptionalValueType<ulong, com.chronoxor.FBE.FinalModelValueType<ulong>> f134;
        public readonly com.chronoxor.FBE.FinalModelOptionalValueType<ulong, com.chronoxor.FBE.FinalModelValueType<ulong>> f135;
        public readonly com.chronoxor.FBE.FinalModelOptionalValueType<float, com.chronoxor.FBE.FinalModelValueType<float>> f136;
        public readonly com.chronoxor.FBE.FinalModelOptionalValueType<float, com.chronoxor.FBE.FinalModelValueType<float>> f137;
        public readonly com.chronoxor.FBE.FinalModelOptionalValueType<float, com.chronoxor.FBE.FinalModelValueType<float>> f138;
        public readonly com.chronoxor.FBE.FinalModelOptionalValueType<double, com.chronoxor.FBE.FinalModelValueType<double>> f139;
        public readonly com.chronoxor.FBE.FinalModelOptionalValueType<double, com.chronoxor.FBE.FinalModelValueType<double>> f140;
        public readonly com.chronoxor.FBE.FinalModelOptionalValueType<double, com.chronoxor.FBE.FinalModelValueType<double>> f141;
        public readonly com.chronoxor.FBE.FinalModelOptionalValueType<decimal, com.chronoxor.FBE.FinalModelValueType<decimal>> f142;
        public readonly com.chronoxor.FBE.FinalModelOptionalValueType<decimal, com.chronoxor.FBE.FinalModelValueType<decimal>> f143;
        public readonly com.chronoxor.FBE.FinalModelOptionalValueType<decimal, com.chronoxor.FBE.FinalModelValueType<decimal>> f144;
        public readonly com.chronoxor.FBE.FinalModelOptionalReferenceType<string, com.chronoxor.FBE.FinalModelReferenceType<string>> f145;
        public readonly com.chronoxor.FBE.FinalModelOptionalReferenceType<string, com.chronoxor.FBE.FinalModelReferenceType<string>> f146;
        public readonly com.chronoxor.FBE.FinalModelOptionalReferenceType<string, com.chronoxor.FBE.FinalModelReferenceType<string>> f147;
        public readonly com.chronoxor.FBE.FinalModelOptionalValueType<DateTime, com.chronoxor.FBE.FinalModelValueType<DateTime>> f148;
        public readonly com.chronoxor.FBE.FinalModelOptionalValueType<DateTime, com.chronoxor.FBE.FinalModelValueType<DateTime>> f149;
        public readonly com.chronoxor.FBE.FinalModelOptionalValueType<DateTime, com.chronoxor.FBE.FinalModelValueType<DateTime>> f150;
        public readonly com.chronoxor.FBE.FinalModelOptionalValueType<Guid, com.chronoxor.FBE.FinalModelValueType<Guid>> f151;
        public readonly com.chronoxor.FBE.FinalModelOptionalValueType<Guid, com.chronoxor.FBE.FinalModelValueType<Guid>> f152;
        public readonly com.chronoxor.FBE.FinalModelOptionalValueType<Guid, com.chronoxor.FBE.FinalModelValueType<Guid>> f153;
        public readonly com.chronoxor.FBE.FinalModelOptionalValueType<proto.OrderSide, com.chronoxor.proto.FBE.FinalModelOrderSide> f154;
        public readonly com.chronoxor.FBE.FinalModelOptionalValueType<proto.OrderSide, com.chronoxor.proto.FBE.FinalModelOrderSide> f155;
        public readonly com.chronoxor.FBE.FinalModelOptionalValueType<proto.OrderType, com.chronoxor.proto.FBE.FinalModelOrderType> f156;
        public readonly com.chronoxor.FBE.FinalModelOptionalValueType<proto.OrderType, com.chronoxor.proto.FBE.FinalModelOrderType> f157;
        public readonly com.chronoxor.FBE.FinalModelOptionalValueType<proto.Order, com.chronoxor.proto.FBE.FinalModelOrder> f158;
        public readonly com.chronoxor.FBE.FinalModelOptionalValueType<proto.Order, com.chronoxor.proto.FBE.FinalModelOrder> f159;
        public readonly com.chronoxor.FBE.FinalModelOptionalValueType<proto.Balance, com.chronoxor.proto.FBE.FinalModelBalance> f160;
        public readonly com.chronoxor.FBE.FinalModelOptionalValueType<proto.Balance, com.chronoxor.proto.FBE.FinalModelBalance> f161;
        public readonly com.chronoxor.FBE.FinalModelOptionalValueType<proto.State, com.chronoxor.proto.FBE.FinalModelState> f162;
        public readonly com.chronoxor.FBE.FinalModelOptionalValueType<proto.State, com.chronoxor.proto.FBE.FinalModelState> f163;
        public readonly com.chronoxor.FBE.FinalModelOptionalValueType<proto.Account, com.chronoxor.proto.FBE.FinalModelAccount> f164;
        public readonly com.chronoxor.FBE.FinalModelOptionalValueType<proto.Account, com.chronoxor.proto.FBE.FinalModelAccount> f165;

        public FinalModelStructOptional(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset)
        {
            parent = new com.chronoxor.test.FBE.FinalModelStructSimple(buffer, 0);
            f100 = new com.chronoxor.FBE.FinalModelOptionalValueType<bool, com.chronoxor.FBE.FinalModelValueType<bool>>(com.chronoxor.FBE.FinalModelValueType<bool>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.BOOL, buffer, 0), buffer, 0);
            f101 = new com.chronoxor.FBE.FinalModelOptionalValueType<bool, com.chronoxor.FBE.FinalModelValueType<bool>>(com.chronoxor.FBE.FinalModelValueType<bool>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.BOOL, buffer, 0), buffer, 0);
            f102 = new com.chronoxor.FBE.FinalModelOptionalValueType<bool, com.chronoxor.FBE.FinalModelValueType<bool>>(com.chronoxor.FBE.FinalModelValueType<bool>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.BOOL, buffer, 0), buffer, 0);
            f103 = new com.chronoxor.FBE.FinalModelOptionalValueType<byte, com.chronoxor.FBE.FinalModelValueType<byte>>(com.chronoxor.FBE.FinalModelValueType<byte>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.BYTE, buffer, 0), buffer, 0);
            f104 = new com.chronoxor.FBE.FinalModelOptionalValueType<byte, com.chronoxor.FBE.FinalModelValueType<byte>>(com.chronoxor.FBE.FinalModelValueType<byte>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.BYTE, buffer, 0), buffer, 0);
            f105 = new com.chronoxor.FBE.FinalModelOptionalValueType<byte, com.chronoxor.FBE.FinalModelValueType<byte>>(com.chronoxor.FBE.FinalModelValueType<byte>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.BYTE, buffer, 0), buffer, 0);
            f106 = new com.chronoxor.FBE.FinalModelOptionalValueType<char, com.chronoxor.FBE.FinalModelValueType<char>>(com.chronoxor.FBE.FinalModelValueType<char>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.CHAR, buffer, 0), buffer, 0);
            f107 = new com.chronoxor.FBE.FinalModelOptionalValueType<char, com.chronoxor.FBE.FinalModelValueType<char>>(com.chronoxor.FBE.FinalModelValueType<char>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.CHAR, buffer, 0), buffer, 0);
            f108 = new com.chronoxor.FBE.FinalModelOptionalValueType<char, com.chronoxor.FBE.FinalModelValueType<char>>(com.chronoxor.FBE.FinalModelValueType<char>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.CHAR, buffer, 0), buffer, 0);
            f109 = new com.chronoxor.FBE.FinalModelOptionalValueType<char, com.chronoxor.FBE.FinalModelValueType<char>>(com.chronoxor.FBE.FinalModelValueType<char>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.WCHAR, buffer, 0), buffer, 0);
            f110 = new com.chronoxor.FBE.FinalModelOptionalValueType<char, com.chronoxor.FBE.FinalModelValueType<char>>(com.chronoxor.FBE.FinalModelValueType<char>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.WCHAR, buffer, 0), buffer, 0);
            f111 = new com.chronoxor.FBE.FinalModelOptionalValueType<char, com.chronoxor.FBE.FinalModelValueType<char>>(com.chronoxor.FBE.FinalModelValueType<char>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.WCHAR, buffer, 0), buffer, 0);
            f112 = new com.chronoxor.FBE.FinalModelOptionalValueType<sbyte, com.chronoxor.FBE.FinalModelValueType<sbyte>>(com.chronoxor.FBE.FinalModelValueType<sbyte>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.INT8, buffer, 0), buffer, 0);
            f113 = new com.chronoxor.FBE.FinalModelOptionalValueType<sbyte, com.chronoxor.FBE.FinalModelValueType<sbyte>>(com.chronoxor.FBE.FinalModelValueType<sbyte>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.INT8, buffer, 0), buffer, 0);
            f114 = new com.chronoxor.FBE.FinalModelOptionalValueType<sbyte, com.chronoxor.FBE.FinalModelValueType<sbyte>>(com.chronoxor.FBE.FinalModelValueType<sbyte>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.INT8, buffer, 0), buffer, 0);
            f115 = new com.chronoxor.FBE.FinalModelOptionalValueType<byte, com.chronoxor.FBE.FinalModelValueType<byte>>(com.chronoxor.FBE.FinalModelValueType<byte>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.UINT8, buffer, 0), buffer, 0);
            f116 = new com.chronoxor.FBE.FinalModelOptionalValueType<byte, com.chronoxor.FBE.FinalModelValueType<byte>>(com.chronoxor.FBE.FinalModelValueType<byte>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.UINT8, buffer, 0), buffer, 0);
            f117 = new com.chronoxor.FBE.FinalModelOptionalValueType<byte, com.chronoxor.FBE.FinalModelValueType<byte>>(com.chronoxor.FBE.FinalModelValueType<byte>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.UINT8, buffer, 0), buffer, 0);
            f118 = new com.chronoxor.FBE.FinalModelOptionalValueType<short, com.chronoxor.FBE.FinalModelValueType<short>>(com.chronoxor.FBE.FinalModelValueType<short>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.INT16, buffer, 0), buffer, 0);
            f119 = new com.chronoxor.FBE.FinalModelOptionalValueType<short, com.chronoxor.FBE.FinalModelValueType<short>>(com.chronoxor.FBE.FinalModelValueType<short>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.INT16, buffer, 0), buffer, 0);
            f120 = new com.chronoxor.FBE.FinalModelOptionalValueType<short, com.chronoxor.FBE.FinalModelValueType<short>>(com.chronoxor.FBE.FinalModelValueType<short>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.INT16, buffer, 0), buffer, 0);
            f121 = new com.chronoxor.FBE.FinalModelOptionalValueType<ushort, com.chronoxor.FBE.FinalModelValueType<ushort>>(com.chronoxor.FBE.FinalModelValueType<ushort>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.UINT16, buffer, 0), buffer, 0);
            f122 = new com.chronoxor.FBE.FinalModelOptionalValueType<ushort, com.chronoxor.FBE.FinalModelValueType<ushort>>(com.chronoxor.FBE.FinalModelValueType<ushort>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.UINT16, buffer, 0), buffer, 0);
            f123 = new com.chronoxor.FBE.FinalModelOptionalValueType<ushort, com.chronoxor.FBE.FinalModelValueType<ushort>>(com.chronoxor.FBE.FinalModelValueType<ushort>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.UINT16, buffer, 0), buffer, 0);
            f124 = new com.chronoxor.FBE.FinalModelOptionalValueType<int, com.chronoxor.FBE.FinalModelValueType<int>>(com.chronoxor.FBE.FinalModelValueType<int>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.INT32, buffer, 0), buffer, 0);
            f125 = new com.chronoxor.FBE.FinalModelOptionalValueType<int, com.chronoxor.FBE.FinalModelValueType<int>>(com.chronoxor.FBE.FinalModelValueType<int>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.INT32, buffer, 0), buffer, 0);
            f126 = new com.chronoxor.FBE.FinalModelOptionalValueType<int, com.chronoxor.FBE.FinalModelValueType<int>>(com.chronoxor.FBE.FinalModelValueType<int>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.INT32, buffer, 0), buffer, 0);
            f127 = new com.chronoxor.FBE.FinalModelOptionalValueType<uint, com.chronoxor.FBE.FinalModelValueType<uint>>(com.chronoxor.FBE.FinalModelValueType<uint>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.UINT32, buffer, 0), buffer, 0);
            f128 = new com.chronoxor.FBE.FinalModelOptionalValueType<uint, com.chronoxor.FBE.FinalModelValueType<uint>>(com.chronoxor.FBE.FinalModelValueType<uint>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.UINT32, buffer, 0), buffer, 0);
            f129 = new com.chronoxor.FBE.FinalModelOptionalValueType<uint, com.chronoxor.FBE.FinalModelValueType<uint>>(com.chronoxor.FBE.FinalModelValueType<uint>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.UINT32, buffer, 0), buffer, 0);
            f130 = new com.chronoxor.FBE.FinalModelOptionalValueType<long, com.chronoxor.FBE.FinalModelValueType<long>>(com.chronoxor.FBE.FinalModelValueType<long>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.INT64, buffer, 0), buffer, 0);
            f131 = new com.chronoxor.FBE.FinalModelOptionalValueType<long, com.chronoxor.FBE.FinalModelValueType<long>>(com.chronoxor.FBE.FinalModelValueType<long>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.INT64, buffer, 0), buffer, 0);
            f132 = new com.chronoxor.FBE.FinalModelOptionalValueType<long, com.chronoxor.FBE.FinalModelValueType<long>>(com.chronoxor.FBE.FinalModelValueType<long>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.INT64, buffer, 0), buffer, 0);
            f133 = new com.chronoxor.FBE.FinalModelOptionalValueType<ulong, com.chronoxor.FBE.FinalModelValueType<ulong>>(com.chronoxor.FBE.FinalModelValueType<ulong>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.UINT64, buffer, 0), buffer, 0);
            f134 = new com.chronoxor.FBE.FinalModelOptionalValueType<ulong, com.chronoxor.FBE.FinalModelValueType<ulong>>(com.chronoxor.FBE.FinalModelValueType<ulong>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.UINT64, buffer, 0), buffer, 0);
            f135 = new com.chronoxor.FBE.FinalModelOptionalValueType<ulong, com.chronoxor.FBE.FinalModelValueType<ulong>>(com.chronoxor.FBE.FinalModelValueType<ulong>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.UINT64, buffer, 0), buffer, 0);
            f136 = new com.chronoxor.FBE.FinalModelOptionalValueType<float, com.chronoxor.FBE.FinalModelValueType<float>>(com.chronoxor.FBE.FinalModelValueType<float>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.FLOAT, buffer, 0), buffer, 0);
            f137 = new com.chronoxor.FBE.FinalModelOptionalValueType<float, com.chronoxor.FBE.FinalModelValueType<float>>(com.chronoxor.FBE.FinalModelValueType<float>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.FLOAT, buffer, 0), buffer, 0);
            f138 = new com.chronoxor.FBE.FinalModelOptionalValueType<float, com.chronoxor.FBE.FinalModelValueType<float>>(com.chronoxor.FBE.FinalModelValueType<float>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.FLOAT, buffer, 0), buffer, 0);
            f139 = new com.chronoxor.FBE.FinalModelOptionalValueType<double, com.chronoxor.FBE.FinalModelValueType<double>>(com.chronoxor.FBE.FinalModelValueType<double>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.DOUBLE, buffer, 0), buffer, 0);
            f140 = new com.chronoxor.FBE.FinalModelOptionalValueType<double, com.chronoxor.FBE.FinalModelValueType<double>>(com.chronoxor.FBE.FinalModelValueType<double>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.DOUBLE, buffer, 0), buffer, 0);
            f141 = new com.chronoxor.FBE.FinalModelOptionalValueType<double, com.chronoxor.FBE.FinalModelValueType<double>>(com.chronoxor.FBE.FinalModelValueType<double>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.DOUBLE, buffer, 0), buffer, 0);
            f142 = new com.chronoxor.FBE.FinalModelOptionalValueType<decimal, com.chronoxor.FBE.FinalModelValueType<decimal>>(com.chronoxor.FBE.FinalModelValueType<decimal>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.DECIMAL, buffer, 0), buffer, 0);
            f143 = new com.chronoxor.FBE.FinalModelOptionalValueType<decimal, com.chronoxor.FBE.FinalModelValueType<decimal>>(com.chronoxor.FBE.FinalModelValueType<decimal>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.DECIMAL, buffer, 0), buffer, 0);
            f144 = new com.chronoxor.FBE.FinalModelOptionalValueType<decimal, com.chronoxor.FBE.FinalModelValueType<decimal>>(com.chronoxor.FBE.FinalModelValueType<decimal>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.DECIMAL, buffer, 0), buffer, 0);
            f145 = new com.chronoxor.FBE.FinalModelOptionalReferenceType<string, com.chronoxor.FBE.FinalModelReferenceType<string>>(com.chronoxor.FBE.FinalModelReferenceType<string>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.STRING, buffer, 0), buffer, 0);
            f146 = new com.chronoxor.FBE.FinalModelOptionalReferenceType<string, com.chronoxor.FBE.FinalModelReferenceType<string>>(com.chronoxor.FBE.FinalModelReferenceType<string>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.STRING, buffer, 0), buffer, 0);
            f147 = new com.chronoxor.FBE.FinalModelOptionalReferenceType<string, com.chronoxor.FBE.FinalModelReferenceType<string>>(com.chronoxor.FBE.FinalModelReferenceType<string>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.STRING, buffer, 0), buffer, 0);
            f148 = new com.chronoxor.FBE.FinalModelOptionalValueType<DateTime, com.chronoxor.FBE.FinalModelValueType<DateTime>>(com.chronoxor.FBE.FinalModelValueType<DateTime>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.TIMESTAMP, buffer, 0), buffer, 0);
            f149 = new com.chronoxor.FBE.FinalModelOptionalValueType<DateTime, com.chronoxor.FBE.FinalModelValueType<DateTime>>(com.chronoxor.FBE.FinalModelValueType<DateTime>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.TIMESTAMP, buffer, 0), buffer, 0);
            f150 = new com.chronoxor.FBE.FinalModelOptionalValueType<DateTime, com.chronoxor.FBE.FinalModelValueType<DateTime>>(com.chronoxor.FBE.FinalModelValueType<DateTime>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.TIMESTAMP, buffer, 0), buffer, 0);
            f151 = new com.chronoxor.FBE.FinalModelOptionalValueType<Guid, com.chronoxor.FBE.FinalModelValueType<Guid>>(com.chronoxor.FBE.FinalModelValueType<Guid>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.UUID, buffer, 0), buffer, 0);
            f152 = new com.chronoxor.FBE.FinalModelOptionalValueType<Guid, com.chronoxor.FBE.FinalModelValueType<Guid>>(com.chronoxor.FBE.FinalModelValueType<Guid>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.UUID, buffer, 0), buffer, 0);
            f153 = new com.chronoxor.FBE.FinalModelOptionalValueType<Guid, com.chronoxor.FBE.FinalModelValueType<Guid>>(com.chronoxor.FBE.FinalModelValueType<Guid>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.UUID, buffer, 0), buffer, 0);
            f154 = new com.chronoxor.FBE.FinalModelOptionalValueType<proto.OrderSide, com.chronoxor.proto.FBE.FinalModelOrderSide>(new com.chronoxor.proto.FBE.FinalModelOrderSide(buffer, 0), buffer, 0);
            f155 = new com.chronoxor.FBE.FinalModelOptionalValueType<proto.OrderSide, com.chronoxor.proto.FBE.FinalModelOrderSide>(new com.chronoxor.proto.FBE.FinalModelOrderSide(buffer, 0), buffer, 0);
            f156 = new com.chronoxor.FBE.FinalModelOptionalValueType<proto.OrderType, com.chronoxor.proto.FBE.FinalModelOrderType>(new com.chronoxor.proto.FBE.FinalModelOrderType(buffer, 0), buffer, 0);
            f157 = new com.chronoxor.FBE.FinalModelOptionalValueType<proto.OrderType, com.chronoxor.proto.FBE.FinalModelOrderType>(new com.chronoxor.proto.FBE.FinalModelOrderType(buffer, 0), buffer, 0);
            f158 = new com.chronoxor.FBE.FinalModelOptionalValueType<proto.Order, com.chronoxor.proto.FBE.FinalModelOrder>(new com.chronoxor.proto.FBE.FinalModelOrder(buffer, 0), buffer, 0);
            f159 = new com.chronoxor.FBE.FinalModelOptionalValueType<proto.Order, com.chronoxor.proto.FBE.FinalModelOrder>(new com.chronoxor.proto.FBE.FinalModelOrder(buffer, 0), buffer, 0);
            f160 = new com.chronoxor.FBE.FinalModelOptionalValueType<proto.Balance, com.chronoxor.proto.FBE.FinalModelBalance>(new com.chronoxor.proto.FBE.FinalModelBalance(buffer, 0), buffer, 0);
            f161 = new com.chronoxor.FBE.FinalModelOptionalValueType<proto.Balance, com.chronoxor.proto.FBE.FinalModelBalance>(new com.chronoxor.proto.FBE.FinalModelBalance(buffer, 0), buffer, 0);
            f162 = new com.chronoxor.FBE.FinalModelOptionalValueType<proto.State, com.chronoxor.proto.FBE.FinalModelState>(new com.chronoxor.proto.FBE.FinalModelState(buffer, 0), buffer, 0);
            f163 = new com.chronoxor.FBE.FinalModelOptionalValueType<proto.State, com.chronoxor.proto.FBE.FinalModelState>(new com.chronoxor.proto.FBE.FinalModelState(buffer, 0), buffer, 0);
            f164 = new com.chronoxor.FBE.FinalModelOptionalValueType<proto.Account, com.chronoxor.proto.FBE.FinalModelAccount>(new com.chronoxor.proto.FBE.FinalModelAccount(buffer, 0), buffer, 0);
            f165 = new com.chronoxor.FBE.FinalModelOptionalValueType<proto.Account, com.chronoxor.proto.FBE.FinalModelAccount>(new com.chronoxor.proto.FBE.FinalModelAccount(buffer, 0), buffer, 0);
        }

        // Get the allocation size
        public override long FBEAllocationSize(StructOptional fbeValue)
        {
            long fbeResult = 0
                + parent.FBEAllocationSize(fbeValue.parent)
                + f100.FBEAllocationSize(fbeValue.f100)
                + f101.FBEAllocationSize(fbeValue.f101)
                + f102.FBEAllocationSize(fbeValue.f102)
                + f103.FBEAllocationSize(fbeValue.f103)
                + f104.FBEAllocationSize(fbeValue.f104)
                + f105.FBEAllocationSize(fbeValue.f105)
                + f106.FBEAllocationSize(fbeValue.f106)
                + f107.FBEAllocationSize(fbeValue.f107)
                + f108.FBEAllocationSize(fbeValue.f108)
                + f109.FBEAllocationSize(fbeValue.f109)
                + f110.FBEAllocationSize(fbeValue.f110)
                + f111.FBEAllocationSize(fbeValue.f111)
                + f112.FBEAllocationSize(fbeValue.f112)
                + f113.FBEAllocationSize(fbeValue.f113)
                + f114.FBEAllocationSize(fbeValue.f114)
                + f115.FBEAllocationSize(fbeValue.f115)
                + f116.FBEAllocationSize(fbeValue.f116)
                + f117.FBEAllocationSize(fbeValue.f117)
                + f118.FBEAllocationSize(fbeValue.f118)
                + f119.FBEAllocationSize(fbeValue.f119)
                + f120.FBEAllocationSize(fbeValue.f120)
                + f121.FBEAllocationSize(fbeValue.f121)
                + f122.FBEAllocationSize(fbeValue.f122)
                + f123.FBEAllocationSize(fbeValue.f123)
                + f124.FBEAllocationSize(fbeValue.f124)
                + f125.FBEAllocationSize(fbeValue.f125)
                + f126.FBEAllocationSize(fbeValue.f126)
                + f127.FBEAllocationSize(fbeValue.f127)
                + f128.FBEAllocationSize(fbeValue.f128)
                + f129.FBEAllocationSize(fbeValue.f129)
                + f130.FBEAllocationSize(fbeValue.f130)
                + f131.FBEAllocationSize(fbeValue.f131)
                + f132.FBEAllocationSize(fbeValue.f132)
                + f133.FBEAllocationSize(fbeValue.f133)
                + f134.FBEAllocationSize(fbeValue.f134)
                + f135.FBEAllocationSize(fbeValue.f135)
                + f136.FBEAllocationSize(fbeValue.f136)
                + f137.FBEAllocationSize(fbeValue.f137)
                + f138.FBEAllocationSize(fbeValue.f138)
                + f139.FBEAllocationSize(fbeValue.f139)
                + f140.FBEAllocationSize(fbeValue.f140)
                + f141.FBEAllocationSize(fbeValue.f141)
                + f142.FBEAllocationSize(fbeValue.f142)
                + f143.FBEAllocationSize(fbeValue.f143)
                + f144.FBEAllocationSize(fbeValue.f144)
                + f145.FBEAllocationSize(fbeValue.f145)
                + f146.FBEAllocationSize(fbeValue.f146)
                + f147.FBEAllocationSize(fbeValue.f147)
                + f148.FBEAllocationSize(fbeValue.f148)
                + f149.FBEAllocationSize(fbeValue.f149)
                + f150.FBEAllocationSize(fbeValue.f150)
                + f151.FBEAllocationSize(fbeValue.f151)
                + f152.FBEAllocationSize(fbeValue.f152)
                + f153.FBEAllocationSize(fbeValue.f153)
                + f154.FBEAllocationSize(fbeValue.f154)
                + f155.FBEAllocationSize(fbeValue.f155)
                + f156.FBEAllocationSize(fbeValue.f156)
                + f157.FBEAllocationSize(fbeValue.f157)
                + f158.FBEAllocationSize(fbeValue.f158)
                + f159.FBEAllocationSize(fbeValue.f159)
                + f160.FBEAllocationSize(fbeValue.f160)
                + f161.FBEAllocationSize(fbeValue.f161)
                + f162.FBEAllocationSize(fbeValue.f162)
                + f163.FBEAllocationSize(fbeValue.f163)
                + f164.FBEAllocationSize(fbeValue.f164)
                + f165.FBEAllocationSize(fbeValue.f165)
                ;
            return fbeResult;
        }

        // Get the final type
        public const long FBETypeConst = 111;
        public long FBEType => FBETypeConst;

        // Clone the final model
        public override com.chronoxor.FBE.FinalModelValueType<StructOptional> Clone() { return new FinalModelStructOptional(_buffer, _offset); }

        // Check if the struct value is valid
        public override long Verify()
        {
            _buffer.Shift(FBEOffset);
            long fbeResult = VerifyFields();
            _buffer.Unshift(FBEOffset);
            return fbeResult;
        }

        // Check if the struct fields are valid
        public long VerifyFields()
        {
            long fbeCurrentOffset = 0;
            long fbeFieldSize;

            parent.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = parent.VerifyFields();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f100.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f100.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f101.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f101.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f102.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f102.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f103.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f103.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f104.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f104.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f105.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f105.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f106.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f106.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f107.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f107.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f108.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f108.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f109.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f109.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f110.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f110.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f111.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f111.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f112.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f112.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f113.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f113.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f114.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f114.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f115.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f115.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f116.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f116.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f117.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f117.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f118.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f118.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f119.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f119.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f120.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f120.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f121.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f121.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f122.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f122.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f123.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f123.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f124.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f124.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f125.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f125.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f126.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f126.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f127.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f127.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f128.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f128.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f129.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f129.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f130.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f130.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f131.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f131.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f132.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f132.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f133.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f133.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f134.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f134.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f135.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f135.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f136.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f136.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f137.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f137.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f138.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f138.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f139.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f139.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f140.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f140.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f141.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f141.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f142.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f142.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f143.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f143.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f144.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f144.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f145.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f145.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f146.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f146.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f147.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f147.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f148.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f148.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f149.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f149.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f150.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f150.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f151.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f151.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f152.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f152.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f153.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f153.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f154.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f154.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f155.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f155.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f156.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f156.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f157.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f157.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f158.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f158.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f159.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f159.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f160.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f160.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f161.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f161.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f162.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f162.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f163.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f163.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f164.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f164.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f165.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f165.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            return fbeCurrentOffset;
        }

        // Get the struct value
        public override long Get(out StructOptional fbeValue)
        {
            _buffer.Shift(FBEOffset);
            long fbeSize = GetFields(out fbeValue);
            _buffer.Unshift(FBEOffset);
            return fbeSize;
        }

        // Get the struct fields values
        public long GetFields(out StructOptional fbeValue)
        {
            long fbeCurrentOffset = 0;
            long fbeCurrentSize = 0;
            long fbeFieldSize;

            fbeValue = StructOptional.Default;

            parent.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = parent.GetFields(out fbeValue.parent);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f100.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f100.Get(out fbeValue.f100);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f101.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f101.Get(out fbeValue.f101);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f102.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f102.Get(out fbeValue.f102);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f103.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f103.Get(out fbeValue.f103);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f104.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f104.Get(out fbeValue.f104);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f105.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f105.Get(out fbeValue.f105);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f106.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f106.Get(out fbeValue.f106);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f107.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f107.Get(out fbeValue.f107);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f108.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f108.Get(out fbeValue.f108);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f109.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f109.Get(out fbeValue.f109);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f110.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f110.Get(out fbeValue.f110);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f111.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f111.Get(out fbeValue.f111);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f112.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f112.Get(out fbeValue.f112);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f113.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f113.Get(out fbeValue.f113);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f114.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f114.Get(out fbeValue.f114);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f115.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f115.Get(out fbeValue.f115);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f116.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f116.Get(out fbeValue.f116);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f117.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f117.Get(out fbeValue.f117);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f118.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f118.Get(out fbeValue.f118);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f119.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f119.Get(out fbeValue.f119);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f120.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f120.Get(out fbeValue.f120);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f121.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f121.Get(out fbeValue.f121);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f122.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f122.Get(out fbeValue.f122);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f123.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f123.Get(out fbeValue.f123);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f124.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f124.Get(out fbeValue.f124);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f125.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f125.Get(out fbeValue.f125);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f126.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f126.Get(out fbeValue.f126);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f127.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f127.Get(out fbeValue.f127);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f128.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f128.Get(out fbeValue.f128);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f129.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f129.Get(out fbeValue.f129);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f130.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f130.Get(out fbeValue.f130);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f131.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f131.Get(out fbeValue.f131);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f132.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f132.Get(out fbeValue.f132);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f133.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f133.Get(out fbeValue.f133);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f134.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f134.Get(out fbeValue.f134);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f135.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f135.Get(out fbeValue.f135);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f136.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f136.Get(out fbeValue.f136);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f137.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f137.Get(out fbeValue.f137);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f138.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f138.Get(out fbeValue.f138);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f139.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f139.Get(out fbeValue.f139);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f140.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f140.Get(out fbeValue.f140);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f141.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f141.Get(out fbeValue.f141);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f142.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f142.Get(out fbeValue.f142);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f143.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f143.Get(out fbeValue.f143);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f144.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f144.Get(out fbeValue.f144);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f145.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f145.Get(out fbeValue.f145);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f146.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f146.Get(out fbeValue.f146);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f147.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f147.Get(out fbeValue.f147);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f148.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f148.Get(out fbeValue.f148);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f149.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f149.Get(out fbeValue.f149);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f150.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f150.Get(out fbeValue.f150);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f151.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f151.Get(out fbeValue.f151);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f152.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f152.Get(out fbeValue.f152);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f153.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f153.Get(out fbeValue.f153);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f154.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f154.Get(out fbeValue.f154);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f155.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f155.Get(out fbeValue.f155);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f156.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f156.Get(out fbeValue.f156);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f157.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f157.Get(out fbeValue.f157);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f158.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f158.Get(out fbeValue.f158);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f159.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f159.Get(out fbeValue.f159);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f160.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f160.Get(out fbeValue.f160);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f161.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f161.Get(out fbeValue.f161);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f162.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f162.Get(out fbeValue.f162);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f163.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f163.Get(out fbeValue.f163);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f164.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f164.Get(out fbeValue.f164);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f165.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f165.Get(out fbeValue.f165);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            return fbeCurrentSize;
        }

        // Set the struct value
        public override long Set(StructOptional fbeValue)
        {
            _buffer.Shift(FBEOffset);
            long fbeResult = SetFields(fbeValue);
            _buffer.Unshift(FBEOffset);
            return fbeResult;
        }

        // Set the struct fields values
        public long SetFields(StructOptional fbeValue)
        {
            long fbeCurrentOffset = 0;
            long fbeCurrentSize = 0;
            long fbeFieldSize;

            parent.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = parent.SetFields(fbeValue.parent);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f100.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f100.Set(fbeValue.f100);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f101.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f101.Set(fbeValue.f101);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f102.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f102.Set(fbeValue.f102);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f103.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f103.Set(fbeValue.f103);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f104.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f104.Set(fbeValue.f104);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f105.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f105.Set(fbeValue.f105);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f106.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f106.Set(fbeValue.f106);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f107.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f107.Set(fbeValue.f107);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f108.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f108.Set(fbeValue.f108);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f109.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f109.Set(fbeValue.f109);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f110.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f110.Set(fbeValue.f110);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f111.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f111.Set(fbeValue.f111);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f112.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f112.Set(fbeValue.f112);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f113.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f113.Set(fbeValue.f113);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f114.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f114.Set(fbeValue.f114);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f115.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f115.Set(fbeValue.f115);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f116.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f116.Set(fbeValue.f116);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f117.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f117.Set(fbeValue.f117);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f118.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f118.Set(fbeValue.f118);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f119.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f119.Set(fbeValue.f119);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f120.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f120.Set(fbeValue.f120);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f121.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f121.Set(fbeValue.f121);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f122.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f122.Set(fbeValue.f122);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f123.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f123.Set(fbeValue.f123);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f124.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f124.Set(fbeValue.f124);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f125.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f125.Set(fbeValue.f125);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f126.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f126.Set(fbeValue.f126);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f127.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f127.Set(fbeValue.f127);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f128.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f128.Set(fbeValue.f128);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f129.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f129.Set(fbeValue.f129);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f130.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f130.Set(fbeValue.f130);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f131.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f131.Set(fbeValue.f131);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f132.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f132.Set(fbeValue.f132);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f133.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f133.Set(fbeValue.f133);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f134.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f134.Set(fbeValue.f134);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f135.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f135.Set(fbeValue.f135);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f136.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f136.Set(fbeValue.f136);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f137.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f137.Set(fbeValue.f137);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f138.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f138.Set(fbeValue.f138);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f139.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f139.Set(fbeValue.f139);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f140.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f140.Set(fbeValue.f140);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f141.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f141.Set(fbeValue.f141);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f142.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f142.Set(fbeValue.f142);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f143.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f143.Set(fbeValue.f143);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f144.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f144.Set(fbeValue.f144);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f145.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f145.Set(fbeValue.f145);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f146.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f146.Set(fbeValue.f146);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f147.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f147.Set(fbeValue.f147);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f148.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f148.Set(fbeValue.f148);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f149.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f149.Set(fbeValue.f149);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f150.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f150.Set(fbeValue.f150);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f151.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f151.Set(fbeValue.f151);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f152.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f152.Set(fbeValue.f152);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f153.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f153.Set(fbeValue.f153);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f154.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f154.Set(fbeValue.f154);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f155.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f155.Set(fbeValue.f155);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f156.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f156.Set(fbeValue.f156);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f157.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f157.Set(fbeValue.f157);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f158.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f158.Set(fbeValue.f158);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f159.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f159.Set(fbeValue.f159);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f160.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f160.Set(fbeValue.f160);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f161.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f161.Set(fbeValue.f161);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f162.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f162.Set(fbeValue.f162);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f163.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f163.Set(fbeValue.f163);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f164.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f164.Set(fbeValue.f164);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f165.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f165.Set(fbeValue.f165);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            return fbeCurrentSize;
        }
    }

} // namespace com.chronoxor.test.FBE

namespace com.chronoxor.test.FBE {

    using global::com.chronoxor.test;

    // Fast Binary Encoding StructOptional final model
    public class StructOptionalFinalModel : com.chronoxor.FBE.Model
    {
        private readonly FinalModelStructOptional _model;

        public StructOptionalFinalModel() { _model = new FinalModelStructOptional(Buffer, 8); }
        public StructOptionalFinalModel(com.chronoxor.FBE.Buffer buffer) : base(buffer) { _model = new FinalModelStructOptional(Buffer, 8); }

        // Get the model type
        public const long FBETypeConst = FinalModelStructOptional.FBETypeConst;
        public long FBEType => FBETypeConst;

        // Check if the struct value is valid
        public bool Verify()
        {
            if ((Buffer.Offset + _model.FBEOffset) > Buffer.Size)
                return false;

            long fbeStructSize = ReadUInt32(_model.FBEOffset - 8);
            long fbeStructType = ReadUInt32(_model.FBEOffset - 4);
            if ((fbeStructSize <= 0) || (fbeStructType != FBEType))
                return false;

            return ((8 + _model.Verify()) == fbeStructSize);
        }

        // Serialize the struct value
        public long Serialize(StructOptional value)
        {
            long fbeInitialSize = Buffer.Size;

            uint fbeStructType = (uint)FBEType;
            uint fbeStructSize = (uint)(8 + _model.FBEAllocationSize(value));
            uint fbeStructOffset = (uint)(Buffer.Allocate(fbeStructSize) - Buffer.Offset);
            Debug.Assert(((Buffer.Offset + fbeStructOffset + fbeStructSize) <= Buffer.Size), "Model is broken!");
            if ((Buffer.Offset + fbeStructOffset + fbeStructSize) > Buffer.Size)
                return 0;

            fbeStructSize = (uint)(8 + _model.Set(value));
            Buffer.Resize(fbeInitialSize + fbeStructSize);

            Write(_model.FBEOffset - 8, fbeStructSize);
            Write(_model.FBEOffset - 4, fbeStructType);

            return fbeStructSize;
        }

        // Deserialize the struct value
        public long Deserialize(out StructOptional value)
        {
            Debug.Assert(((Buffer.Offset + _model.FBEOffset) <= Buffer.Size), "Model is broken!");
            if ((Buffer.Offset + _model.FBEOffset) > Buffer.Size)
            {
                value = StructOptional.Default;
                return 0;
            }

            long fbeStructSize = ReadUInt32(_model.FBEOffset - 8);
            long fbeStructType = ReadUInt32(_model.FBEOffset - 4);
            Debug.Assert(((fbeStructSize > 0) && (fbeStructType == FBEType)), "Model is broken!");
            if ((fbeStructSize <= 0) || (fbeStructType != FBEType))
            {
                value = StructOptional.Default;
                return 8;
            }

            return 8 + _model.Get(out value);
        }

        // Move to the next struct value
        public void Next(long prev)
        {
            _model.FBEShift(prev);
        }
    }

} // namespace com.chronoxor.test.FBE

namespace com.chronoxor.test {

    public struct StructNested : IComparable, IComparable<StructNested>, IEquatable<StructNested>
    {
        #if UTF8JSON
        [IgnoreDataMember]
        #else
        [JsonIgnore]
        #endif
        public StructOptional parent;
        public EnumSimple f1000;
        public EnumSimple? f1001;
        public EnumTyped f1002;
        public EnumTyped? f1003;
        public FlagsSimple f1004;
        public FlagsSimple? f1005;
        public FlagsTyped f1006;
        public FlagsTyped? f1007;
        public StructSimple f1008;
        public StructSimple? f1009;
        public StructOptional f1010;
        public StructOptional? f1011;

        public const long FBETypeConst = 112;
        #if UTF8JSON
        [IgnoreDataMember]
        #else
        [JsonIgnore]
        #endif
        public long FBEType => FBETypeConst;

        public static StructNested Default => new StructNested
        {
            parent = StructOptional.Default
            , f1000 = global::com.chronoxor.test.EnumSimple.Default
            , f1001 = null
            , f1002 = global::com.chronoxor.test.EnumTyped.ENUM_VALUE_2
            , f1003 = null
            , f1004 = global::com.chronoxor.test.FlagsSimple.Default
            , f1005 = null
            , f1006 = global::com.chronoxor.test.FlagsTyped.FLAG_VALUE_2 | global::com.chronoxor.test.FlagsTyped.FLAG_VALUE_4 | global::com.chronoxor.test.FlagsTyped.FLAG_VALUE_6
            , f1007 = null
            , f1008 = global::com.chronoxor.test.StructSimple.Default
            , f1009 = null
            , f1010 = global::com.chronoxor.test.StructOptional.Default
            , f1011 = null
        };

        public StructNested(StructOptional parent, EnumSimple f1000, EnumSimple? f1001, EnumTyped f1002, EnumTyped? f1003, FlagsSimple f1004, FlagsSimple? f1005, FlagsTyped f1006, FlagsTyped? f1007, StructSimple f1008, StructSimple? f1009, StructOptional f1010, StructOptional? f1011)
        {
            this.parent = parent;
            this.f1000 = f1000;
            this.f1001 = f1001;
            this.f1002 = f1002;
            this.f1003 = f1003;
            this.f1004 = f1004;
            this.f1005 = f1005;
            this.f1006 = f1006;
            this.f1007 = f1007;
            this.f1008 = f1008;
            this.f1009 = f1009;
            this.f1010 = f1010;
            this.f1011 = f1011;
        }

        public StructNested Clone()
        {
            // Serialize the struct to the FBE stream
            var writer = new com.chronoxor.test.FBE.StructNestedModel();
            writer.Serialize(this);

            // Deserialize the struct from the FBE stream
            var reader = new com.chronoxor.test.FBE.StructNestedModel();
            reader.Attach(writer.Buffer);
            reader.Deserialize(out var result);
            return result;
        }

        public int CompareTo(object other)
        {
            int result = 0;
            result = parent.CompareTo(other);
            if (result != 0)
                return result;
            return result;
        }

        public int CompareTo(StructNested other)
        {
            int result = 0;
            result = parent.CompareTo(other);
            if (result != 0)
                return result;
            return result;
        }

        public override bool Equals(object other)
        {
            if (!(other is StructNested))
                return false;
            if (!parent.Equals(other))
                return false;
            return true;
        }

        public bool Equals(StructNested other)
        {
            if (!parent.Equals(other))
                return false;
            return true;
        }

        public override int GetHashCode()
        {
            int hash = 17;
            hash = hash * 31 + parent.GetHashCode();
            return hash;
        }

        public static bool operator==(StructNested lhs, StructNested rhs) => lhs.Equals(rhs);
        public static bool operator!=(StructNested lhs, StructNested rhs) => !(lhs == rhs);

        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("StructNested(");
            sb.Append(parent.ToString());
            sb.Append(",f1000="); sb.Append(f1000);
            sb.Append(",f1001="); if (f1001 != null) sb.Append(f1001); else sb.Append("null");
            sb.Append(",f1002="); sb.Append(f1002);
            sb.Append(",f1003="); if (f1003 != null) sb.Append(f1003); else sb.Append("null");
            sb.Append(",f1004="); sb.Append(f1004);
            sb.Append(",f1005="); if (f1005 != null) sb.Append(f1005); else sb.Append("null");
            sb.Append(",f1006="); sb.Append(f1006);
            sb.Append(",f1007="); if (f1007 != null) sb.Append(f1007); else sb.Append("null");
            sb.Append(",f1008="); sb.Append(f1008);
            sb.Append(",f1009="); if (f1009 != null) sb.Append(f1009); else sb.Append("null");
            sb.Append(",f1010="); sb.Append(f1010);
            sb.Append(",f1011="); if (f1011 != null) sb.Append(f1011); else sb.Append("null");
            sb.Append(")");
            return sb.ToString();
        }

        public string ToJson()
        {
            var json = com.chronoxor.FBE.Json.ToJson(this);
            var jsonParent = parent.ToJson();
            json = json.Substring(0, json.Length - 1) + "," + jsonParent.Substring(1, jsonParent.Length - 2) + "}";
            return json;
        }

        public static StructNested FromJson(string json)
        {
            var result = com.chronoxor.FBE.Json.FromJson<StructNested>(json);
            result.parent = StructOptional.FromJson(json);
            return result;
        }

        public static com.chronoxor.FBE.FieldModelValueType<StructNested> CreateFieldModel(com.chronoxor.FBE.Buffer buffer, long offset) { return new test.FBE.FieldModelStructNested(buffer, offset); }
    }

} // namespace com.chronoxor.test

namespace com.chronoxor.test.FBE {

    using global::com.chronoxor.test;

    // Fast Binary Encoding StructNested field model
    public class FieldModelStructNested : com.chronoxor.FBE.FieldModelValueType<StructNested>
    {
        public readonly com.chronoxor.test.FBE.FieldModelStructOptional parent;
        public readonly com.chronoxor.test.FBE.FieldModelEnumSimple f1000;
        public readonly com.chronoxor.FBE.FieldModelOptionalValueType<EnumSimple, com.chronoxor.test.FBE.FieldModelEnumSimple> f1001;
        public readonly com.chronoxor.test.FBE.FieldModelEnumTyped f1002;
        public readonly com.chronoxor.FBE.FieldModelOptionalValueType<EnumTyped, com.chronoxor.test.FBE.FieldModelEnumTyped> f1003;
        public readonly com.chronoxor.test.FBE.FieldModelFlagsSimple f1004;
        public readonly com.chronoxor.FBE.FieldModelOptionalValueType<FlagsSimple, com.chronoxor.test.FBE.FieldModelFlagsSimple> f1005;
        public readonly com.chronoxor.test.FBE.FieldModelFlagsTyped f1006;
        public readonly com.chronoxor.FBE.FieldModelOptionalValueType<FlagsTyped, com.chronoxor.test.FBE.FieldModelFlagsTyped> f1007;
        public readonly com.chronoxor.test.FBE.FieldModelStructSimple f1008;
        public readonly com.chronoxor.FBE.FieldModelOptionalValueType<StructSimple, com.chronoxor.test.FBE.FieldModelStructSimple> f1009;
        public readonly com.chronoxor.test.FBE.FieldModelStructOptional f1010;
        public readonly com.chronoxor.FBE.FieldModelOptionalValueType<StructOptional, com.chronoxor.test.FBE.FieldModelStructOptional> f1011;

        public FieldModelStructNested(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset)
        {
            parent = new com.chronoxor.test.FBE.FieldModelStructOptional(buffer, 4 + 4);
            f1000 = new com.chronoxor.test.FBE.FieldModelEnumSimple(buffer, parent.FBEOffset + parent.FBEBody - 4 - 4);
            f1001 = new com.chronoxor.FBE.FieldModelOptionalValueType<EnumSimple, com.chronoxor.test.FBE.FieldModelEnumSimple>(new com.chronoxor.test.FBE.FieldModelEnumSimple(buffer, f1000.FBEOffset + f1000.FBESize), buffer, f1000.FBEOffset + f1000.FBESize);
            f1002 = new com.chronoxor.test.FBE.FieldModelEnumTyped(buffer, f1001.FBEOffset + f1001.FBESize);
            f1003 = new com.chronoxor.FBE.FieldModelOptionalValueType<EnumTyped, com.chronoxor.test.FBE.FieldModelEnumTyped>(new com.chronoxor.test.FBE.FieldModelEnumTyped(buffer, f1002.FBEOffset + f1002.FBESize), buffer, f1002.FBEOffset + f1002.FBESize);
            f1004 = new com.chronoxor.test.FBE.FieldModelFlagsSimple(buffer, f1003.FBEOffset + f1003.FBESize);
            f1005 = new com.chronoxor.FBE.FieldModelOptionalValueType<FlagsSimple, com.chronoxor.test.FBE.FieldModelFlagsSimple>(new com.chronoxor.test.FBE.FieldModelFlagsSimple(buffer, f1004.FBEOffset + f1004.FBESize), buffer, f1004.FBEOffset + f1004.FBESize);
            f1006 = new com.chronoxor.test.FBE.FieldModelFlagsTyped(buffer, f1005.FBEOffset + f1005.FBESize);
            f1007 = new com.chronoxor.FBE.FieldModelOptionalValueType<FlagsTyped, com.chronoxor.test.FBE.FieldModelFlagsTyped>(new com.chronoxor.test.FBE.FieldModelFlagsTyped(buffer, f1006.FBEOffset + f1006.FBESize), buffer, f1006.FBEOffset + f1006.FBESize);
            f1008 = new com.chronoxor.test.FBE.FieldModelStructSimple(buffer, f1007.FBEOffset + f1007.FBESize);
            f1009 = new com.chronoxor.FBE.FieldModelOptionalValueType<StructSimple, com.chronoxor.test.FBE.FieldModelStructSimple>(new com.chronoxor.test.FBE.FieldModelStructSimple(buffer, f1008.FBEOffset + f1008.FBESize), buffer, f1008.FBEOffset + f1008.FBESize);
            f1010 = new com.chronoxor.test.FBE.FieldModelStructOptional(buffer, f1009.FBEOffset + f1009.FBESize);
            f1011 = new com.chronoxor.FBE.FieldModelOptionalValueType<StructOptional, com.chronoxor.test.FBE.FieldModelStructOptional>(new com.chronoxor.test.FBE.FieldModelStructOptional(buffer, f1010.FBEOffset + f1010.FBESize), buffer, f1010.FBEOffset + f1010.FBESize);
        }

        // Get the field size
        public override long FBESize => 4;
        // Get the field body size
        public long FBEBody
        {
            get
            {
                long fbeResult = 4 + 4
                    + parent.FBEBody - 4 - 4
                    + f1000.FBESize
                    + f1001.FBESize
                    + f1002.FBESize
                    + f1003.FBESize
                    + f1004.FBESize
                    + f1005.FBESize
                    + f1006.FBESize
                    + f1007.FBESize
                    + f1008.FBESize
                    + f1009.FBESize
                    + f1010.FBESize
                    + f1011.FBESize
                    ;
                return fbeResult;
            }
        }
        // Get the field extra size
        public override long FBEExtra
        {
            get
            {
                if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                    return 0;

                uint fbeStructOffset = ReadUInt32(FBEOffset);
                if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4) > _buffer.Size))
                    return 0;

                _buffer.Shift(fbeStructOffset);

                long fbeResult = FBEBody
                    + parent.FBEExtra
                    + f1000.FBEExtra
                    + f1001.FBEExtra
                    + f1002.FBEExtra
                    + f1003.FBEExtra
                    + f1004.FBEExtra
                    + f1005.FBEExtra
                    + f1006.FBEExtra
                    + f1007.FBEExtra
                    + f1008.FBEExtra
                    + f1009.FBEExtra
                    + f1010.FBEExtra
                    + f1011.FBEExtra
                    ;

                _buffer.Unshift(fbeStructOffset);

                return fbeResult;
            }
        }
        // Get the field type
        public const long FBETypeConst = 112;
        public long FBEType => FBETypeConst;

        // Clone the field model
        public override com.chronoxor.FBE.FieldModelValueType<StructNested> Clone() { return new FieldModelStructNested(_buffer, _offset); }

        // Check if the struct value is valid
        public override bool Verify() { return Verify(true); }
        public bool Verify(bool fbeVerifyType)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return true;

            uint fbeStructOffset = ReadUInt32(FBEOffset);
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
                return false;

            uint fbeStructSize = ReadUInt32(fbeStructOffset);
            if (fbeStructSize < (4 + 4))
                return false;

            uint fbeStructType = ReadUInt32(fbeStructOffset + 4);
            if (fbeVerifyType && (fbeStructType != FBEType))
                return false;

            _buffer.Shift(fbeStructOffset);
            bool fbeResult = VerifyFields(fbeStructSize);
            _buffer.Unshift(fbeStructOffset);
            return fbeResult;
        }

        // Check if the struct fields are valid
        public bool VerifyFields(long fbeStructSize)
        {
            long fbeCurrentSize = 4 + 4;

            if ((fbeCurrentSize + parent.FBEBody - 4 - 4) > fbeStructSize)
                return true;
            if (!parent.VerifyFields(fbeStructSize))
                return false;
            fbeCurrentSize += parent.FBEBody - 4 - 4;

            if ((fbeCurrentSize + f1000.FBESize) > fbeStructSize)
                return true;
            if (!f1000.Verify())
                return false;
            fbeCurrentSize += f1000.FBESize;

            if ((fbeCurrentSize + f1001.FBESize) > fbeStructSize)
                return true;
            if (!f1001.Verify())
                return false;
            fbeCurrentSize += f1001.FBESize;

            if ((fbeCurrentSize + f1002.FBESize) > fbeStructSize)
                return true;
            if (!f1002.Verify())
                return false;
            fbeCurrentSize += f1002.FBESize;

            if ((fbeCurrentSize + f1003.FBESize) > fbeStructSize)
                return true;
            if (!f1003.Verify())
                return false;
            fbeCurrentSize += f1003.FBESize;

            if ((fbeCurrentSize + f1004.FBESize) > fbeStructSize)
                return true;
            if (!f1004.Verify())
                return false;
            fbeCurrentSize += f1004.FBESize;

            if ((fbeCurrentSize + f1005.FBESize) > fbeStructSize)
                return true;
            if (!f1005.Verify())
                return false;
            fbeCurrentSize += f1005.FBESize;

            if ((fbeCurrentSize + f1006.FBESize) > fbeStructSize)
                return true;
            if (!f1006.Verify())
                return false;
            fbeCurrentSize += f1006.FBESize;

            if ((fbeCurrentSize + f1007.FBESize) > fbeStructSize)
                return true;
            if (!f1007.Verify())
                return false;
            fbeCurrentSize += f1007.FBESize;

            if ((fbeCurrentSize + f1008.FBESize) > fbeStructSize)
                return true;
            if (!f1008.Verify())
                return false;
            fbeCurrentSize += f1008.FBESize;

            if ((fbeCurrentSize + f1009.FBESize) > fbeStructSize)
                return true;
            if (!f1009.Verify())
                return false;
            fbeCurrentSize += f1009.FBESize;

            if ((fbeCurrentSize + f1010.FBESize) > fbeStructSize)
                return true;
            if (!f1010.Verify())
                return false;
            fbeCurrentSize += f1010.FBESize;

            if ((fbeCurrentSize + f1011.FBESize) > fbeStructSize)
                return true;
            if (!f1011.Verify())
                return false;
            fbeCurrentSize += f1011.FBESize;

            return true;
        }

        // Get the struct value (begin phase)
        public long GetBegin()
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            uint fbeStructOffset = ReadUInt32(FBEOffset);
            Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + 4 + 4) <= _buffer.Size)), "Model is broken!");
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
                return 0;

            uint fbeStructSize = ReadUInt32(fbeStructOffset);
            Debug.Assert((fbeStructSize >= (4 + 4)), "Model is broken!");
            if (fbeStructSize < (4 + 4))
                return 0;

            _buffer.Shift(fbeStructOffset);
            return fbeStructOffset;
        }

        // Get the struct value (end phase)
        public void GetEnd(long fbeBegin)
        {
            _buffer.Unshift(fbeBegin);
        }

        // Get the struct value
        public override void Get(out StructNested fbeValue) { Get(out fbeValue, StructNested.Default); }
        public override void Get(out StructNested fbeValue, StructNested defaults)
        {
            long fbeBegin = GetBegin();
            if (fbeBegin == 0)
            {
                fbeValue = defaults;
                return;
            }

            uint fbeStructSize = ReadUInt32(0);
            GetFields(out fbeValue, fbeStructSize);
            GetEnd(fbeBegin);
        }

        // Get the struct fields values
        public void GetFields(out StructNested fbeValue, long fbeStructSize)
        {
            long fbeCurrentSize = 4 + 4;

            fbeValue = StructNested.Default;

            if ((fbeCurrentSize + parent.FBEBody - 4 - 4) <= fbeStructSize)
                parent.GetFields(out fbeValue.parent, fbeStructSize);
            fbeCurrentSize += parent.FBEBody - 4 - 4;

            if ((fbeCurrentSize + f1000.FBESize) <= fbeStructSize)
                f1000.Get(out fbeValue.f1000);
            else
                fbeValue.f1000 = global::com.chronoxor.test.EnumSimple.Default;
            fbeCurrentSize += f1000.FBESize;

            if ((fbeCurrentSize + f1001.FBESize) <= fbeStructSize)
                f1001.Get(out fbeValue.f1001);
            else
                fbeValue.f1001 = null;
            fbeCurrentSize += f1001.FBESize;

            if ((fbeCurrentSize + f1002.FBESize) <= fbeStructSize)
                f1002.Get(out fbeValue.f1002, global::com.chronoxor.test.EnumTyped.ENUM_VALUE_2);
            else
                fbeValue.f1002 = global::com.chronoxor.test.EnumTyped.ENUM_VALUE_2;
            fbeCurrentSize += f1002.FBESize;

            if ((fbeCurrentSize + f1003.FBESize) <= fbeStructSize)
                f1003.Get(out fbeValue.f1003, null);
            else
                fbeValue.f1003 = null;
            fbeCurrentSize += f1003.FBESize;

            if ((fbeCurrentSize + f1004.FBESize) <= fbeStructSize)
                f1004.Get(out fbeValue.f1004);
            else
                fbeValue.f1004 = global::com.chronoxor.test.FlagsSimple.Default;
            fbeCurrentSize += f1004.FBESize;

            if ((fbeCurrentSize + f1005.FBESize) <= fbeStructSize)
                f1005.Get(out fbeValue.f1005);
            else
                fbeValue.f1005 = null;
            fbeCurrentSize += f1005.FBESize;

            if ((fbeCurrentSize + f1006.FBESize) <= fbeStructSize)
                f1006.Get(out fbeValue.f1006, global::com.chronoxor.test.FlagsTyped.FLAG_VALUE_2 | global::com.chronoxor.test.FlagsTyped.FLAG_VALUE_4 | global::com.chronoxor.test.FlagsTyped.FLAG_VALUE_6);
            else
                fbeValue.f1006 = global::com.chronoxor.test.FlagsTyped.FLAG_VALUE_2 | global::com.chronoxor.test.FlagsTyped.FLAG_VALUE_4 | global::com.chronoxor.test.FlagsTyped.FLAG_VALUE_6;
            fbeCurrentSize += f1006.FBESize;

            if ((fbeCurrentSize + f1007.FBESize) <= fbeStructSize)
                f1007.Get(out fbeValue.f1007, null);
            else
                fbeValue.f1007 = null;
            fbeCurrentSize += f1007.FBESize;

            if ((fbeCurrentSize + f1008.FBESize) <= fbeStructSize)
                f1008.Get(out fbeValue.f1008);
            else
                fbeValue.f1008 = global::com.chronoxor.test.StructSimple.Default;
            fbeCurrentSize += f1008.FBESize;

            if ((fbeCurrentSize + f1009.FBESize) <= fbeStructSize)
                f1009.Get(out fbeValue.f1009);
            else
                fbeValue.f1009 = null;
            fbeCurrentSize += f1009.FBESize;

            if ((fbeCurrentSize + f1010.FBESize) <= fbeStructSize)
                f1010.Get(out fbeValue.f1010);
            else
                fbeValue.f1010 = global::com.chronoxor.test.StructOptional.Default;
            fbeCurrentSize += f1010.FBESize;

            if ((fbeCurrentSize + f1011.FBESize) <= fbeStructSize)
                f1011.Get(out fbeValue.f1011, null);
            else
                fbeValue.f1011 = null;
            fbeCurrentSize += f1011.FBESize;
        }

        // Set the struct value (begin phase)
        public long SetBegin()
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            uint fbeStructSize = (uint)FBEBody;
            uint fbeStructOffset = (uint)(_buffer.Allocate(fbeStructSize) - _buffer.Offset);
            Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + fbeStructSize) <= _buffer.Size)), "Model is broken!");
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + fbeStructSize) > _buffer.Size))
                return 0;

            Write(FBEOffset, fbeStructOffset);
            Write(fbeStructOffset, fbeStructSize);
            Write(fbeStructOffset + 4, (uint)FBEType);

            _buffer.Shift(fbeStructOffset);
            return fbeStructOffset;
        }

        // Set the struct value (end phase)
        public void SetEnd(long fbeBegin)
        {
            _buffer.Unshift(fbeBegin);
        }

        // Set the struct value
        public override void Set(StructNested fbeValue)
        {
            long fbeBegin = SetBegin();
            if (fbeBegin == 0)
                return;

            SetFields(fbeValue);
            SetEnd(fbeBegin);
        }

        // Set the struct fields values
        public void SetFields(StructNested fbeValue)
        {
            parent.SetFields(fbeValue.parent);
            f1000.Set(fbeValue.f1000);
            f1001.Set(fbeValue.f1001);
            f1002.Set(fbeValue.f1002);
            f1003.Set(fbeValue.f1003);
            f1004.Set(fbeValue.f1004);
            f1005.Set(fbeValue.f1005);
            f1006.Set(fbeValue.f1006);
            f1007.Set(fbeValue.f1007);
            f1008.Set(fbeValue.f1008);
            f1009.Set(fbeValue.f1009);
            f1010.Set(fbeValue.f1010);
            f1011.Set(fbeValue.f1011);
        }
    }

} // namespace com.chronoxor.test.FBE

namespace com.chronoxor.test.FBE {

    using global::com.chronoxor.test;

    // Fast Binary Encoding StructNested model
    public class StructNestedModel : com.chronoxor.FBE.Model
    {
        public readonly FieldModelStructNested model;

        public StructNestedModel() { model = new FieldModelStructNested(Buffer, 4); }
        public StructNestedModel(com.chronoxor.FBE.Buffer buffer) : base(buffer) { model = new FieldModelStructNested(Buffer, 4); }

        // Get the model size
        public long FBESize => model.FBESize + model.FBEExtra;
        // Get the model type
        public const long FBETypeConst = FieldModelStructNested.FBETypeConst;
        public long FBEType => FBETypeConst;

        // Check if the struct value is valid
        public bool Verify()
        {
            if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
                return false;

            uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
            if (fbeFullSize < model.FBESize)
                return false;

            return model.Verify();
        }

        // Create a new model (begin phase)
        public long CreateBegin()
        {
            long fbeBegin = Buffer.Allocate(4 + model.FBESize);
            return fbeBegin;
        }

        // Create a new model (end phase)
        public long CreateEnd(long fbeBegin)
        {
            long fbeEnd = Buffer.Size;
            uint fbeFullSize = (uint)(fbeEnd - fbeBegin);
            Write(model.FBEOffset - 4, fbeFullSize);
            return fbeFullSize;
        }

        // Serialize the struct value
        public long Serialize(StructNested value)
        {
            long fbeBegin = CreateBegin();
            model.Set(value);
            long fbeFullSize = CreateEnd(fbeBegin);
            return fbeFullSize;
        }

        // Deserialize the struct value
        public long Deserialize(out StructNested value)
        {
            if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
            {
                value = StructNested.Default;
                return 0;
            }

            uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
            Debug.Assert((fbeFullSize >= model.FBESize), "Model is broken!");
            if (fbeFullSize < model.FBESize)
            {
                value = StructNested.Default;
                return 0;
            }

            model.Get(out value);
            return fbeFullSize;
        }

        // Move to the next struct value
        public void Next(long prev)
        {
            model.FBEShift(prev);
        }
    }

} // namespace com.chronoxor.test.FBE

namespace com.chronoxor.test.FBE {

    using global::com.chronoxor.test;

    // Fast Binary Encoding StructNested final model
    public class FinalModelStructNested : com.chronoxor.FBE.FinalModelValueType<StructNested>
    {
        public readonly com.chronoxor.test.FBE.FinalModelStructOptional parent;
        public readonly com.chronoxor.test.FBE.FinalModelEnumSimple f1000;
        public readonly com.chronoxor.FBE.FinalModelOptionalValueType<EnumSimple, com.chronoxor.test.FBE.FinalModelEnumSimple> f1001;
        public readonly com.chronoxor.test.FBE.FinalModelEnumTyped f1002;
        public readonly com.chronoxor.FBE.FinalModelOptionalValueType<EnumTyped, com.chronoxor.test.FBE.FinalModelEnumTyped> f1003;
        public readonly com.chronoxor.test.FBE.FinalModelFlagsSimple f1004;
        public readonly com.chronoxor.FBE.FinalModelOptionalValueType<FlagsSimple, com.chronoxor.test.FBE.FinalModelFlagsSimple> f1005;
        public readonly com.chronoxor.test.FBE.FinalModelFlagsTyped f1006;
        public readonly com.chronoxor.FBE.FinalModelOptionalValueType<FlagsTyped, com.chronoxor.test.FBE.FinalModelFlagsTyped> f1007;
        public readonly com.chronoxor.test.FBE.FinalModelStructSimple f1008;
        public readonly com.chronoxor.FBE.FinalModelOptionalValueType<StructSimple, com.chronoxor.test.FBE.FinalModelStructSimple> f1009;
        public readonly com.chronoxor.test.FBE.FinalModelStructOptional f1010;
        public readonly com.chronoxor.FBE.FinalModelOptionalValueType<StructOptional, com.chronoxor.test.FBE.FinalModelStructOptional> f1011;

        public FinalModelStructNested(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset)
        {
            parent = new com.chronoxor.test.FBE.FinalModelStructOptional(buffer, 0);
            f1000 = new com.chronoxor.test.FBE.FinalModelEnumSimple(buffer, 0);
            f1001 = new com.chronoxor.FBE.FinalModelOptionalValueType<EnumSimple, com.chronoxor.test.FBE.FinalModelEnumSimple>(new com.chronoxor.test.FBE.FinalModelEnumSimple(buffer, 0), buffer, 0);
            f1002 = new com.chronoxor.test.FBE.FinalModelEnumTyped(buffer, 0);
            f1003 = new com.chronoxor.FBE.FinalModelOptionalValueType<EnumTyped, com.chronoxor.test.FBE.FinalModelEnumTyped>(new com.chronoxor.test.FBE.FinalModelEnumTyped(buffer, 0), buffer, 0);
            f1004 = new com.chronoxor.test.FBE.FinalModelFlagsSimple(buffer, 0);
            f1005 = new com.chronoxor.FBE.FinalModelOptionalValueType<FlagsSimple, com.chronoxor.test.FBE.FinalModelFlagsSimple>(new com.chronoxor.test.FBE.FinalModelFlagsSimple(buffer, 0), buffer, 0);
            f1006 = new com.chronoxor.test.FBE.FinalModelFlagsTyped(buffer, 0);
            f1007 = new com.chronoxor.FBE.FinalModelOptionalValueType<FlagsTyped, com.chronoxor.test.FBE.FinalModelFlagsTyped>(new com.chronoxor.test.FBE.FinalModelFlagsTyped(buffer, 0), buffer, 0);
            f1008 = new com.chronoxor.test.FBE.FinalModelStructSimple(buffer, 0);
            f1009 = new com.chronoxor.FBE.FinalModelOptionalValueType<StructSimple, com.chronoxor.test.FBE.FinalModelStructSimple>(new com.chronoxor.test.FBE.FinalModelStructSimple(buffer, 0), buffer, 0);
            f1010 = new com.chronoxor.test.FBE.FinalModelStructOptional(buffer, 0);
            f1011 = new com.chronoxor.FBE.FinalModelOptionalValueType<StructOptional, com.chronoxor.test.FBE.FinalModelStructOptional>(new com.chronoxor.test.FBE.FinalModelStructOptional(buffer, 0), buffer, 0);
        }

        // Get the allocation size
        public override long FBEAllocationSize(StructNested fbeValue)
        {
            long fbeResult = 0
                + parent.FBEAllocationSize(fbeValue.parent)
                + f1000.FBEAllocationSize(fbeValue.f1000)
                + f1001.FBEAllocationSize(fbeValue.f1001)
                + f1002.FBEAllocationSize(fbeValue.f1002)
                + f1003.FBEAllocationSize(fbeValue.f1003)
                + f1004.FBEAllocationSize(fbeValue.f1004)
                + f1005.FBEAllocationSize(fbeValue.f1005)
                + f1006.FBEAllocationSize(fbeValue.f1006)
                + f1007.FBEAllocationSize(fbeValue.f1007)
                + f1008.FBEAllocationSize(fbeValue.f1008)
                + f1009.FBEAllocationSize(fbeValue.f1009)
                + f1010.FBEAllocationSize(fbeValue.f1010)
                + f1011.FBEAllocationSize(fbeValue.f1011)
                ;
            return fbeResult;
        }

        // Get the final type
        public const long FBETypeConst = 112;
        public long FBEType => FBETypeConst;

        // Clone the final model
        public override com.chronoxor.FBE.FinalModelValueType<StructNested> Clone() { return new FinalModelStructNested(_buffer, _offset); }

        // Check if the struct value is valid
        public override long Verify()
        {
            _buffer.Shift(FBEOffset);
            long fbeResult = VerifyFields();
            _buffer.Unshift(FBEOffset);
            return fbeResult;
        }

        // Check if the struct fields are valid
        public long VerifyFields()
        {
            long fbeCurrentOffset = 0;
            long fbeFieldSize;

            parent.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = parent.VerifyFields();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f1000.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f1000.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f1001.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f1001.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f1002.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f1002.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f1003.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f1003.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f1004.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f1004.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f1005.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f1005.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f1006.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f1006.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f1007.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f1007.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f1008.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f1008.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f1009.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f1009.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f1010.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f1010.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f1011.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f1011.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            return fbeCurrentOffset;
        }

        // Get the struct value
        public override long Get(out StructNested fbeValue)
        {
            _buffer.Shift(FBEOffset);
            long fbeSize = GetFields(out fbeValue);
            _buffer.Unshift(FBEOffset);
            return fbeSize;
        }

        // Get the struct fields values
        public long GetFields(out StructNested fbeValue)
        {
            long fbeCurrentOffset = 0;
            long fbeCurrentSize = 0;
            long fbeFieldSize;

            fbeValue = StructNested.Default;

            parent.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = parent.GetFields(out fbeValue.parent);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f1000.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f1000.Get(out fbeValue.f1000);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f1001.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f1001.Get(out fbeValue.f1001);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f1002.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f1002.Get(out fbeValue.f1002);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f1003.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f1003.Get(out fbeValue.f1003);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f1004.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f1004.Get(out fbeValue.f1004);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f1005.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f1005.Get(out fbeValue.f1005);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f1006.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f1006.Get(out fbeValue.f1006);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f1007.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f1007.Get(out fbeValue.f1007);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f1008.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f1008.Get(out fbeValue.f1008);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f1009.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f1009.Get(out fbeValue.f1009);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f1010.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f1010.Get(out fbeValue.f1010);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f1011.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f1011.Get(out fbeValue.f1011);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            return fbeCurrentSize;
        }

        // Set the struct value
        public override long Set(StructNested fbeValue)
        {
            _buffer.Shift(FBEOffset);
            long fbeResult = SetFields(fbeValue);
            _buffer.Unshift(FBEOffset);
            return fbeResult;
        }

        // Set the struct fields values
        public long SetFields(StructNested fbeValue)
        {
            long fbeCurrentOffset = 0;
            long fbeCurrentSize = 0;
            long fbeFieldSize;

            parent.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = parent.SetFields(fbeValue.parent);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f1000.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f1000.Set(fbeValue.f1000);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f1001.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f1001.Set(fbeValue.f1001);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f1002.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f1002.Set(fbeValue.f1002);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f1003.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f1003.Set(fbeValue.f1003);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f1004.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f1004.Set(fbeValue.f1004);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f1005.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f1005.Set(fbeValue.f1005);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f1006.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f1006.Set(fbeValue.f1006);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f1007.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f1007.Set(fbeValue.f1007);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f1008.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f1008.Set(fbeValue.f1008);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f1009.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f1009.Set(fbeValue.f1009);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f1010.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f1010.Set(fbeValue.f1010);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f1011.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f1011.Set(fbeValue.f1011);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            return fbeCurrentSize;
        }
    }

} // namespace com.chronoxor.test.FBE

namespace com.chronoxor.test.FBE {

    using global::com.chronoxor.test;

    // Fast Binary Encoding StructNested final model
    public class StructNestedFinalModel : com.chronoxor.FBE.Model
    {
        private readonly FinalModelStructNested _model;

        public StructNestedFinalModel() { _model = new FinalModelStructNested(Buffer, 8); }
        public StructNestedFinalModel(com.chronoxor.FBE.Buffer buffer) : base(buffer) { _model = new FinalModelStructNested(Buffer, 8); }

        // Get the model type
        public const long FBETypeConst = FinalModelStructNested.FBETypeConst;
        public long FBEType => FBETypeConst;

        // Check if the struct value is valid
        public bool Verify()
        {
            if ((Buffer.Offset + _model.FBEOffset) > Buffer.Size)
                return false;

            long fbeStructSize = ReadUInt32(_model.FBEOffset - 8);
            long fbeStructType = ReadUInt32(_model.FBEOffset - 4);
            if ((fbeStructSize <= 0) || (fbeStructType != FBEType))
                return false;

            return ((8 + _model.Verify()) == fbeStructSize);
        }

        // Serialize the struct value
        public long Serialize(StructNested value)
        {
            long fbeInitialSize = Buffer.Size;

            uint fbeStructType = (uint)FBEType;
            uint fbeStructSize = (uint)(8 + _model.FBEAllocationSize(value));
            uint fbeStructOffset = (uint)(Buffer.Allocate(fbeStructSize) - Buffer.Offset);
            Debug.Assert(((Buffer.Offset + fbeStructOffset + fbeStructSize) <= Buffer.Size), "Model is broken!");
            if ((Buffer.Offset + fbeStructOffset + fbeStructSize) > Buffer.Size)
                return 0;

            fbeStructSize = (uint)(8 + _model.Set(value));
            Buffer.Resize(fbeInitialSize + fbeStructSize);

            Write(_model.FBEOffset - 8, fbeStructSize);
            Write(_model.FBEOffset - 4, fbeStructType);

            return fbeStructSize;
        }

        // Deserialize the struct value
        public long Deserialize(out StructNested value)
        {
            Debug.Assert(((Buffer.Offset + _model.FBEOffset) <= Buffer.Size), "Model is broken!");
            if ((Buffer.Offset + _model.FBEOffset) > Buffer.Size)
            {
                value = StructNested.Default;
                return 0;
            }

            long fbeStructSize = ReadUInt32(_model.FBEOffset - 8);
            long fbeStructType = ReadUInt32(_model.FBEOffset - 4);
            Debug.Assert(((fbeStructSize > 0) && (fbeStructType == FBEType)), "Model is broken!");
            if ((fbeStructSize <= 0) || (fbeStructType != FBEType))
            {
                value = StructNested.Default;
                return 8;
            }

            return 8 + _model.Get(out value);
        }

        // Move to the next struct value
        public void Next(long prev)
        {
            _model.FBEShift(prev);
        }
    }

} // namespace com.chronoxor.test.FBE

namespace com.chronoxor.test {

    public struct StructBytes : IComparable, IComparable<StructBytes>, IEquatable<StructBytes>
    {
        public MemoryStream f1;
        public MemoryStream f2;
        public MemoryStream f3;

        public const long FBETypeConst = 120;
        #if UTF8JSON
        [IgnoreDataMember]
        #else
        [JsonIgnore]
        #endif
        public long FBEType => FBETypeConst;

        public static StructBytes Default => new StructBytes
        {
            f1 = new MemoryStream()
            , f2 = null
            , f3 = null
        };

        public StructBytes(MemoryStream f1, MemoryStream f2, MemoryStream f3)
        {
            this.f1 = f1;
            this.f2 = f2;
            this.f3 = f3;
        }

        public StructBytes Clone()
        {
            // Serialize the struct to the FBE stream
            var writer = new com.chronoxor.test.FBE.StructBytesModel();
            writer.Serialize(this);

            // Deserialize the struct from the FBE stream
            var reader = new com.chronoxor.test.FBE.StructBytesModel();
            reader.Attach(writer.Buffer);
            reader.Deserialize(out var result);
            return result;
        }

        public int CompareTo(object other)
        {
            int result = 0;
            return result;
        }

        public int CompareTo(StructBytes other)
        {
            int result = 0;
            return result;
        }

        public override bool Equals(object other)
        {
            if (!(other is StructBytes))
                return false;
            return true;
        }

        public bool Equals(StructBytes other)
        {
            return true;
        }

        public override int GetHashCode()
        {
            int hash = 17;
            return hash;
        }

        public static bool operator==(StructBytes lhs, StructBytes rhs) => lhs.Equals(rhs);
        public static bool operator!=(StructBytes lhs, StructBytes rhs) => !(lhs == rhs);

        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("StructBytes(");
            sb.Append("f1="); if (f1 != null) sb.Append("bytes[").Append(f1.Length).Append("]"); else sb.Append("null");
            sb.Append(",f2="); if (f2 != null) sb.Append("bytes[").Append(f2.Length).Append("]"); else sb.Append("null");
            sb.Append(",f3="); if (f3 != null) sb.Append("bytes[").Append(f3.Length).Append("]"); else sb.Append("null");
            sb.Append(")");
            return sb.ToString();
        }

        public string ToJson()
        {
            var json = com.chronoxor.FBE.Json.ToJson(this);
            return json;
        }

        public static StructBytes FromJson(string json)
        {
            var result = com.chronoxor.FBE.Json.FromJson<StructBytes>(json);
            return result;
        }

        public static com.chronoxor.FBE.FieldModelValueType<StructBytes> CreateFieldModel(com.chronoxor.FBE.Buffer buffer, long offset) { return new test.FBE.FieldModelStructBytes(buffer, offset); }
    }

} // namespace com.chronoxor.test

namespace com.chronoxor.test.FBE {

    using global::com.chronoxor.test;

    // Fast Binary Encoding StructBytes field model
    public class FieldModelStructBytes : com.chronoxor.FBE.FieldModelValueType<StructBytes>
    {
        public readonly com.chronoxor.FBE.FieldModelReferenceType<MemoryStream> f1;
        public readonly com.chronoxor.FBE.FieldModelOptionalReferenceType<MemoryStream, com.chronoxor.FBE.FieldModelReferenceType<MemoryStream>> f2;
        public readonly com.chronoxor.FBE.FieldModelOptionalReferenceType<MemoryStream, com.chronoxor.FBE.FieldModelReferenceType<MemoryStream>> f3;

        public FieldModelStructBytes(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset)
        {
            f1 = com.chronoxor.FBE.FieldModelReferenceType<MemoryStream>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.BYTES, buffer, 4 + 4);
            f2 = new com.chronoxor.FBE.FieldModelOptionalReferenceType<MemoryStream, com.chronoxor.FBE.FieldModelReferenceType<MemoryStream>>(com.chronoxor.FBE.FieldModelReferenceType<MemoryStream>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.BYTES, buffer, f1.FBEOffset + f1.FBESize), buffer, f1.FBEOffset + f1.FBESize);
            f3 = new com.chronoxor.FBE.FieldModelOptionalReferenceType<MemoryStream, com.chronoxor.FBE.FieldModelReferenceType<MemoryStream>>(com.chronoxor.FBE.FieldModelReferenceType<MemoryStream>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.BYTES, buffer, f2.FBEOffset + f2.FBESize), buffer, f2.FBEOffset + f2.FBESize);
        }

        // Get the field size
        public override long FBESize => 4;
        // Get the field body size
        public long FBEBody
        {
            get
            {
                long fbeResult = 4 + 4
                    + f1.FBESize
                    + f2.FBESize
                    + f3.FBESize
                    ;
                return fbeResult;
            }
        }
        // Get the field extra size
        public override long FBEExtra
        {
            get
            {
                if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                    return 0;

                uint fbeStructOffset = ReadUInt32(FBEOffset);
                if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4) > _buffer.Size))
                    return 0;

                _buffer.Shift(fbeStructOffset);

                long fbeResult = FBEBody
                    + f1.FBEExtra
                    + f2.FBEExtra
                    + f3.FBEExtra
                    ;

                _buffer.Unshift(fbeStructOffset);

                return fbeResult;
            }
        }
        // Get the field type
        public const long FBETypeConst = 120;
        public long FBEType => FBETypeConst;

        // Clone the field model
        public override com.chronoxor.FBE.FieldModelValueType<StructBytes> Clone() { return new FieldModelStructBytes(_buffer, _offset); }

        // Check if the struct value is valid
        public override bool Verify() { return Verify(true); }
        public bool Verify(bool fbeVerifyType)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return true;

            uint fbeStructOffset = ReadUInt32(FBEOffset);
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
                return false;

            uint fbeStructSize = ReadUInt32(fbeStructOffset);
            if (fbeStructSize < (4 + 4))
                return false;

            uint fbeStructType = ReadUInt32(fbeStructOffset + 4);
            if (fbeVerifyType && (fbeStructType != FBEType))
                return false;

            _buffer.Shift(fbeStructOffset);
            bool fbeResult = VerifyFields(fbeStructSize);
            _buffer.Unshift(fbeStructOffset);
            return fbeResult;
        }

        // Check if the struct fields are valid
        public bool VerifyFields(long fbeStructSize)
        {
            long fbeCurrentSize = 4 + 4;

            if ((fbeCurrentSize + f1.FBESize) > fbeStructSize)
                return true;
            if (!f1.Verify())
                return false;
            fbeCurrentSize += f1.FBESize;

            if ((fbeCurrentSize + f2.FBESize) > fbeStructSize)
                return true;
            if (!f2.Verify())
                return false;
            fbeCurrentSize += f2.FBESize;

            if ((fbeCurrentSize + f3.FBESize) > fbeStructSize)
                return true;
            if (!f3.Verify())
                return false;
            fbeCurrentSize += f3.FBESize;

            return true;
        }

        // Get the struct value (begin phase)
        public long GetBegin()
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            uint fbeStructOffset = ReadUInt32(FBEOffset);
            Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + 4 + 4) <= _buffer.Size)), "Model is broken!");
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
                return 0;

            uint fbeStructSize = ReadUInt32(fbeStructOffset);
            Debug.Assert((fbeStructSize >= (4 + 4)), "Model is broken!");
            if (fbeStructSize < (4 + 4))
                return 0;

            _buffer.Shift(fbeStructOffset);
            return fbeStructOffset;
        }

        // Get the struct value (end phase)
        public void GetEnd(long fbeBegin)
        {
            _buffer.Unshift(fbeBegin);
        }

        // Get the struct value
        public override void Get(out StructBytes fbeValue) { Get(out fbeValue, StructBytes.Default); }
        public override void Get(out StructBytes fbeValue, StructBytes defaults)
        {
            long fbeBegin = GetBegin();
            if (fbeBegin == 0)
            {
                fbeValue = defaults;
                return;
            }

            uint fbeStructSize = ReadUInt32(0);
            GetFields(out fbeValue, fbeStructSize);
            GetEnd(fbeBegin);
        }

        // Get the struct fields values
        public void GetFields(out StructBytes fbeValue, long fbeStructSize)
        {
            long fbeCurrentSize = 4 + 4;

            fbeValue = StructBytes.Default;

            if ((fbeCurrentSize + f1.FBESize) <= fbeStructSize)
                f1.Get(out fbeValue.f1);
            else
                fbeValue.f1 = new MemoryStream();
            fbeCurrentSize += f1.FBESize;

            if ((fbeCurrentSize + f2.FBESize) <= fbeStructSize)
                f2.Get(out fbeValue.f2);
            else
                fbeValue.f2 = null;
            fbeCurrentSize += f2.FBESize;

            if ((fbeCurrentSize + f3.FBESize) <= fbeStructSize)
                f3.Get(out fbeValue.f3, null);
            else
                fbeValue.f3 = null;
            fbeCurrentSize += f3.FBESize;
        }

        // Set the struct value (begin phase)
        public long SetBegin()
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            uint fbeStructSize = (uint)FBEBody;
            uint fbeStructOffset = (uint)(_buffer.Allocate(fbeStructSize) - _buffer.Offset);
            Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + fbeStructSize) <= _buffer.Size)), "Model is broken!");
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + fbeStructSize) > _buffer.Size))
                return 0;

            Write(FBEOffset, fbeStructOffset);
            Write(fbeStructOffset, fbeStructSize);
            Write(fbeStructOffset + 4, (uint)FBEType);

            _buffer.Shift(fbeStructOffset);
            return fbeStructOffset;
        }

        // Set the struct value (end phase)
        public void SetEnd(long fbeBegin)
        {
            _buffer.Unshift(fbeBegin);
        }

        // Set the struct value
        public override void Set(StructBytes fbeValue)
        {
            long fbeBegin = SetBegin();
            if (fbeBegin == 0)
                return;

            SetFields(fbeValue);
            SetEnd(fbeBegin);
        }

        // Set the struct fields values
        public void SetFields(StructBytes fbeValue)
        {
            f1.Set(fbeValue.f1);
            f2.Set(fbeValue.f2);
            f3.Set(fbeValue.f3);
        }
    }

} // namespace com.chronoxor.test.FBE

namespace com.chronoxor.test.FBE {

    using global::com.chronoxor.test;

    // Fast Binary Encoding StructBytes model
    public class StructBytesModel : com.chronoxor.FBE.Model
    {
        public readonly FieldModelStructBytes model;

        public StructBytesModel() { model = new FieldModelStructBytes(Buffer, 4); }
        public StructBytesModel(com.chronoxor.FBE.Buffer buffer) : base(buffer) { model = new FieldModelStructBytes(Buffer, 4); }

        // Get the model size
        public long FBESize => model.FBESize + model.FBEExtra;
        // Get the model type
        public const long FBETypeConst = FieldModelStructBytes.FBETypeConst;
        public long FBEType => FBETypeConst;

        // Check if the struct value is valid
        public bool Verify()
        {
            if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
                return false;

            uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
            if (fbeFullSize < model.FBESize)
                return false;

            return model.Verify();
        }

        // Create a new model (begin phase)
        public long CreateBegin()
        {
            long fbeBegin = Buffer.Allocate(4 + model.FBESize);
            return fbeBegin;
        }

        // Create a new model (end phase)
        public long CreateEnd(long fbeBegin)
        {
            long fbeEnd = Buffer.Size;
            uint fbeFullSize = (uint)(fbeEnd - fbeBegin);
            Write(model.FBEOffset - 4, fbeFullSize);
            return fbeFullSize;
        }

        // Serialize the struct value
        public long Serialize(StructBytes value)
        {
            long fbeBegin = CreateBegin();
            model.Set(value);
            long fbeFullSize = CreateEnd(fbeBegin);
            return fbeFullSize;
        }

        // Deserialize the struct value
        public long Deserialize(out StructBytes value)
        {
            if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
            {
                value = StructBytes.Default;
                return 0;
            }

            uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
            Debug.Assert((fbeFullSize >= model.FBESize), "Model is broken!");
            if (fbeFullSize < model.FBESize)
            {
                value = StructBytes.Default;
                return 0;
            }

            model.Get(out value);
            return fbeFullSize;
        }

        // Move to the next struct value
        public void Next(long prev)
        {
            model.FBEShift(prev);
        }
    }

} // namespace com.chronoxor.test.FBE

namespace com.chronoxor.test.FBE {

    using global::com.chronoxor.test;

    // Fast Binary Encoding StructBytes final model
    public class FinalModelStructBytes : com.chronoxor.FBE.FinalModelValueType<StructBytes>
    {
        public readonly com.chronoxor.FBE.FinalModelReferenceType<MemoryStream> f1;
        public readonly com.chronoxor.FBE.FinalModelOptionalReferenceType<MemoryStream, com.chronoxor.FBE.FinalModelReferenceType<MemoryStream>> f2;
        public readonly com.chronoxor.FBE.FinalModelOptionalReferenceType<MemoryStream, com.chronoxor.FBE.FinalModelReferenceType<MemoryStream>> f3;

        public FinalModelStructBytes(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset)
        {
            f1 = com.chronoxor.FBE.FinalModelReferenceType<MemoryStream>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.BYTES, buffer, 0);
            f2 = new com.chronoxor.FBE.FinalModelOptionalReferenceType<MemoryStream, com.chronoxor.FBE.FinalModelReferenceType<MemoryStream>>(com.chronoxor.FBE.FinalModelReferenceType<MemoryStream>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.BYTES, buffer, 0), buffer, 0);
            f3 = new com.chronoxor.FBE.FinalModelOptionalReferenceType<MemoryStream, com.chronoxor.FBE.FinalModelReferenceType<MemoryStream>>(com.chronoxor.FBE.FinalModelReferenceType<MemoryStream>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.BYTES, buffer, 0), buffer, 0);
        }

        // Get the allocation size
        public override long FBEAllocationSize(StructBytes fbeValue)
        {
            long fbeResult = 0
                + f1.FBEAllocationSize(fbeValue.f1)
                + f2.FBEAllocationSize(fbeValue.f2)
                + f3.FBEAllocationSize(fbeValue.f3)
                ;
            return fbeResult;
        }

        // Get the final type
        public const long FBETypeConst = 120;
        public long FBEType => FBETypeConst;

        // Clone the final model
        public override com.chronoxor.FBE.FinalModelValueType<StructBytes> Clone() { return new FinalModelStructBytes(_buffer, _offset); }

        // Check if the struct value is valid
        public override long Verify()
        {
            _buffer.Shift(FBEOffset);
            long fbeResult = VerifyFields();
            _buffer.Unshift(FBEOffset);
            return fbeResult;
        }

        // Check if the struct fields are valid
        public long VerifyFields()
        {
            long fbeCurrentOffset = 0;
            long fbeFieldSize;

            f1.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f1.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f2.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f2.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f3.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f3.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            return fbeCurrentOffset;
        }

        // Get the struct value
        public override long Get(out StructBytes fbeValue)
        {
            _buffer.Shift(FBEOffset);
            long fbeSize = GetFields(out fbeValue);
            _buffer.Unshift(FBEOffset);
            return fbeSize;
        }

        // Get the struct fields values
        public long GetFields(out StructBytes fbeValue)
        {
            long fbeCurrentOffset = 0;
            long fbeCurrentSize = 0;
            long fbeFieldSize;

            fbeValue = StructBytes.Default;

            f1.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f1.Get(out fbeValue.f1);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f2.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f2.Get(out fbeValue.f2);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f3.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f3.Get(out fbeValue.f3);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            return fbeCurrentSize;
        }

        // Set the struct value
        public override long Set(StructBytes fbeValue)
        {
            _buffer.Shift(FBEOffset);
            long fbeResult = SetFields(fbeValue);
            _buffer.Unshift(FBEOffset);
            return fbeResult;
        }

        // Set the struct fields values
        public long SetFields(StructBytes fbeValue)
        {
            long fbeCurrentOffset = 0;
            long fbeCurrentSize = 0;
            long fbeFieldSize;

            f1.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f1.Set(fbeValue.f1);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f2.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f2.Set(fbeValue.f2);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f3.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f3.Set(fbeValue.f3);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            return fbeCurrentSize;
        }
    }

} // namespace com.chronoxor.test.FBE

namespace com.chronoxor.test.FBE {

    using global::com.chronoxor.test;

    // Fast Binary Encoding StructBytes final model
    public class StructBytesFinalModel : com.chronoxor.FBE.Model
    {
        private readonly FinalModelStructBytes _model;

        public StructBytesFinalModel() { _model = new FinalModelStructBytes(Buffer, 8); }
        public StructBytesFinalModel(com.chronoxor.FBE.Buffer buffer) : base(buffer) { _model = new FinalModelStructBytes(Buffer, 8); }

        // Get the model type
        public const long FBETypeConst = FinalModelStructBytes.FBETypeConst;
        public long FBEType => FBETypeConst;

        // Check if the struct value is valid
        public bool Verify()
        {
            if ((Buffer.Offset + _model.FBEOffset) > Buffer.Size)
                return false;

            long fbeStructSize = ReadUInt32(_model.FBEOffset - 8);
            long fbeStructType = ReadUInt32(_model.FBEOffset - 4);
            if ((fbeStructSize <= 0) || (fbeStructType != FBEType))
                return false;

            return ((8 + _model.Verify()) == fbeStructSize);
        }

        // Serialize the struct value
        public long Serialize(StructBytes value)
        {
            long fbeInitialSize = Buffer.Size;

            uint fbeStructType = (uint)FBEType;
            uint fbeStructSize = (uint)(8 + _model.FBEAllocationSize(value));
            uint fbeStructOffset = (uint)(Buffer.Allocate(fbeStructSize) - Buffer.Offset);
            Debug.Assert(((Buffer.Offset + fbeStructOffset + fbeStructSize) <= Buffer.Size), "Model is broken!");
            if ((Buffer.Offset + fbeStructOffset + fbeStructSize) > Buffer.Size)
                return 0;

            fbeStructSize = (uint)(8 + _model.Set(value));
            Buffer.Resize(fbeInitialSize + fbeStructSize);

            Write(_model.FBEOffset - 8, fbeStructSize);
            Write(_model.FBEOffset - 4, fbeStructType);

            return fbeStructSize;
        }

        // Deserialize the struct value
        public long Deserialize(out StructBytes value)
        {
            Debug.Assert(((Buffer.Offset + _model.FBEOffset) <= Buffer.Size), "Model is broken!");
            if ((Buffer.Offset + _model.FBEOffset) > Buffer.Size)
            {
                value = StructBytes.Default;
                return 0;
            }

            long fbeStructSize = ReadUInt32(_model.FBEOffset - 8);
            long fbeStructType = ReadUInt32(_model.FBEOffset - 4);
            Debug.Assert(((fbeStructSize > 0) && (fbeStructType == FBEType)), "Model is broken!");
            if ((fbeStructSize <= 0) || (fbeStructType != FBEType))
            {
                value = StructBytes.Default;
                return 8;
            }

            return 8 + _model.Get(out value);
        }

        // Move to the next struct value
        public void Next(long prev)
        {
            _model.FBEShift(prev);
        }
    }

} // namespace com.chronoxor.test.FBE

namespace com.chronoxor.test {

    public struct StructArray : IComparable, IComparable<StructArray>, IEquatable<StructArray>
    {
        public byte[] f1;
        public byte?[] f2;
        public MemoryStream[] f3;
        public MemoryStream[] f4;
        public EnumSimple[] f5;
        public EnumSimple?[] f6;
        public FlagsSimple[] f7;
        public FlagsSimple?[] f8;
        public StructSimple[] f9;
        public StructSimple?[] f10;

        public const long FBETypeConst = 125;
        #if UTF8JSON
        [IgnoreDataMember]
        #else
        [JsonIgnore]
        #endif
        public long FBEType => FBETypeConst;

        public static StructArray Default => new StructArray
        {
            f1 = new byte[2]
            , f2 = new byte?[2]
            , f3 = new MemoryStream[2]
            , f4 = new MemoryStream[2]
            , f5 = new EnumSimple[2]
            , f6 = new EnumSimple?[2]
            , f7 = new FlagsSimple[2]
            , f8 = new FlagsSimple?[2]
            , f9 = new StructSimple[2]
            , f10 = new StructSimple?[2]
        };

        public StructArray(byte[] f1, byte?[] f2, MemoryStream[] f3, MemoryStream[] f4, EnumSimple[] f5, EnumSimple?[] f6, FlagsSimple[] f7, FlagsSimple?[] f8, StructSimple[] f9, StructSimple?[] f10)
        {
            this.f1 = f1;
            this.f2 = f2;
            this.f3 = f3;
            this.f4 = f4;
            this.f5 = f5;
            this.f6 = f6;
            this.f7 = f7;
            this.f8 = f8;
            this.f9 = f9;
            this.f10 = f10;
        }

        public StructArray Clone()
        {
            // Serialize the struct to the FBE stream
            var writer = new com.chronoxor.test.FBE.StructArrayModel();
            writer.Serialize(this);

            // Deserialize the struct from the FBE stream
            var reader = new com.chronoxor.test.FBE.StructArrayModel();
            reader.Attach(writer.Buffer);
            reader.Deserialize(out var result);
            return result;
        }

        public int CompareTo(object other)
        {
            int result = 0;
            return result;
        }

        public int CompareTo(StructArray other)
        {
            int result = 0;
            return result;
        }

        public override bool Equals(object other)
        {
            if (!(other is StructArray))
                return false;
            return true;
        }

        public bool Equals(StructArray other)
        {
            return true;
        }

        public override int GetHashCode()
        {
            int hash = 17;
            return hash;
        }

        public static bool operator==(StructArray lhs, StructArray rhs) => lhs.Equals(rhs);
        public static bool operator!=(StructArray lhs, StructArray rhs) => !(lhs == rhs);

        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("StructArray(");
            if (f1 != null)
            {
                bool first = true;
                sb.Append("f1=[").Append(f1.Length).Append("][");
                foreach (var item in f1)
                {
                    sb.Append(first ? "" : ",").Append(item);
                    first = false;
                }
                sb.Append("]");
            }
            else
            {
                sb.Append("f1=[0][]");
            }
            if (f2 != null)
            {
                bool first = true;
                sb.Append(",f2=[").Append(f2.Length).Append("][");
                foreach (var item in f2)
                {
                    if (item != null) sb.Append(first ? "" : ",").Append(item); else sb.Append(first ? "" : ",").Append("null");
                    first = false;
                }
                sb.Append("]");
            }
            else
            {
                sb.Append(",f2=[0][]");
            }
            if (f3 != null)
            {
                bool first = true;
                sb.Append(",f3=[").Append(f3.Length).Append("][");
                foreach (var item in f3)
                {
                    if (item != null) sb.Append(first ? "" : ",").Append("bytes[").Append(item.Length).Append("]"); else sb.Append(first ? "" : ",").Append("null");
                    first = false;
                }
                sb.Append("]");
            }
            else
            {
                sb.Append(",f3=[0][]");
            }
            if (f4 != null)
            {
                bool first = true;
                sb.Append(",f4=[").Append(f4.Length).Append("][");
                foreach (var item in f4)
                {
                    if (item != null) sb.Append(first ? "" : ",").Append("bytes[").Append(item.Length).Append("]"); else sb.Append(first ? "" : ",").Append("null");
                    first = false;
                }
                sb.Append("]");
            }
            else
            {
                sb.Append(",f4=[0][]");
            }
            if (f5 != null)
            {
                bool first = true;
                sb.Append(",f5=[").Append(f5.Length).Append("][");
                foreach (var item in f5)
                {
                    sb.Append(first ? "" : ",").Append(item);
                    first = false;
                }
                sb.Append("]");
            }
            else
            {
                sb.Append(",f5=[0][]");
            }
            if (f6 != null)
            {
                bool first = true;
                sb.Append(",f6=[").Append(f6.Length).Append("][");
                foreach (var item in f6)
                {
                    if (item != null) sb.Append(first ? "" : ",").Append(item); else sb.Append(first ? "" : ",").Append("null");
                    first = false;
                }
                sb.Append("]");
            }
            else
            {
                sb.Append(",f6=[0][]");
            }
            if (f7 != null)
            {
                bool first = true;
                sb.Append(",f7=[").Append(f7.Length).Append("][");
                foreach (var item in f7)
                {
                    sb.Append(first ? "" : ",").Append(item);
                    first = false;
                }
                sb.Append("]");
            }
            else
            {
                sb.Append(",f7=[0][]");
            }
            if (f8 != null)
            {
                bool first = true;
                sb.Append(",f8=[").Append(f8.Length).Append("][");
                foreach (var item in f8)
                {
                    if (item != null) sb.Append(first ? "" : ",").Append(item); else sb.Append(first ? "" : ",").Append("null");
                    first = false;
                }
                sb.Append("]");
            }
            else
            {
                sb.Append(",f8=[0][]");
            }
            if (f9 != null)
            {
                bool first = true;
                sb.Append(",f9=[").Append(f9.Length).Append("][");
                foreach (var item in f9)
                {
                    sb.Append(first ? "" : ",").Append(item);
                    first = false;
                }
                sb.Append("]");
            }
            else
            {
                sb.Append(",f9=[0][]");
            }
            if (f10 != null)
            {
                bool first = true;
                sb.Append(",f10=[").Append(f10.Length).Append("][");
                foreach (var item in f10)
                {
                    if (item != null) sb.Append(first ? "" : ",").Append(item); else sb.Append(first ? "" : ",").Append("null");
                    first = false;
                }
                sb.Append("]");
            }
            else
            {
                sb.Append(",f10=[0][]");
            }
            sb.Append(")");
            return sb.ToString();
        }

        public string ToJson()
        {
            var json = com.chronoxor.FBE.Json.ToJson(this);
            return json;
        }

        public static StructArray FromJson(string json)
        {
            var result = com.chronoxor.FBE.Json.FromJson<StructArray>(json);
            return result;
        }

        public static com.chronoxor.FBE.FieldModelValueType<StructArray> CreateFieldModel(com.chronoxor.FBE.Buffer buffer, long offset) { return new test.FBE.FieldModelStructArray(buffer, offset); }
    }

} // namespace com.chronoxor.test

namespace com.chronoxor.test.FBE {

    using global::com.chronoxor.test;

    // Fast Binary Encoding StructArray field model
    public class FieldModelStructArray : com.chronoxor.FBE.FieldModelValueType<StructArray>
    {
        public readonly com.chronoxor.FBE.FieldModelArrayValueType<byte, com.chronoxor.FBE.FieldModelValueType<byte>> f1;
        public readonly com.chronoxor.FBE.FieldModelArrayOptionalValueType<byte, com.chronoxor.FBE.FieldModelValueType<byte>> f2;
        public readonly com.chronoxor.FBE.FieldModelArrayReferenceType<MemoryStream, com.chronoxor.FBE.FieldModelReferenceType<MemoryStream>> f3;
        public readonly com.chronoxor.FBE.FieldModelArrayOptionalReferenceType<MemoryStream, com.chronoxor.FBE.FieldModelReferenceType<MemoryStream>> f4;
        public readonly com.chronoxor.FBE.FieldModelArrayValueType<EnumSimple, com.chronoxor.test.FBE.FieldModelEnumSimple> f5;
        public readonly com.chronoxor.FBE.FieldModelArrayOptionalValueType<EnumSimple, com.chronoxor.test.FBE.FieldModelEnumSimple> f6;
        public readonly com.chronoxor.FBE.FieldModelArrayValueType<FlagsSimple, com.chronoxor.test.FBE.FieldModelFlagsSimple> f7;
        public readonly com.chronoxor.FBE.FieldModelArrayOptionalValueType<FlagsSimple, com.chronoxor.test.FBE.FieldModelFlagsSimple> f8;
        public readonly com.chronoxor.FBE.FieldModelArrayValueType<StructSimple, com.chronoxor.test.FBE.FieldModelStructSimple> f9;
        public readonly com.chronoxor.FBE.FieldModelArrayOptionalValueType<StructSimple, com.chronoxor.test.FBE.FieldModelStructSimple> f10;

        public FieldModelStructArray(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset)
        {
            f1 = new com.chronoxor.FBE.FieldModelArrayValueType<byte, com.chronoxor.FBE.FieldModelValueType<byte>>(com.chronoxor.FBE.FieldModelValueType<byte>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.BYTE, buffer, 4 + 4), buffer, 4 + 4, 2);
            f2 = new com.chronoxor.FBE.FieldModelArrayOptionalValueType<byte, com.chronoxor.FBE.FieldModelValueType<byte>>(com.chronoxor.FBE.FieldModelValueType<byte>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.BYTE, buffer, f1.FBEOffset + f1.FBESize), buffer, f1.FBEOffset + f1.FBESize, 2);
            f3 = new com.chronoxor.FBE.FieldModelArrayReferenceType<MemoryStream, com.chronoxor.FBE.FieldModelReferenceType<MemoryStream>>(com.chronoxor.FBE.FieldModelReferenceType<MemoryStream>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.BYTES, buffer, f2.FBEOffset + f2.FBESize), buffer, f2.FBEOffset + f2.FBESize, 2);
            f4 = new com.chronoxor.FBE.FieldModelArrayOptionalReferenceType<MemoryStream, com.chronoxor.FBE.FieldModelReferenceType<MemoryStream>>(com.chronoxor.FBE.FieldModelReferenceType<MemoryStream>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.BYTES, buffer, f3.FBEOffset + f3.FBESize), buffer, f3.FBEOffset + f3.FBESize, 2);
            f5 = new com.chronoxor.FBE.FieldModelArrayValueType<EnumSimple, com.chronoxor.test.FBE.FieldModelEnumSimple>(new com.chronoxor.test.FBE.FieldModelEnumSimple(buffer, f4.FBEOffset + f4.FBESize), buffer, f4.FBEOffset + f4.FBESize, 2);
            f6 = new com.chronoxor.FBE.FieldModelArrayOptionalValueType<EnumSimple, com.chronoxor.test.FBE.FieldModelEnumSimple>(new com.chronoxor.test.FBE.FieldModelEnumSimple(buffer, f5.FBEOffset + f5.FBESize), buffer, f5.FBEOffset + f5.FBESize, 2);
            f7 = new com.chronoxor.FBE.FieldModelArrayValueType<FlagsSimple, com.chronoxor.test.FBE.FieldModelFlagsSimple>(new com.chronoxor.test.FBE.FieldModelFlagsSimple(buffer, f6.FBEOffset + f6.FBESize), buffer, f6.FBEOffset + f6.FBESize, 2);
            f8 = new com.chronoxor.FBE.FieldModelArrayOptionalValueType<FlagsSimple, com.chronoxor.test.FBE.FieldModelFlagsSimple>(new com.chronoxor.test.FBE.FieldModelFlagsSimple(buffer, f7.FBEOffset + f7.FBESize), buffer, f7.FBEOffset + f7.FBESize, 2);
            f9 = new com.chronoxor.FBE.FieldModelArrayValueType<StructSimple, com.chronoxor.test.FBE.FieldModelStructSimple>(new com.chronoxor.test.FBE.FieldModelStructSimple(buffer, f8.FBEOffset + f8.FBESize), buffer, f8.FBEOffset + f8.FBESize, 2);
            f10 = new com.chronoxor.FBE.FieldModelArrayOptionalValueType<StructSimple, com.chronoxor.test.FBE.FieldModelStructSimple>(new com.chronoxor.test.FBE.FieldModelStructSimple(buffer, f9.FBEOffset + f9.FBESize), buffer, f9.FBEOffset + f9.FBESize, 2);
        }

        // Get the field size
        public override long FBESize => 4;
        // Get the field body size
        public long FBEBody
        {
            get
            {
                long fbeResult = 4 + 4
                    + f1.FBESize
                    + f2.FBESize
                    + f3.FBESize
                    + f4.FBESize
                    + f5.FBESize
                    + f6.FBESize
                    + f7.FBESize
                    + f8.FBESize
                    + f9.FBESize
                    + f10.FBESize
                    ;
                return fbeResult;
            }
        }
        // Get the field extra size
        public override long FBEExtra
        {
            get
            {
                if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                    return 0;

                uint fbeStructOffset = ReadUInt32(FBEOffset);
                if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4) > _buffer.Size))
                    return 0;

                _buffer.Shift(fbeStructOffset);

                long fbeResult = FBEBody
                    + f1.FBEExtra
                    + f2.FBEExtra
                    + f3.FBEExtra
                    + f4.FBEExtra
                    + f5.FBEExtra
                    + f6.FBEExtra
                    + f7.FBEExtra
                    + f8.FBEExtra
                    + f9.FBEExtra
                    + f10.FBEExtra
                    ;

                _buffer.Unshift(fbeStructOffset);

                return fbeResult;
            }
        }
        // Get the field type
        public const long FBETypeConst = 125;
        public long FBEType => FBETypeConst;

        // Clone the field model
        public override com.chronoxor.FBE.FieldModelValueType<StructArray> Clone() { return new FieldModelStructArray(_buffer, _offset); }

        // Check if the struct value is valid
        public override bool Verify() { return Verify(true); }
        public bool Verify(bool fbeVerifyType)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return true;

            uint fbeStructOffset = ReadUInt32(FBEOffset);
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
                return false;

            uint fbeStructSize = ReadUInt32(fbeStructOffset);
            if (fbeStructSize < (4 + 4))
                return false;

            uint fbeStructType = ReadUInt32(fbeStructOffset + 4);
            if (fbeVerifyType && (fbeStructType != FBEType))
                return false;

            _buffer.Shift(fbeStructOffset);
            bool fbeResult = VerifyFields(fbeStructSize);
            _buffer.Unshift(fbeStructOffset);
            return fbeResult;
        }

        // Check if the struct fields are valid
        public bool VerifyFields(long fbeStructSize)
        {
            long fbeCurrentSize = 4 + 4;

            if ((fbeCurrentSize + f1.FBESize) > fbeStructSize)
                return true;
            if (!f1.Verify())
                return false;
            fbeCurrentSize += f1.FBESize;

            if ((fbeCurrentSize + f2.FBESize) > fbeStructSize)
                return true;
            if (!f2.Verify())
                return false;
            fbeCurrentSize += f2.FBESize;

            if ((fbeCurrentSize + f3.FBESize) > fbeStructSize)
                return true;
            if (!f3.Verify())
                return false;
            fbeCurrentSize += f3.FBESize;

            if ((fbeCurrentSize + f4.FBESize) > fbeStructSize)
                return true;
            if (!f4.Verify())
                return false;
            fbeCurrentSize += f4.FBESize;

            if ((fbeCurrentSize + f5.FBESize) > fbeStructSize)
                return true;
            if (!f5.Verify())
                return false;
            fbeCurrentSize += f5.FBESize;

            if ((fbeCurrentSize + f6.FBESize) > fbeStructSize)
                return true;
            if (!f6.Verify())
                return false;
            fbeCurrentSize += f6.FBESize;

            if ((fbeCurrentSize + f7.FBESize) > fbeStructSize)
                return true;
            if (!f7.Verify())
                return false;
            fbeCurrentSize += f7.FBESize;

            if ((fbeCurrentSize + f8.FBESize) > fbeStructSize)
                return true;
            if (!f8.Verify())
                return false;
            fbeCurrentSize += f8.FBESize;

            if ((fbeCurrentSize + f9.FBESize) > fbeStructSize)
                return true;
            if (!f9.Verify())
                return false;
            fbeCurrentSize += f9.FBESize;

            if ((fbeCurrentSize + f10.FBESize) > fbeStructSize)
                return true;
            if (!f10.Verify())
                return false;
            fbeCurrentSize += f10.FBESize;

            return true;
        }

        // Get the struct value (begin phase)
        public long GetBegin()
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            uint fbeStructOffset = ReadUInt32(FBEOffset);
            Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + 4 + 4) <= _buffer.Size)), "Model is broken!");
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
                return 0;

            uint fbeStructSize = ReadUInt32(fbeStructOffset);
            Debug.Assert((fbeStructSize >= (4 + 4)), "Model is broken!");
            if (fbeStructSize < (4 + 4))
                return 0;

            _buffer.Shift(fbeStructOffset);
            return fbeStructOffset;
        }

        // Get the struct value (end phase)
        public void GetEnd(long fbeBegin)
        {
            _buffer.Unshift(fbeBegin);
        }

        // Get the struct value
        public override void Get(out StructArray fbeValue) { Get(out fbeValue, StructArray.Default); }
        public override void Get(out StructArray fbeValue, StructArray defaults)
        {
            long fbeBegin = GetBegin();
            if (fbeBegin == 0)
            {
                fbeValue = defaults;
                return;
            }

            uint fbeStructSize = ReadUInt32(0);
            GetFields(out fbeValue, fbeStructSize);
            GetEnd(fbeBegin);
        }

        // Get the struct fields values
        public void GetFields(out StructArray fbeValue, long fbeStructSize)
        {
            long fbeCurrentSize = 4 + 4;

            fbeValue = StructArray.Default;

            if ((fbeCurrentSize + f1.FBESize) <= fbeStructSize)
                f1.Get(ref fbeValue.f1);
            else
                fbeValue.f1 = new byte[2];
            fbeCurrentSize += f1.FBESize;

            if ((fbeCurrentSize + f2.FBESize) <= fbeStructSize)
                f2.Get(ref fbeValue.f2);
            else
                fbeValue.f2 = new byte?[2];
            fbeCurrentSize += f2.FBESize;

            if ((fbeCurrentSize + f3.FBESize) <= fbeStructSize)
                f3.Get(ref fbeValue.f3);
            else
                fbeValue.f3 = new MemoryStream[2];
            fbeCurrentSize += f3.FBESize;

            if ((fbeCurrentSize + f4.FBESize) <= fbeStructSize)
                f4.Get(ref fbeValue.f4);
            else
                fbeValue.f4 = new MemoryStream[2];
            fbeCurrentSize += f4.FBESize;

            if ((fbeCurrentSize + f5.FBESize) <= fbeStructSize)
                f5.Get(ref fbeValue.f5);
            else
                fbeValue.f5 = new EnumSimple[2];
            fbeCurrentSize += f5.FBESize;

            if ((fbeCurrentSize + f6.FBESize) <= fbeStructSize)
                f6.Get(ref fbeValue.f6);
            else
                fbeValue.f6 = new EnumSimple?[2];
            fbeCurrentSize += f6.FBESize;

            if ((fbeCurrentSize + f7.FBESize) <= fbeStructSize)
                f7.Get(ref fbeValue.f7);
            else
                fbeValue.f7 = new FlagsSimple[2];
            fbeCurrentSize += f7.FBESize;

            if ((fbeCurrentSize + f8.FBESize) <= fbeStructSize)
                f8.Get(ref fbeValue.f8);
            else
                fbeValue.f8 = new FlagsSimple?[2];
            fbeCurrentSize += f8.FBESize;

            if ((fbeCurrentSize + f9.FBESize) <= fbeStructSize)
                f9.Get(ref fbeValue.f9);
            else
                fbeValue.f9 = new StructSimple[2];
            fbeCurrentSize += f9.FBESize;

            if ((fbeCurrentSize + f10.FBESize) <= fbeStructSize)
                f10.Get(ref fbeValue.f10);
            else
                fbeValue.f10 = new StructSimple?[2];
            fbeCurrentSize += f10.FBESize;
        }

        // Set the struct value (begin phase)
        public long SetBegin()
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            uint fbeStructSize = (uint)FBEBody;
            uint fbeStructOffset = (uint)(_buffer.Allocate(fbeStructSize) - _buffer.Offset);
            Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + fbeStructSize) <= _buffer.Size)), "Model is broken!");
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + fbeStructSize) > _buffer.Size))
                return 0;

            Write(FBEOffset, fbeStructOffset);
            Write(fbeStructOffset, fbeStructSize);
            Write(fbeStructOffset + 4, (uint)FBEType);

            _buffer.Shift(fbeStructOffset);
            return fbeStructOffset;
        }

        // Set the struct value (end phase)
        public void SetEnd(long fbeBegin)
        {
            _buffer.Unshift(fbeBegin);
        }

        // Set the struct value
        public override void Set(StructArray fbeValue)
        {
            long fbeBegin = SetBegin();
            if (fbeBegin == 0)
                return;

            SetFields(fbeValue);
            SetEnd(fbeBegin);
        }

        // Set the struct fields values
        public void SetFields(StructArray fbeValue)
        {
            f1.Set(fbeValue.f1);
            f2.Set(fbeValue.f2);
            f3.Set(fbeValue.f3);
            f4.Set(fbeValue.f4);
            f5.Set(fbeValue.f5);
            f6.Set(fbeValue.f6);
            f7.Set(fbeValue.f7);
            f8.Set(fbeValue.f8);
            f9.Set(fbeValue.f9);
            f10.Set(fbeValue.f10);
        }
    }

} // namespace com.chronoxor.test.FBE

namespace com.chronoxor.test.FBE {

    using global::com.chronoxor.test;

    // Fast Binary Encoding StructArray model
    public class StructArrayModel : com.chronoxor.FBE.Model
    {
        public readonly FieldModelStructArray model;

        public StructArrayModel() { model = new FieldModelStructArray(Buffer, 4); }
        public StructArrayModel(com.chronoxor.FBE.Buffer buffer) : base(buffer) { model = new FieldModelStructArray(Buffer, 4); }

        // Get the model size
        public long FBESize => model.FBESize + model.FBEExtra;
        // Get the model type
        public const long FBETypeConst = FieldModelStructArray.FBETypeConst;
        public long FBEType => FBETypeConst;

        // Check if the struct value is valid
        public bool Verify()
        {
            if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
                return false;

            uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
            if (fbeFullSize < model.FBESize)
                return false;

            return model.Verify();
        }

        // Create a new model (begin phase)
        public long CreateBegin()
        {
            long fbeBegin = Buffer.Allocate(4 + model.FBESize);
            return fbeBegin;
        }

        // Create a new model (end phase)
        public long CreateEnd(long fbeBegin)
        {
            long fbeEnd = Buffer.Size;
            uint fbeFullSize = (uint)(fbeEnd - fbeBegin);
            Write(model.FBEOffset - 4, fbeFullSize);
            return fbeFullSize;
        }

        // Serialize the struct value
        public long Serialize(StructArray value)
        {
            long fbeBegin = CreateBegin();
            model.Set(value);
            long fbeFullSize = CreateEnd(fbeBegin);
            return fbeFullSize;
        }

        // Deserialize the struct value
        public long Deserialize(out StructArray value)
        {
            if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
            {
                value = StructArray.Default;
                return 0;
            }

            uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
            Debug.Assert((fbeFullSize >= model.FBESize), "Model is broken!");
            if (fbeFullSize < model.FBESize)
            {
                value = StructArray.Default;
                return 0;
            }

            model.Get(out value);
            return fbeFullSize;
        }

        // Move to the next struct value
        public void Next(long prev)
        {
            model.FBEShift(prev);
        }
    }

} // namespace com.chronoxor.test.FBE

namespace com.chronoxor.test.FBE {

    using global::com.chronoxor.test;

    // Fast Binary Encoding StructArray final model
    public class FinalModelStructArray : com.chronoxor.FBE.FinalModelValueType<StructArray>
    {
        public readonly com.chronoxor.FBE.FinalModelArrayValueType<byte, com.chronoxor.FBE.FinalModelValueType<byte>> f1;
        public readonly com.chronoxor.FBE.FinalModelArrayOptionalValueType<byte, com.chronoxor.FBE.FinalModelValueType<byte>> f2;
        public readonly com.chronoxor.FBE.FinalModelArrayReferenceType<MemoryStream, com.chronoxor.FBE.FinalModelReferenceType<MemoryStream>> f3;
        public readonly com.chronoxor.FBE.FinalModelArrayOptionalReferenceType<MemoryStream, com.chronoxor.FBE.FinalModelReferenceType<MemoryStream>> f4;
        public readonly com.chronoxor.FBE.FinalModelArrayValueType<EnumSimple, com.chronoxor.test.FBE.FinalModelEnumSimple> f5;
        public readonly com.chronoxor.FBE.FinalModelArrayOptionalValueType<EnumSimple, com.chronoxor.test.FBE.FinalModelEnumSimple> f6;
        public readonly com.chronoxor.FBE.FinalModelArrayValueType<FlagsSimple, com.chronoxor.test.FBE.FinalModelFlagsSimple> f7;
        public readonly com.chronoxor.FBE.FinalModelArrayOptionalValueType<FlagsSimple, com.chronoxor.test.FBE.FinalModelFlagsSimple> f8;
        public readonly com.chronoxor.FBE.FinalModelArrayValueType<StructSimple, com.chronoxor.test.FBE.FinalModelStructSimple> f9;
        public readonly com.chronoxor.FBE.FinalModelArrayOptionalValueType<StructSimple, com.chronoxor.test.FBE.FinalModelStructSimple> f10;

        public FinalModelStructArray(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset)
        {
            f1 = new com.chronoxor.FBE.FinalModelArrayValueType<byte, com.chronoxor.FBE.FinalModelValueType<byte>>(com.chronoxor.FBE.FinalModelValueType<byte>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.BYTE, buffer, 0), buffer, 0, 2);
            f2 = new com.chronoxor.FBE.FinalModelArrayOptionalValueType<byte, com.chronoxor.FBE.FinalModelValueType<byte>>(com.chronoxor.FBE.FinalModelValueType<byte>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.BYTE, buffer, 0), buffer, 0, 2);
            f3 = new com.chronoxor.FBE.FinalModelArrayReferenceType<MemoryStream, com.chronoxor.FBE.FinalModelReferenceType<MemoryStream>>(com.chronoxor.FBE.FinalModelReferenceType<MemoryStream>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.BYTES, buffer, 0), buffer, 0, 2);
            f4 = new com.chronoxor.FBE.FinalModelArrayOptionalReferenceType<MemoryStream, com.chronoxor.FBE.FinalModelReferenceType<MemoryStream>>(com.chronoxor.FBE.FinalModelReferenceType<MemoryStream>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.BYTES, buffer, 0), buffer, 0, 2);
            f5 = new com.chronoxor.FBE.FinalModelArrayValueType<EnumSimple, com.chronoxor.test.FBE.FinalModelEnumSimple>(new com.chronoxor.test.FBE.FinalModelEnumSimple(buffer, 0), buffer, 0, 2);
            f6 = new com.chronoxor.FBE.FinalModelArrayOptionalValueType<EnumSimple, com.chronoxor.test.FBE.FinalModelEnumSimple>(new com.chronoxor.test.FBE.FinalModelEnumSimple(buffer, 0), buffer, 0, 2);
            f7 = new com.chronoxor.FBE.FinalModelArrayValueType<FlagsSimple, com.chronoxor.test.FBE.FinalModelFlagsSimple>(new com.chronoxor.test.FBE.FinalModelFlagsSimple(buffer, 0), buffer, 0, 2);
            f8 = new com.chronoxor.FBE.FinalModelArrayOptionalValueType<FlagsSimple, com.chronoxor.test.FBE.FinalModelFlagsSimple>(new com.chronoxor.test.FBE.FinalModelFlagsSimple(buffer, 0), buffer, 0, 2);
            f9 = new com.chronoxor.FBE.FinalModelArrayValueType<StructSimple, com.chronoxor.test.FBE.FinalModelStructSimple>(new com.chronoxor.test.FBE.FinalModelStructSimple(buffer, 0), buffer, 0, 2);
            f10 = new com.chronoxor.FBE.FinalModelArrayOptionalValueType<StructSimple, com.chronoxor.test.FBE.FinalModelStructSimple>(new com.chronoxor.test.FBE.FinalModelStructSimple(buffer, 0), buffer, 0, 2);
        }

        // Get the allocation size
        public override long FBEAllocationSize(StructArray fbeValue)
        {
            long fbeResult = 0
                + f1.FBEAllocationSize(fbeValue.f1)
                + f2.FBEAllocationSize(fbeValue.f2)
                + f3.FBEAllocationSize(fbeValue.f3)
                + f4.FBEAllocationSize(fbeValue.f4)
                + f5.FBEAllocationSize(fbeValue.f5)
                + f6.FBEAllocationSize(fbeValue.f6)
                + f7.FBEAllocationSize(fbeValue.f7)
                + f8.FBEAllocationSize(fbeValue.f8)
                + f9.FBEAllocationSize(fbeValue.f9)
                + f10.FBEAllocationSize(fbeValue.f10)
                ;
            return fbeResult;
        }

        // Get the final type
        public const long FBETypeConst = 125;
        public long FBEType => FBETypeConst;

        // Clone the final model
        public override com.chronoxor.FBE.FinalModelValueType<StructArray> Clone() { return new FinalModelStructArray(_buffer, _offset); }

        // Check if the struct value is valid
        public override long Verify()
        {
            _buffer.Shift(FBEOffset);
            long fbeResult = VerifyFields();
            _buffer.Unshift(FBEOffset);
            return fbeResult;
        }

        // Check if the struct fields are valid
        public long VerifyFields()
        {
            long fbeCurrentOffset = 0;
            long fbeFieldSize;

            f1.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f1.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f2.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f2.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f3.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f3.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f4.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f4.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f5.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f5.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f6.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f6.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f7.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f7.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f8.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f8.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f9.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f9.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f10.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f10.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            return fbeCurrentOffset;
        }

        // Get the struct value
        public override long Get(out StructArray fbeValue)
        {
            _buffer.Shift(FBEOffset);
            long fbeSize = GetFields(out fbeValue);
            _buffer.Unshift(FBEOffset);
            return fbeSize;
        }

        // Get the struct fields values
        public long GetFields(out StructArray fbeValue)
        {
            long fbeCurrentOffset = 0;
            long fbeCurrentSize = 0;
            long fbeFieldSize;

            fbeValue = StructArray.Default;

            f1.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f1.Get(out fbeValue.f1);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f2.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f2.Get(out fbeValue.f2);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f3.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f3.Get(out fbeValue.f3);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f4.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f4.Get(out fbeValue.f4);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f5.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f5.Get(out fbeValue.f5);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f6.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f6.Get(out fbeValue.f6);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f7.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f7.Get(out fbeValue.f7);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f8.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f8.Get(out fbeValue.f8);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f9.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f9.Get(out fbeValue.f9);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f10.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f10.Get(out fbeValue.f10);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            return fbeCurrentSize;
        }

        // Set the struct value
        public override long Set(StructArray fbeValue)
        {
            _buffer.Shift(FBEOffset);
            long fbeResult = SetFields(fbeValue);
            _buffer.Unshift(FBEOffset);
            return fbeResult;
        }

        // Set the struct fields values
        public long SetFields(StructArray fbeValue)
        {
            long fbeCurrentOffset = 0;
            long fbeCurrentSize = 0;
            long fbeFieldSize;

            f1.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f1.Set(fbeValue.f1);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f2.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f2.Set(fbeValue.f2);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f3.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f3.Set(fbeValue.f3);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f4.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f4.Set(fbeValue.f4);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f5.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f5.Set(fbeValue.f5);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f6.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f6.Set(fbeValue.f6);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f7.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f7.Set(fbeValue.f7);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f8.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f8.Set(fbeValue.f8);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f9.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f9.Set(fbeValue.f9);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f10.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f10.Set(fbeValue.f10);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            return fbeCurrentSize;
        }
    }

} // namespace com.chronoxor.test.FBE

namespace com.chronoxor.test.FBE {

    using global::com.chronoxor.test;

    // Fast Binary Encoding StructArray final model
    public class StructArrayFinalModel : com.chronoxor.FBE.Model
    {
        private readonly FinalModelStructArray _model;

        public StructArrayFinalModel() { _model = new FinalModelStructArray(Buffer, 8); }
        public StructArrayFinalModel(com.chronoxor.FBE.Buffer buffer) : base(buffer) { _model = new FinalModelStructArray(Buffer, 8); }

        // Get the model type
        public const long FBETypeConst = FinalModelStructArray.FBETypeConst;
        public long FBEType => FBETypeConst;

        // Check if the struct value is valid
        public bool Verify()
        {
            if ((Buffer.Offset + _model.FBEOffset) > Buffer.Size)
                return false;

            long fbeStructSize = ReadUInt32(_model.FBEOffset - 8);
            long fbeStructType = ReadUInt32(_model.FBEOffset - 4);
            if ((fbeStructSize <= 0) || (fbeStructType != FBEType))
                return false;

            return ((8 + _model.Verify()) == fbeStructSize);
        }

        // Serialize the struct value
        public long Serialize(StructArray value)
        {
            long fbeInitialSize = Buffer.Size;

            uint fbeStructType = (uint)FBEType;
            uint fbeStructSize = (uint)(8 + _model.FBEAllocationSize(value));
            uint fbeStructOffset = (uint)(Buffer.Allocate(fbeStructSize) - Buffer.Offset);
            Debug.Assert(((Buffer.Offset + fbeStructOffset + fbeStructSize) <= Buffer.Size), "Model is broken!");
            if ((Buffer.Offset + fbeStructOffset + fbeStructSize) > Buffer.Size)
                return 0;

            fbeStructSize = (uint)(8 + _model.Set(value));
            Buffer.Resize(fbeInitialSize + fbeStructSize);

            Write(_model.FBEOffset - 8, fbeStructSize);
            Write(_model.FBEOffset - 4, fbeStructType);

            return fbeStructSize;
        }

        // Deserialize the struct value
        public long Deserialize(out StructArray value)
        {
            Debug.Assert(((Buffer.Offset + _model.FBEOffset) <= Buffer.Size), "Model is broken!");
            if ((Buffer.Offset + _model.FBEOffset) > Buffer.Size)
            {
                value = StructArray.Default;
                return 0;
            }

            long fbeStructSize = ReadUInt32(_model.FBEOffset - 8);
            long fbeStructType = ReadUInt32(_model.FBEOffset - 4);
            Debug.Assert(((fbeStructSize > 0) && (fbeStructType == FBEType)), "Model is broken!");
            if ((fbeStructSize <= 0) || (fbeStructType != FBEType))
            {
                value = StructArray.Default;
                return 8;
            }

            return 8 + _model.Get(out value);
        }

        // Move to the next struct value
        public void Next(long prev)
        {
            _model.FBEShift(prev);
        }
    }

} // namespace com.chronoxor.test.FBE

namespace com.chronoxor.test {

    public struct StructVector : IComparable, IComparable<StructVector>, IEquatable<StructVector>
    {
        public List<byte> f1;
        public List<byte?> f2;
        public List<MemoryStream> f3;
        public List<MemoryStream> f4;
        public List<EnumSimple> f5;
        public List<EnumSimple?> f6;
        public List<FlagsSimple> f7;
        public List<FlagsSimple?> f8;
        public List<StructSimple> f9;
        public List<StructSimple?> f10;

        public const long FBETypeConst = 130;
        #if UTF8JSON
        [IgnoreDataMember]
        #else
        [JsonIgnore]
        #endif
        public long FBEType => FBETypeConst;

        public static StructVector Default => new StructVector
        {
            f1 = new List<byte>()
            , f2 = new List<byte?>()
            , f3 = new List<MemoryStream>()
            , f4 = new List<MemoryStream>()
            , f5 = new List<EnumSimple>()
            , f6 = new List<EnumSimple?>()
            , f7 = new List<FlagsSimple>()
            , f8 = new List<FlagsSimple?>()
            , f9 = new List<StructSimple>()
            , f10 = new List<StructSimple?>()
        };

        public StructVector(List<byte> f1, List<byte?> f2, List<MemoryStream> f3, List<MemoryStream> f4, List<EnumSimple> f5, List<EnumSimple?> f6, List<FlagsSimple> f7, List<FlagsSimple?> f8, List<StructSimple> f9, List<StructSimple?> f10)
        {
            this.f1 = f1;
            this.f2 = f2;
            this.f3 = f3;
            this.f4 = f4;
            this.f5 = f5;
            this.f6 = f6;
            this.f7 = f7;
            this.f8 = f8;
            this.f9 = f9;
            this.f10 = f10;
        }

        public StructVector Clone()
        {
            // Serialize the struct to the FBE stream
            var writer = new com.chronoxor.test.FBE.StructVectorModel();
            writer.Serialize(this);

            // Deserialize the struct from the FBE stream
            var reader = new com.chronoxor.test.FBE.StructVectorModel();
            reader.Attach(writer.Buffer);
            reader.Deserialize(out var result);
            return result;
        }

        public int CompareTo(object other)
        {
            int result = 0;
            return result;
        }

        public int CompareTo(StructVector other)
        {
            int result = 0;
            return result;
        }

        public override bool Equals(object other)
        {
            if (!(other is StructVector))
                return false;
            return true;
        }

        public bool Equals(StructVector other)
        {
            return true;
        }

        public override int GetHashCode()
        {
            int hash = 17;
            return hash;
        }

        public static bool operator==(StructVector lhs, StructVector rhs) => lhs.Equals(rhs);
        public static bool operator!=(StructVector lhs, StructVector rhs) => !(lhs == rhs);

        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("StructVector(");
            if (f1 != null)
            {
                bool first = true;
                sb.Append("f1=[").Append(f1.Count).Append("][");
                foreach (var item in f1)
                {
                    sb.Append(first ? "" : ",").Append(item);
                    first = false;
                }
                sb.Append("]");
            }
            else
            {
                sb.Append("f1=[0][]");
            }
            if (f2 != null)
            {
                bool first = true;
                sb.Append(",f2=[").Append(f2.Count).Append("][");
                foreach (var item in f2)
                {
                    if (item != null) sb.Append(first ? "" : ",").Append(item); else sb.Append(first ? "" : ",").Append("null");
                    first = false;
                }
                sb.Append("]");
            }
            else
            {
                sb.Append(",f2=[0][]");
            }
            if (f3 != null)
            {
                bool first = true;
                sb.Append(",f3=[").Append(f3.Count).Append("][");
                foreach (var item in f3)
                {
                    if (item != null) sb.Append(first ? "" : ",").Append("bytes[").Append(item.Length).Append("]"); else sb.Append(first ? "" : ",").Append("null");
                    first = false;
                }
                sb.Append("]");
            }
            else
            {
                sb.Append(",f3=[0][]");
            }
            if (f4 != null)
            {
                bool first = true;
                sb.Append(",f4=[").Append(f4.Count).Append("][");
                foreach (var item in f4)
                {
                    if (item != null) sb.Append(first ? "" : ",").Append("bytes[").Append(item.Length).Append("]"); else sb.Append(first ? "" : ",").Append("null");
                    first = false;
                }
                sb.Append("]");
            }
            else
            {
                sb.Append(",f4=[0][]");
            }
            if (f5 != null)
            {
                bool first = true;
                sb.Append(",f5=[").Append(f5.Count).Append("][");
                foreach (var item in f5)
                {
                    sb.Append(first ? "" : ",").Append(item);
                    first = false;
                }
                sb.Append("]");
            }
            else
            {
                sb.Append(",f5=[0][]");
            }
            if (f6 != null)
            {
                bool first = true;
                sb.Append(",f6=[").Append(f6.Count).Append("][");
                foreach (var item in f6)
                {
                    if (item != null) sb.Append(first ? "" : ",").Append(item); else sb.Append(first ? "" : ",").Append("null");
                    first = false;
                }
                sb.Append("]");
            }
            else
            {
                sb.Append(",f6=[0][]");
            }
            if (f7 != null)
            {
                bool first = true;
                sb.Append(",f7=[").Append(f7.Count).Append("][");
                foreach (var item in f7)
                {
                    sb.Append(first ? "" : ",").Append(item);
                    first = false;
                }
                sb.Append("]");
            }
            else
            {
                sb.Append(",f7=[0][]");
            }
            if (f8 != null)
            {
                bool first = true;
                sb.Append(",f8=[").Append(f8.Count).Append("][");
                foreach (var item in f8)
                {
                    if (item != null) sb.Append(first ? "" : ",").Append(item); else sb.Append(first ? "" : ",").Append("null");
                    first = false;
                }
                sb.Append("]");
            }
            else
            {
                sb.Append(",f8=[0][]");
            }
            if (f9 != null)
            {
                bool first = true;
                sb.Append(",f9=[").Append(f9.Count).Append("][");
                foreach (var item in f9)
                {
                    sb.Append(first ? "" : ",").Append(item);
                    first = false;
                }
                sb.Append("]");
            }
            else
            {
                sb.Append(",f9=[0][]");
            }
            if (f10 != null)
            {
                bool first = true;
                sb.Append(",f10=[").Append(f10.Count).Append("][");
                foreach (var item in f10)
                {
                    if (item != null) sb.Append(first ? "" : ",").Append(item); else sb.Append(first ? "" : ",").Append("null");
                    first = false;
                }
                sb.Append("]");
            }
            else
            {
                sb.Append(",f10=[0][]");
            }
            sb.Append(")");
            return sb.ToString();
        }

        public string ToJson()
        {
            var json = com.chronoxor.FBE.Json.ToJson(this);
            return json;
        }

        public static StructVector FromJson(string json)
        {
            var result = com.chronoxor.FBE.Json.FromJson<StructVector>(json);
            return result;
        }

        public static com.chronoxor.FBE.FieldModelValueType<StructVector> CreateFieldModel(com.chronoxor.FBE.Buffer buffer, long offset) { return new test.FBE.FieldModelStructVector(buffer, offset); }
    }

} // namespace com.chronoxor.test

namespace com.chronoxor.test.FBE {

    using global::com.chronoxor.test;

    // Fast Binary Encoding StructVector field model
    public class FieldModelStructVector : com.chronoxor.FBE.FieldModelValueType<StructVector>
    {
        public readonly com.chronoxor.FBE.FieldModelVectorValueType<byte, com.chronoxor.FBE.FieldModelValueType<byte>> f1;
        public readonly com.chronoxor.FBE.FieldModelVectorOptionalValueType<byte, com.chronoxor.FBE.FieldModelValueType<byte>> f2;
        public readonly com.chronoxor.FBE.FieldModelVectorReferenceType<MemoryStream, com.chronoxor.FBE.FieldModelReferenceType<MemoryStream>> f3;
        public readonly com.chronoxor.FBE.FieldModelVectorOptionalReferenceType<MemoryStream, com.chronoxor.FBE.FieldModelReferenceType<MemoryStream>> f4;
        public readonly com.chronoxor.FBE.FieldModelVectorValueType<EnumSimple, com.chronoxor.test.FBE.FieldModelEnumSimple> f5;
        public readonly com.chronoxor.FBE.FieldModelVectorOptionalValueType<EnumSimple, com.chronoxor.test.FBE.FieldModelEnumSimple> f6;
        public readonly com.chronoxor.FBE.FieldModelVectorValueType<FlagsSimple, com.chronoxor.test.FBE.FieldModelFlagsSimple> f7;
        public readonly com.chronoxor.FBE.FieldModelVectorOptionalValueType<FlagsSimple, com.chronoxor.test.FBE.FieldModelFlagsSimple> f8;
        public readonly com.chronoxor.FBE.FieldModelVectorValueType<StructSimple, com.chronoxor.test.FBE.FieldModelStructSimple> f9;
        public readonly com.chronoxor.FBE.FieldModelVectorOptionalValueType<StructSimple, com.chronoxor.test.FBE.FieldModelStructSimple> f10;

        public FieldModelStructVector(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset)
        {
            f1 = new com.chronoxor.FBE.FieldModelVectorValueType<byte, com.chronoxor.FBE.FieldModelValueType<byte>>(com.chronoxor.FBE.FieldModelValueType<byte>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.BYTE, buffer, 4 + 4), buffer, 4 + 4);
            f2 = new com.chronoxor.FBE.FieldModelVectorOptionalValueType<byte, com.chronoxor.FBE.FieldModelValueType<byte>>(com.chronoxor.FBE.FieldModelValueType<byte>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.BYTE, buffer, f1.FBEOffset + f1.FBESize), buffer, f1.FBEOffset + f1.FBESize);
            f3 = new com.chronoxor.FBE.FieldModelVectorReferenceType<MemoryStream, com.chronoxor.FBE.FieldModelReferenceType<MemoryStream>>(com.chronoxor.FBE.FieldModelReferenceType<MemoryStream>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.BYTES, buffer, f2.FBEOffset + f2.FBESize), buffer, f2.FBEOffset + f2.FBESize);
            f4 = new com.chronoxor.FBE.FieldModelVectorOptionalReferenceType<MemoryStream, com.chronoxor.FBE.FieldModelReferenceType<MemoryStream>>(com.chronoxor.FBE.FieldModelReferenceType<MemoryStream>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.BYTES, buffer, f3.FBEOffset + f3.FBESize), buffer, f3.FBEOffset + f3.FBESize);
            f5 = new com.chronoxor.FBE.FieldModelVectorValueType<EnumSimple, com.chronoxor.test.FBE.FieldModelEnumSimple>(new com.chronoxor.test.FBE.FieldModelEnumSimple(buffer, f4.FBEOffset + f4.FBESize), buffer, f4.FBEOffset + f4.FBESize);
            f6 = new com.chronoxor.FBE.FieldModelVectorOptionalValueType<EnumSimple, com.chronoxor.test.FBE.FieldModelEnumSimple>(new com.chronoxor.test.FBE.FieldModelEnumSimple(buffer, f5.FBEOffset + f5.FBESize), buffer, f5.FBEOffset + f5.FBESize);
            f7 = new com.chronoxor.FBE.FieldModelVectorValueType<FlagsSimple, com.chronoxor.test.FBE.FieldModelFlagsSimple>(new com.chronoxor.test.FBE.FieldModelFlagsSimple(buffer, f6.FBEOffset + f6.FBESize), buffer, f6.FBEOffset + f6.FBESize);
            f8 = new com.chronoxor.FBE.FieldModelVectorOptionalValueType<FlagsSimple, com.chronoxor.test.FBE.FieldModelFlagsSimple>(new com.chronoxor.test.FBE.FieldModelFlagsSimple(buffer, f7.FBEOffset + f7.FBESize), buffer, f7.FBEOffset + f7.FBESize);
            f9 = new com.chronoxor.FBE.FieldModelVectorValueType<StructSimple, com.chronoxor.test.FBE.FieldModelStructSimple>(new com.chronoxor.test.FBE.FieldModelStructSimple(buffer, f8.FBEOffset + f8.FBESize), buffer, f8.FBEOffset + f8.FBESize);
            f10 = new com.chronoxor.FBE.FieldModelVectorOptionalValueType<StructSimple, com.chronoxor.test.FBE.FieldModelStructSimple>(new com.chronoxor.test.FBE.FieldModelStructSimple(buffer, f9.FBEOffset + f9.FBESize), buffer, f9.FBEOffset + f9.FBESize);
        }

        // Get the field size
        public override long FBESize => 4;
        // Get the field body size
        public long FBEBody
        {
            get
            {
                long fbeResult = 4 + 4
                    + f1.FBESize
                    + f2.FBESize
                    + f3.FBESize
                    + f4.FBESize
                    + f5.FBESize
                    + f6.FBESize
                    + f7.FBESize
                    + f8.FBESize
                    + f9.FBESize
                    + f10.FBESize
                    ;
                return fbeResult;
            }
        }
        // Get the field extra size
        public override long FBEExtra
        {
            get
            {
                if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                    return 0;

                uint fbeStructOffset = ReadUInt32(FBEOffset);
                if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4) > _buffer.Size))
                    return 0;

                _buffer.Shift(fbeStructOffset);

                long fbeResult = FBEBody
                    + f1.FBEExtra
                    + f2.FBEExtra
                    + f3.FBEExtra
                    + f4.FBEExtra
                    + f5.FBEExtra
                    + f6.FBEExtra
                    + f7.FBEExtra
                    + f8.FBEExtra
                    + f9.FBEExtra
                    + f10.FBEExtra
                    ;

                _buffer.Unshift(fbeStructOffset);

                return fbeResult;
            }
        }
        // Get the field type
        public const long FBETypeConst = 130;
        public long FBEType => FBETypeConst;

        // Clone the field model
        public override com.chronoxor.FBE.FieldModelValueType<StructVector> Clone() { return new FieldModelStructVector(_buffer, _offset); }

        // Check if the struct value is valid
        public override bool Verify() { return Verify(true); }
        public bool Verify(bool fbeVerifyType)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return true;

            uint fbeStructOffset = ReadUInt32(FBEOffset);
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
                return false;

            uint fbeStructSize = ReadUInt32(fbeStructOffset);
            if (fbeStructSize < (4 + 4))
                return false;

            uint fbeStructType = ReadUInt32(fbeStructOffset + 4);
            if (fbeVerifyType && (fbeStructType != FBEType))
                return false;

            _buffer.Shift(fbeStructOffset);
            bool fbeResult = VerifyFields(fbeStructSize);
            _buffer.Unshift(fbeStructOffset);
            return fbeResult;
        }

        // Check if the struct fields are valid
        public bool VerifyFields(long fbeStructSize)
        {
            long fbeCurrentSize = 4 + 4;

            if ((fbeCurrentSize + f1.FBESize) > fbeStructSize)
                return true;
            if (!f1.Verify())
                return false;
            fbeCurrentSize += f1.FBESize;

            if ((fbeCurrentSize + f2.FBESize) > fbeStructSize)
                return true;
            if (!f2.Verify())
                return false;
            fbeCurrentSize += f2.FBESize;

            if ((fbeCurrentSize + f3.FBESize) > fbeStructSize)
                return true;
            if (!f3.Verify())
                return false;
            fbeCurrentSize += f3.FBESize;

            if ((fbeCurrentSize + f4.FBESize) > fbeStructSize)
                return true;
            if (!f4.Verify())
                return false;
            fbeCurrentSize += f4.FBESize;

            if ((fbeCurrentSize + f5.FBESize) > fbeStructSize)
                return true;
            if (!f5.Verify())
                return false;
            fbeCurrentSize += f5.FBESize;

            if ((fbeCurrentSize + f6.FBESize) > fbeStructSize)
                return true;
            if (!f6.Verify())
                return false;
            fbeCurrentSize += f6.FBESize;

            if ((fbeCurrentSize + f7.FBESize) > fbeStructSize)
                return true;
            if (!f7.Verify())
                return false;
            fbeCurrentSize += f7.FBESize;

            if ((fbeCurrentSize + f8.FBESize) > fbeStructSize)
                return true;
            if (!f8.Verify())
                return false;
            fbeCurrentSize += f8.FBESize;

            if ((fbeCurrentSize + f9.FBESize) > fbeStructSize)
                return true;
            if (!f9.Verify())
                return false;
            fbeCurrentSize += f9.FBESize;

            if ((fbeCurrentSize + f10.FBESize) > fbeStructSize)
                return true;
            if (!f10.Verify())
                return false;
            fbeCurrentSize += f10.FBESize;

            return true;
        }

        // Get the struct value (begin phase)
        public long GetBegin()
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            uint fbeStructOffset = ReadUInt32(FBEOffset);
            Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + 4 + 4) <= _buffer.Size)), "Model is broken!");
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
                return 0;

            uint fbeStructSize = ReadUInt32(fbeStructOffset);
            Debug.Assert((fbeStructSize >= (4 + 4)), "Model is broken!");
            if (fbeStructSize < (4 + 4))
                return 0;

            _buffer.Shift(fbeStructOffset);
            return fbeStructOffset;
        }

        // Get the struct value (end phase)
        public void GetEnd(long fbeBegin)
        {
            _buffer.Unshift(fbeBegin);
        }

        // Get the struct value
        public override void Get(out StructVector fbeValue) { Get(out fbeValue, StructVector.Default); }
        public override void Get(out StructVector fbeValue, StructVector defaults)
        {
            long fbeBegin = GetBegin();
            if (fbeBegin == 0)
            {
                fbeValue = defaults;
                return;
            }

            uint fbeStructSize = ReadUInt32(0);
            GetFields(out fbeValue, fbeStructSize);
            GetEnd(fbeBegin);
        }

        // Get the struct fields values
        public void GetFields(out StructVector fbeValue, long fbeStructSize)
        {
            long fbeCurrentSize = 4 + 4;

            fbeValue = StructVector.Default;

            if ((fbeCurrentSize + f1.FBESize) <= fbeStructSize)
                f1.Get(ref fbeValue.f1);
            else
                fbeValue.f1.Clear();
            fbeCurrentSize += f1.FBESize;

            if ((fbeCurrentSize + f2.FBESize) <= fbeStructSize)
                f2.Get(ref fbeValue.f2);
            else
                fbeValue.f2.Clear();
            fbeCurrentSize += f2.FBESize;

            if ((fbeCurrentSize + f3.FBESize) <= fbeStructSize)
                f3.Get(ref fbeValue.f3);
            else
                fbeValue.f3.Clear();
            fbeCurrentSize += f3.FBESize;

            if ((fbeCurrentSize + f4.FBESize) <= fbeStructSize)
                f4.Get(ref fbeValue.f4);
            else
                fbeValue.f4.Clear();
            fbeCurrentSize += f4.FBESize;

            if ((fbeCurrentSize + f5.FBESize) <= fbeStructSize)
                f5.Get(ref fbeValue.f5);
            else
                fbeValue.f5.Clear();
            fbeCurrentSize += f5.FBESize;

            if ((fbeCurrentSize + f6.FBESize) <= fbeStructSize)
                f6.Get(ref fbeValue.f6);
            else
                fbeValue.f6.Clear();
            fbeCurrentSize += f6.FBESize;

            if ((fbeCurrentSize + f7.FBESize) <= fbeStructSize)
                f7.Get(ref fbeValue.f7);
            else
                fbeValue.f7.Clear();
            fbeCurrentSize += f7.FBESize;

            if ((fbeCurrentSize + f8.FBESize) <= fbeStructSize)
                f8.Get(ref fbeValue.f8);
            else
                fbeValue.f8.Clear();
            fbeCurrentSize += f8.FBESize;

            if ((fbeCurrentSize + f9.FBESize) <= fbeStructSize)
                f9.Get(ref fbeValue.f9);
            else
                fbeValue.f9.Clear();
            fbeCurrentSize += f9.FBESize;

            if ((fbeCurrentSize + f10.FBESize) <= fbeStructSize)
                f10.Get(ref fbeValue.f10);
            else
                fbeValue.f10.Clear();
            fbeCurrentSize += f10.FBESize;
        }

        // Set the struct value (begin phase)
        public long SetBegin()
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            uint fbeStructSize = (uint)FBEBody;
            uint fbeStructOffset = (uint)(_buffer.Allocate(fbeStructSize) - _buffer.Offset);
            Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + fbeStructSize) <= _buffer.Size)), "Model is broken!");
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + fbeStructSize) > _buffer.Size))
                return 0;

            Write(FBEOffset, fbeStructOffset);
            Write(fbeStructOffset, fbeStructSize);
            Write(fbeStructOffset + 4, (uint)FBEType);

            _buffer.Shift(fbeStructOffset);
            return fbeStructOffset;
        }

        // Set the struct value (end phase)
        public void SetEnd(long fbeBegin)
        {
            _buffer.Unshift(fbeBegin);
        }

        // Set the struct value
        public override void Set(StructVector fbeValue)
        {
            long fbeBegin = SetBegin();
            if (fbeBegin == 0)
                return;

            SetFields(fbeValue);
            SetEnd(fbeBegin);
        }

        // Set the struct fields values
        public void SetFields(StructVector fbeValue)
        {
            f1.Set(fbeValue.f1);
            f2.Set(fbeValue.f2);
            f3.Set(fbeValue.f3);
            f4.Set(fbeValue.f4);
            f5.Set(fbeValue.f5);
            f6.Set(fbeValue.f6);
            f7.Set(fbeValue.f7);
            f8.Set(fbeValue.f8);
            f9.Set(fbeValue.f9);
            f10.Set(fbeValue.f10);
        }
    }

} // namespace com.chronoxor.test.FBE

namespace com.chronoxor.test.FBE {

    using global::com.chronoxor.test;

    // Fast Binary Encoding StructVector model
    public class StructVectorModel : com.chronoxor.FBE.Model
    {
        public readonly FieldModelStructVector model;

        public StructVectorModel() { model = new FieldModelStructVector(Buffer, 4); }
        public StructVectorModel(com.chronoxor.FBE.Buffer buffer) : base(buffer) { model = new FieldModelStructVector(Buffer, 4); }

        // Get the model size
        public long FBESize => model.FBESize + model.FBEExtra;
        // Get the model type
        public const long FBETypeConst = FieldModelStructVector.FBETypeConst;
        public long FBEType => FBETypeConst;

        // Check if the struct value is valid
        public bool Verify()
        {
            if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
                return false;

            uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
            if (fbeFullSize < model.FBESize)
                return false;

            return model.Verify();
        }

        // Create a new model (begin phase)
        public long CreateBegin()
        {
            long fbeBegin = Buffer.Allocate(4 + model.FBESize);
            return fbeBegin;
        }

        // Create a new model (end phase)
        public long CreateEnd(long fbeBegin)
        {
            long fbeEnd = Buffer.Size;
            uint fbeFullSize = (uint)(fbeEnd - fbeBegin);
            Write(model.FBEOffset - 4, fbeFullSize);
            return fbeFullSize;
        }

        // Serialize the struct value
        public long Serialize(StructVector value)
        {
            long fbeBegin = CreateBegin();
            model.Set(value);
            long fbeFullSize = CreateEnd(fbeBegin);
            return fbeFullSize;
        }

        // Deserialize the struct value
        public long Deserialize(out StructVector value)
        {
            if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
            {
                value = StructVector.Default;
                return 0;
            }

            uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
            Debug.Assert((fbeFullSize >= model.FBESize), "Model is broken!");
            if (fbeFullSize < model.FBESize)
            {
                value = StructVector.Default;
                return 0;
            }

            model.Get(out value);
            return fbeFullSize;
        }

        // Move to the next struct value
        public void Next(long prev)
        {
            model.FBEShift(prev);
        }
    }

} // namespace com.chronoxor.test.FBE

namespace com.chronoxor.test.FBE {

    using global::com.chronoxor.test;

    // Fast Binary Encoding StructVector final model
    public class FinalModelStructVector : com.chronoxor.FBE.FinalModelValueType<StructVector>
    {
        public readonly com.chronoxor.FBE.FinalModelVectorValueType<byte, com.chronoxor.FBE.FinalModelValueType<byte>> f1;
        public readonly com.chronoxor.FBE.FinalModelVectorOptionalValueType<byte, com.chronoxor.FBE.FinalModelValueType<byte>> f2;
        public readonly com.chronoxor.FBE.FinalModelVectorReferenceType<MemoryStream, com.chronoxor.FBE.FinalModelReferenceType<MemoryStream>> f3;
        public readonly com.chronoxor.FBE.FinalModelVectorOptionalReferenceType<MemoryStream, com.chronoxor.FBE.FinalModelReferenceType<MemoryStream>> f4;
        public readonly com.chronoxor.FBE.FinalModelVectorValueType<EnumSimple, com.chronoxor.test.FBE.FinalModelEnumSimple> f5;
        public readonly com.chronoxor.FBE.FinalModelVectorOptionalValueType<EnumSimple, com.chronoxor.test.FBE.FinalModelEnumSimple> f6;
        public readonly com.chronoxor.FBE.FinalModelVectorValueType<FlagsSimple, com.chronoxor.test.FBE.FinalModelFlagsSimple> f7;
        public readonly com.chronoxor.FBE.FinalModelVectorOptionalValueType<FlagsSimple, com.chronoxor.test.FBE.FinalModelFlagsSimple> f8;
        public readonly com.chronoxor.FBE.FinalModelVectorValueType<StructSimple, com.chronoxor.test.FBE.FinalModelStructSimple> f9;
        public readonly com.chronoxor.FBE.FinalModelVectorOptionalValueType<StructSimple, com.chronoxor.test.FBE.FinalModelStructSimple> f10;

        public FinalModelStructVector(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset)
        {
            f1 = new com.chronoxor.FBE.FinalModelVectorValueType<byte, com.chronoxor.FBE.FinalModelValueType<byte>>(com.chronoxor.FBE.FinalModelValueType<byte>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.BYTE, buffer, 0), buffer, 0);
            f2 = new com.chronoxor.FBE.FinalModelVectorOptionalValueType<byte, com.chronoxor.FBE.FinalModelValueType<byte>>(com.chronoxor.FBE.FinalModelValueType<byte>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.BYTE, buffer, 0), buffer, 0);
            f3 = new com.chronoxor.FBE.FinalModelVectorReferenceType<MemoryStream, com.chronoxor.FBE.FinalModelReferenceType<MemoryStream>>(com.chronoxor.FBE.FinalModelReferenceType<MemoryStream>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.BYTES, buffer, 0), buffer, 0);
            f4 = new com.chronoxor.FBE.FinalModelVectorOptionalReferenceType<MemoryStream, com.chronoxor.FBE.FinalModelReferenceType<MemoryStream>>(com.chronoxor.FBE.FinalModelReferenceType<MemoryStream>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.BYTES, buffer, 0), buffer, 0);
            f5 = new com.chronoxor.FBE.FinalModelVectorValueType<EnumSimple, com.chronoxor.test.FBE.FinalModelEnumSimple>(new com.chronoxor.test.FBE.FinalModelEnumSimple(buffer, 0), buffer, 0);
            f6 = new com.chronoxor.FBE.FinalModelVectorOptionalValueType<EnumSimple, com.chronoxor.test.FBE.FinalModelEnumSimple>(new com.chronoxor.test.FBE.FinalModelEnumSimple(buffer, 0), buffer, 0);
            f7 = new com.chronoxor.FBE.FinalModelVectorValueType<FlagsSimple, com.chronoxor.test.FBE.FinalModelFlagsSimple>(new com.chronoxor.test.FBE.FinalModelFlagsSimple(buffer, 0), buffer, 0);
            f8 = new com.chronoxor.FBE.FinalModelVectorOptionalValueType<FlagsSimple, com.chronoxor.test.FBE.FinalModelFlagsSimple>(new com.chronoxor.test.FBE.FinalModelFlagsSimple(buffer, 0), buffer, 0);
            f9 = new com.chronoxor.FBE.FinalModelVectorValueType<StructSimple, com.chronoxor.test.FBE.FinalModelStructSimple>(new com.chronoxor.test.FBE.FinalModelStructSimple(buffer, 0), buffer, 0);
            f10 = new com.chronoxor.FBE.FinalModelVectorOptionalValueType<StructSimple, com.chronoxor.test.FBE.FinalModelStructSimple>(new com.chronoxor.test.FBE.FinalModelStructSimple(buffer, 0), buffer, 0);
        }

        // Get the allocation size
        public override long FBEAllocationSize(StructVector fbeValue)
        {
            long fbeResult = 0
                + f1.FBEAllocationSize(fbeValue.f1)
                + f2.FBEAllocationSize(fbeValue.f2)
                + f3.FBEAllocationSize(fbeValue.f3)
                + f4.FBEAllocationSize(fbeValue.f4)
                + f5.FBEAllocationSize(fbeValue.f5)
                + f6.FBEAllocationSize(fbeValue.f6)
                + f7.FBEAllocationSize(fbeValue.f7)
                + f8.FBEAllocationSize(fbeValue.f8)
                + f9.FBEAllocationSize(fbeValue.f9)
                + f10.FBEAllocationSize(fbeValue.f10)
                ;
            return fbeResult;
        }

        // Get the final type
        public const long FBETypeConst = 130;
        public long FBEType => FBETypeConst;

        // Clone the final model
        public override com.chronoxor.FBE.FinalModelValueType<StructVector> Clone() { return new FinalModelStructVector(_buffer, _offset); }

        // Check if the struct value is valid
        public override long Verify()
        {
            _buffer.Shift(FBEOffset);
            long fbeResult = VerifyFields();
            _buffer.Unshift(FBEOffset);
            return fbeResult;
        }

        // Check if the struct fields are valid
        public long VerifyFields()
        {
            long fbeCurrentOffset = 0;
            long fbeFieldSize;

            f1.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f1.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f2.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f2.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f3.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f3.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f4.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f4.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f5.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f5.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f6.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f6.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f7.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f7.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f8.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f8.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f9.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f9.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f10.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f10.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            return fbeCurrentOffset;
        }

        // Get the struct value
        public override long Get(out StructVector fbeValue)
        {
            _buffer.Shift(FBEOffset);
            long fbeSize = GetFields(out fbeValue);
            _buffer.Unshift(FBEOffset);
            return fbeSize;
        }

        // Get the struct fields values
        public long GetFields(out StructVector fbeValue)
        {
            long fbeCurrentOffset = 0;
            long fbeCurrentSize = 0;
            long fbeFieldSize;

            fbeValue = StructVector.Default;

            f1.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f1.Get(out fbeValue.f1);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f2.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f2.Get(out fbeValue.f2);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f3.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f3.Get(out fbeValue.f3);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f4.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f4.Get(out fbeValue.f4);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f5.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f5.Get(out fbeValue.f5);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f6.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f6.Get(out fbeValue.f6);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f7.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f7.Get(out fbeValue.f7);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f8.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f8.Get(out fbeValue.f8);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f9.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f9.Get(out fbeValue.f9);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f10.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f10.Get(out fbeValue.f10);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            return fbeCurrentSize;
        }

        // Set the struct value
        public override long Set(StructVector fbeValue)
        {
            _buffer.Shift(FBEOffset);
            long fbeResult = SetFields(fbeValue);
            _buffer.Unshift(FBEOffset);
            return fbeResult;
        }

        // Set the struct fields values
        public long SetFields(StructVector fbeValue)
        {
            long fbeCurrentOffset = 0;
            long fbeCurrentSize = 0;
            long fbeFieldSize;

            f1.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f1.Set(fbeValue.f1);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f2.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f2.Set(fbeValue.f2);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f3.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f3.Set(fbeValue.f3);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f4.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f4.Set(fbeValue.f4);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f5.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f5.Set(fbeValue.f5);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f6.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f6.Set(fbeValue.f6);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f7.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f7.Set(fbeValue.f7);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f8.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f8.Set(fbeValue.f8);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f9.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f9.Set(fbeValue.f9);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f10.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f10.Set(fbeValue.f10);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            return fbeCurrentSize;
        }
    }

} // namespace com.chronoxor.test.FBE

namespace com.chronoxor.test.FBE {

    using global::com.chronoxor.test;

    // Fast Binary Encoding StructVector final model
    public class StructVectorFinalModel : com.chronoxor.FBE.Model
    {
        private readonly FinalModelStructVector _model;

        public StructVectorFinalModel() { _model = new FinalModelStructVector(Buffer, 8); }
        public StructVectorFinalModel(com.chronoxor.FBE.Buffer buffer) : base(buffer) { _model = new FinalModelStructVector(Buffer, 8); }

        // Get the model type
        public const long FBETypeConst = FinalModelStructVector.FBETypeConst;
        public long FBEType => FBETypeConst;

        // Check if the struct value is valid
        public bool Verify()
        {
            if ((Buffer.Offset + _model.FBEOffset) > Buffer.Size)
                return false;

            long fbeStructSize = ReadUInt32(_model.FBEOffset - 8);
            long fbeStructType = ReadUInt32(_model.FBEOffset - 4);
            if ((fbeStructSize <= 0) || (fbeStructType != FBEType))
                return false;

            return ((8 + _model.Verify()) == fbeStructSize);
        }

        // Serialize the struct value
        public long Serialize(StructVector value)
        {
            long fbeInitialSize = Buffer.Size;

            uint fbeStructType = (uint)FBEType;
            uint fbeStructSize = (uint)(8 + _model.FBEAllocationSize(value));
            uint fbeStructOffset = (uint)(Buffer.Allocate(fbeStructSize) - Buffer.Offset);
            Debug.Assert(((Buffer.Offset + fbeStructOffset + fbeStructSize) <= Buffer.Size), "Model is broken!");
            if ((Buffer.Offset + fbeStructOffset + fbeStructSize) > Buffer.Size)
                return 0;

            fbeStructSize = (uint)(8 + _model.Set(value));
            Buffer.Resize(fbeInitialSize + fbeStructSize);

            Write(_model.FBEOffset - 8, fbeStructSize);
            Write(_model.FBEOffset - 4, fbeStructType);

            return fbeStructSize;
        }

        // Deserialize the struct value
        public long Deserialize(out StructVector value)
        {
            Debug.Assert(((Buffer.Offset + _model.FBEOffset) <= Buffer.Size), "Model is broken!");
            if ((Buffer.Offset + _model.FBEOffset) > Buffer.Size)
            {
                value = StructVector.Default;
                return 0;
            }

            long fbeStructSize = ReadUInt32(_model.FBEOffset - 8);
            long fbeStructType = ReadUInt32(_model.FBEOffset - 4);
            Debug.Assert(((fbeStructSize > 0) && (fbeStructType == FBEType)), "Model is broken!");
            if ((fbeStructSize <= 0) || (fbeStructType != FBEType))
            {
                value = StructVector.Default;
                return 8;
            }

            return 8 + _model.Get(out value);
        }

        // Move to the next struct value
        public void Next(long prev)
        {
            _model.FBEShift(prev);
        }
    }

} // namespace com.chronoxor.test.FBE

namespace com.chronoxor.test {

    public struct StructList : IComparable, IComparable<StructList>, IEquatable<StructList>
    {
        public LinkedList<byte> f1;
        public LinkedList<byte?> f2;
        public LinkedList<MemoryStream> f3;
        public LinkedList<MemoryStream> f4;
        public LinkedList<EnumSimple> f5;
        public LinkedList<EnumSimple?> f6;
        public LinkedList<FlagsSimple> f7;
        public LinkedList<FlagsSimple?> f8;
        public LinkedList<StructSimple> f9;
        public LinkedList<StructSimple?> f10;

        public const long FBETypeConst = 131;
        #if UTF8JSON
        [IgnoreDataMember]
        #else
        [JsonIgnore]
        #endif
        public long FBEType => FBETypeConst;

        public static StructList Default => new StructList
        {
            f1 = new LinkedList<byte>()
            , f2 = new LinkedList<byte?>()
            , f3 = new LinkedList<MemoryStream>()
            , f4 = new LinkedList<MemoryStream>()
            , f5 = new LinkedList<EnumSimple>()
            , f6 = new LinkedList<EnumSimple?>()
            , f7 = new LinkedList<FlagsSimple>()
            , f8 = new LinkedList<FlagsSimple?>()
            , f9 = new LinkedList<StructSimple>()
            , f10 = new LinkedList<StructSimple?>()
        };

        public StructList(LinkedList<byte> f1, LinkedList<byte?> f2, LinkedList<MemoryStream> f3, LinkedList<MemoryStream> f4, LinkedList<EnumSimple> f5, LinkedList<EnumSimple?> f6, LinkedList<FlagsSimple> f7, LinkedList<FlagsSimple?> f8, LinkedList<StructSimple> f9, LinkedList<StructSimple?> f10)
        {
            this.f1 = f1;
            this.f2 = f2;
            this.f3 = f3;
            this.f4 = f4;
            this.f5 = f5;
            this.f6 = f6;
            this.f7 = f7;
            this.f8 = f8;
            this.f9 = f9;
            this.f10 = f10;
        }

        public StructList Clone()
        {
            // Serialize the struct to the FBE stream
            var writer = new com.chronoxor.test.FBE.StructListModel();
            writer.Serialize(this);

            // Deserialize the struct from the FBE stream
            var reader = new com.chronoxor.test.FBE.StructListModel();
            reader.Attach(writer.Buffer);
            reader.Deserialize(out var result);
            return result;
        }

        public int CompareTo(object other)
        {
            int result = 0;
            return result;
        }

        public int CompareTo(StructList other)
        {
            int result = 0;
            return result;
        }

        public override bool Equals(object other)
        {
            if (!(other is StructList))
                return false;
            return true;
        }

        public bool Equals(StructList other)
        {
            return true;
        }

        public override int GetHashCode()
        {
            int hash = 17;
            return hash;
        }

        public static bool operator==(StructList lhs, StructList rhs) => lhs.Equals(rhs);
        public static bool operator!=(StructList lhs, StructList rhs) => !(lhs == rhs);

        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("StructList(");
            if (f1 != null)
            {
                bool first = true;
                sb.Append("f1=[").Append(f1.Count).Append("]<");
                foreach (var item in f1)
                {
                    sb.Append(first ? "" : ",").Append(item);
                    first = false;
                }
                sb.Append(">");
            }
            else
            {
                sb.Append("f1=[0]<>");
            }
            if (f2 != null)
            {
                bool first = true;
                sb.Append(",f2=[").Append(f2.Count).Append("]<");
                foreach (var item in f2)
                {
                    if (item != null) sb.Append(first ? "" : ",").Append(item); else sb.Append(first ? "" : ",").Append("null");
                    first = false;
                }
                sb.Append(">");
            }
            else
            {
                sb.Append(",f2=[0]<>");
            }
            if (f3 != null)
            {
                bool first = true;
                sb.Append(",f3=[").Append(f3.Count).Append("]<");
                foreach (var item in f3)
                {
                    if (item != null) sb.Append(first ? "" : ",").Append("bytes[").Append(item.Length).Append("]"); else sb.Append(first ? "" : ",").Append("null");
                    first = false;
                }
                sb.Append(">");
            }
            else
            {
                sb.Append(",f3=[0]<>");
            }
            if (f4 != null)
            {
                bool first = true;
                sb.Append(",f4=[").Append(f4.Count).Append("]<");
                foreach (var item in f4)
                {
                    if (item != null) sb.Append(first ? "" : ",").Append("bytes[").Append(item.Length).Append("]"); else sb.Append(first ? "" : ",").Append("null");
                    first = false;
                }
                sb.Append(">");
            }
            else
            {
                sb.Append(",f4=[0]<>");
            }
            if (f5 != null)
            {
                bool first = true;
                sb.Append(",f5=[").Append(f5.Count).Append("]<");
                foreach (var item in f5)
                {
                    sb.Append(first ? "" : ",").Append(item);
                    first = false;
                }
                sb.Append(">");
            }
            else
            {
                sb.Append(",f5=[0]<>");
            }
            if (f6 != null)
            {
                bool first = true;
                sb.Append(",f6=[").Append(f6.Count).Append("]<");
                foreach (var item in f6)
                {
                    if (item != null) sb.Append(first ? "" : ",").Append(item); else sb.Append(first ? "" : ",").Append("null");
                    first = false;
                }
                sb.Append(">");
            }
            else
            {
                sb.Append(",f6=[0]<>");
            }
            if (f7 != null)
            {
                bool first = true;
                sb.Append(",f7=[").Append(f7.Count).Append("]<");
                foreach (var item in f7)
                {
                    sb.Append(first ? "" : ",").Append(item);
                    first = false;
                }
                sb.Append(">");
            }
            else
            {
                sb.Append(",f7=[0]<>");
            }
            if (f8 != null)
            {
                bool first = true;
                sb.Append(",f8=[").Append(f8.Count).Append("]<");
                foreach (var item in f8)
                {
                    if (item != null) sb.Append(first ? "" : ",").Append(item); else sb.Append(first ? "" : ",").Append("null");
                    first = false;
                }
                sb.Append(">");
            }
            else
            {
                sb.Append(",f8=[0]<>");
            }
            if (f9 != null)
            {
                bool first = true;
                sb.Append(",f9=[").Append(f9.Count).Append("]<");
                foreach (var item in f9)
                {
                    sb.Append(first ? "" : ",").Append(item);
                    first = false;
                }
                sb.Append(">");
            }
            else
            {
                sb.Append(",f9=[0]<>");
            }
            if (f10 != null)
            {
                bool first = true;
                sb.Append(",f10=[").Append(f10.Count).Append("]<");
                foreach (var item in f10)
                {
                    if (item != null) sb.Append(first ? "" : ",").Append(item); else sb.Append(first ? "" : ",").Append("null");
                    first = false;
                }
                sb.Append(">");
            }
            else
            {
                sb.Append(",f10=[0]<>");
            }
            sb.Append(")");
            return sb.ToString();
        }

        public string ToJson()
        {
            var json = com.chronoxor.FBE.Json.ToJson(this);
            return json;
        }

        public static StructList FromJson(string json)
        {
            var result = com.chronoxor.FBE.Json.FromJson<StructList>(json);
            return result;
        }

        public static com.chronoxor.FBE.FieldModelValueType<StructList> CreateFieldModel(com.chronoxor.FBE.Buffer buffer, long offset) { return new test.FBE.FieldModelStructList(buffer, offset); }
    }

} // namespace com.chronoxor.test

namespace com.chronoxor.test.FBE {

    using global::com.chronoxor.test;

    // Fast Binary Encoding StructList field model
    public class FieldModelStructList : com.chronoxor.FBE.FieldModelValueType<StructList>
    {
        public readonly com.chronoxor.FBE.FieldModelVectorValueType<byte, com.chronoxor.FBE.FieldModelValueType<byte>> f1;
        public readonly com.chronoxor.FBE.FieldModelVectorOptionalValueType<byte, com.chronoxor.FBE.FieldModelValueType<byte>> f2;
        public readonly com.chronoxor.FBE.FieldModelVectorReferenceType<MemoryStream, com.chronoxor.FBE.FieldModelReferenceType<MemoryStream>> f3;
        public readonly com.chronoxor.FBE.FieldModelVectorOptionalReferenceType<MemoryStream, com.chronoxor.FBE.FieldModelReferenceType<MemoryStream>> f4;
        public readonly com.chronoxor.FBE.FieldModelVectorValueType<EnumSimple, com.chronoxor.test.FBE.FieldModelEnumSimple> f5;
        public readonly com.chronoxor.FBE.FieldModelVectorOptionalValueType<EnumSimple, com.chronoxor.test.FBE.FieldModelEnumSimple> f6;
        public readonly com.chronoxor.FBE.FieldModelVectorValueType<FlagsSimple, com.chronoxor.test.FBE.FieldModelFlagsSimple> f7;
        public readonly com.chronoxor.FBE.FieldModelVectorOptionalValueType<FlagsSimple, com.chronoxor.test.FBE.FieldModelFlagsSimple> f8;
        public readonly com.chronoxor.FBE.FieldModelVectorValueType<StructSimple, com.chronoxor.test.FBE.FieldModelStructSimple> f9;
        public readonly com.chronoxor.FBE.FieldModelVectorOptionalValueType<StructSimple, com.chronoxor.test.FBE.FieldModelStructSimple> f10;

        public FieldModelStructList(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset)
        {
            f1 = new com.chronoxor.FBE.FieldModelVectorValueType<byte, com.chronoxor.FBE.FieldModelValueType<byte>>(com.chronoxor.FBE.FieldModelValueType<byte>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.BYTE, buffer, 4 + 4), buffer, 4 + 4);
            f2 = new com.chronoxor.FBE.FieldModelVectorOptionalValueType<byte, com.chronoxor.FBE.FieldModelValueType<byte>>(com.chronoxor.FBE.FieldModelValueType<byte>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.BYTE, buffer, f1.FBEOffset + f1.FBESize), buffer, f1.FBEOffset + f1.FBESize);
            f3 = new com.chronoxor.FBE.FieldModelVectorReferenceType<MemoryStream, com.chronoxor.FBE.FieldModelReferenceType<MemoryStream>>(com.chronoxor.FBE.FieldModelReferenceType<MemoryStream>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.BYTES, buffer, f2.FBEOffset + f2.FBESize), buffer, f2.FBEOffset + f2.FBESize);
            f4 = new com.chronoxor.FBE.FieldModelVectorOptionalReferenceType<MemoryStream, com.chronoxor.FBE.FieldModelReferenceType<MemoryStream>>(com.chronoxor.FBE.FieldModelReferenceType<MemoryStream>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.BYTES, buffer, f3.FBEOffset + f3.FBESize), buffer, f3.FBEOffset + f3.FBESize);
            f5 = new com.chronoxor.FBE.FieldModelVectorValueType<EnumSimple, com.chronoxor.test.FBE.FieldModelEnumSimple>(new com.chronoxor.test.FBE.FieldModelEnumSimple(buffer, f4.FBEOffset + f4.FBESize), buffer, f4.FBEOffset + f4.FBESize);
            f6 = new com.chronoxor.FBE.FieldModelVectorOptionalValueType<EnumSimple, com.chronoxor.test.FBE.FieldModelEnumSimple>(new com.chronoxor.test.FBE.FieldModelEnumSimple(buffer, f5.FBEOffset + f5.FBESize), buffer, f5.FBEOffset + f5.FBESize);
            f7 = new com.chronoxor.FBE.FieldModelVectorValueType<FlagsSimple, com.chronoxor.test.FBE.FieldModelFlagsSimple>(new com.chronoxor.test.FBE.FieldModelFlagsSimple(buffer, f6.FBEOffset + f6.FBESize), buffer, f6.FBEOffset + f6.FBESize);
            f8 = new com.chronoxor.FBE.FieldModelVectorOptionalValueType<FlagsSimple, com.chronoxor.test.FBE.FieldModelFlagsSimple>(new com.chronoxor.test.FBE.FieldModelFlagsSimple(buffer, f7.FBEOffset + f7.FBESize), buffer, f7.FBEOffset + f7.FBESize);
            f9 = new com.chronoxor.FBE.FieldModelVectorValueType<StructSimple, com.chronoxor.test.FBE.FieldModelStructSimple>(new com.chronoxor.test.FBE.FieldModelStructSimple(buffer, f8.FBEOffset + f8.FBESize), buffer, f8.FBEOffset + f8.FBESize);
            f10 = new com.chronoxor.FBE.FieldModelVectorOptionalValueType<StructSimple, com.chronoxor.test.FBE.FieldModelStructSimple>(new com.chronoxor.test.FBE.FieldModelStructSimple(buffer, f9.FBEOffset + f9.FBESize), buffer, f9.FBEOffset + f9.FBESize);
        }

        // Get the field size
        public override long FBESize => 4;
        // Get the field body size
        public long FBEBody
        {
            get
            {
                long fbeResult = 4 + 4
                    + f1.FBESize
                    + f2.FBESize
                    + f3.FBESize
                    + f4.FBESize
                    + f5.FBESize
                    + f6.FBESize
                    + f7.FBESize
                    + f8.FBESize
                    + f9.FBESize
                    + f10.FBESize
                    ;
                return fbeResult;
            }
        }
        // Get the field extra size
        public override long FBEExtra
        {
            get
            {
                if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                    return 0;

                uint fbeStructOffset = ReadUInt32(FBEOffset);
                if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4) > _buffer.Size))
                    return 0;

                _buffer.Shift(fbeStructOffset);

                long fbeResult = FBEBody
                    + f1.FBEExtra
                    + f2.FBEExtra
                    + f3.FBEExtra
                    + f4.FBEExtra
                    + f5.FBEExtra
                    + f6.FBEExtra
                    + f7.FBEExtra
                    + f8.FBEExtra
                    + f9.FBEExtra
                    + f10.FBEExtra
                    ;

                _buffer.Unshift(fbeStructOffset);

                return fbeResult;
            }
        }
        // Get the field type
        public const long FBETypeConst = 131;
        public long FBEType => FBETypeConst;

        // Clone the field model
        public override com.chronoxor.FBE.FieldModelValueType<StructList> Clone() { return new FieldModelStructList(_buffer, _offset); }

        // Check if the struct value is valid
        public override bool Verify() { return Verify(true); }
        public bool Verify(bool fbeVerifyType)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return true;

            uint fbeStructOffset = ReadUInt32(FBEOffset);
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
                return false;

            uint fbeStructSize = ReadUInt32(fbeStructOffset);
            if (fbeStructSize < (4 + 4))
                return false;

            uint fbeStructType = ReadUInt32(fbeStructOffset + 4);
            if (fbeVerifyType && (fbeStructType != FBEType))
                return false;

            _buffer.Shift(fbeStructOffset);
            bool fbeResult = VerifyFields(fbeStructSize);
            _buffer.Unshift(fbeStructOffset);
            return fbeResult;
        }

        // Check if the struct fields are valid
        public bool VerifyFields(long fbeStructSize)
        {
            long fbeCurrentSize = 4 + 4;

            if ((fbeCurrentSize + f1.FBESize) > fbeStructSize)
                return true;
            if (!f1.Verify())
                return false;
            fbeCurrentSize += f1.FBESize;

            if ((fbeCurrentSize + f2.FBESize) > fbeStructSize)
                return true;
            if (!f2.Verify())
                return false;
            fbeCurrentSize += f2.FBESize;

            if ((fbeCurrentSize + f3.FBESize) > fbeStructSize)
                return true;
            if (!f3.Verify())
                return false;
            fbeCurrentSize += f3.FBESize;

            if ((fbeCurrentSize + f4.FBESize) > fbeStructSize)
                return true;
            if (!f4.Verify())
                return false;
            fbeCurrentSize += f4.FBESize;

            if ((fbeCurrentSize + f5.FBESize) > fbeStructSize)
                return true;
            if (!f5.Verify())
                return false;
            fbeCurrentSize += f5.FBESize;

            if ((fbeCurrentSize + f6.FBESize) > fbeStructSize)
                return true;
            if (!f6.Verify())
                return false;
            fbeCurrentSize += f6.FBESize;

            if ((fbeCurrentSize + f7.FBESize) > fbeStructSize)
                return true;
            if (!f7.Verify())
                return false;
            fbeCurrentSize += f7.FBESize;

            if ((fbeCurrentSize + f8.FBESize) > fbeStructSize)
                return true;
            if (!f8.Verify())
                return false;
            fbeCurrentSize += f8.FBESize;

            if ((fbeCurrentSize + f9.FBESize) > fbeStructSize)
                return true;
            if (!f9.Verify())
                return false;
            fbeCurrentSize += f9.FBESize;

            if ((fbeCurrentSize + f10.FBESize) > fbeStructSize)
                return true;
            if (!f10.Verify())
                return false;
            fbeCurrentSize += f10.FBESize;

            return true;
        }

        // Get the struct value (begin phase)
        public long GetBegin()
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            uint fbeStructOffset = ReadUInt32(FBEOffset);
            Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + 4 + 4) <= _buffer.Size)), "Model is broken!");
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
                return 0;

            uint fbeStructSize = ReadUInt32(fbeStructOffset);
            Debug.Assert((fbeStructSize >= (4 + 4)), "Model is broken!");
            if (fbeStructSize < (4 + 4))
                return 0;

            _buffer.Shift(fbeStructOffset);
            return fbeStructOffset;
        }

        // Get the struct value (end phase)
        public void GetEnd(long fbeBegin)
        {
            _buffer.Unshift(fbeBegin);
        }

        // Get the struct value
        public override void Get(out StructList fbeValue) { Get(out fbeValue, StructList.Default); }
        public override void Get(out StructList fbeValue, StructList defaults)
        {
            long fbeBegin = GetBegin();
            if (fbeBegin == 0)
            {
                fbeValue = defaults;
                return;
            }

            uint fbeStructSize = ReadUInt32(0);
            GetFields(out fbeValue, fbeStructSize);
            GetEnd(fbeBegin);
        }

        // Get the struct fields values
        public void GetFields(out StructList fbeValue, long fbeStructSize)
        {
            long fbeCurrentSize = 4 + 4;

            fbeValue = StructList.Default;

            if ((fbeCurrentSize + f1.FBESize) <= fbeStructSize)
                f1.Get(ref fbeValue.f1);
            else
                fbeValue.f1.Clear();
            fbeCurrentSize += f1.FBESize;

            if ((fbeCurrentSize + f2.FBESize) <= fbeStructSize)
                f2.Get(ref fbeValue.f2);
            else
                fbeValue.f2.Clear();
            fbeCurrentSize += f2.FBESize;

            if ((fbeCurrentSize + f3.FBESize) <= fbeStructSize)
                f3.Get(ref fbeValue.f3);
            else
                fbeValue.f3.Clear();
            fbeCurrentSize += f3.FBESize;

            if ((fbeCurrentSize + f4.FBESize) <= fbeStructSize)
                f4.Get(ref fbeValue.f4);
            else
                fbeValue.f4.Clear();
            fbeCurrentSize += f4.FBESize;

            if ((fbeCurrentSize + f5.FBESize) <= fbeStructSize)
                f5.Get(ref fbeValue.f5);
            else
                fbeValue.f5.Clear();
            fbeCurrentSize += f5.FBESize;

            if ((fbeCurrentSize + f6.FBESize) <= fbeStructSize)
                f6.Get(ref fbeValue.f6);
            else
                fbeValue.f6.Clear();
            fbeCurrentSize += f6.FBESize;

            if ((fbeCurrentSize + f7.FBESize) <= fbeStructSize)
                f7.Get(ref fbeValue.f7);
            else
                fbeValue.f7.Clear();
            fbeCurrentSize += f7.FBESize;

            if ((fbeCurrentSize + f8.FBESize) <= fbeStructSize)
                f8.Get(ref fbeValue.f8);
            else
                fbeValue.f8.Clear();
            fbeCurrentSize += f8.FBESize;

            if ((fbeCurrentSize + f9.FBESize) <= fbeStructSize)
                f9.Get(ref fbeValue.f9);
            else
                fbeValue.f9.Clear();
            fbeCurrentSize += f9.FBESize;

            if ((fbeCurrentSize + f10.FBESize) <= fbeStructSize)
                f10.Get(ref fbeValue.f10);
            else
                fbeValue.f10.Clear();
            fbeCurrentSize += f10.FBESize;
        }

        // Set the struct value (begin phase)
        public long SetBegin()
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            uint fbeStructSize = (uint)FBEBody;
            uint fbeStructOffset = (uint)(_buffer.Allocate(fbeStructSize) - _buffer.Offset);
            Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + fbeStructSize) <= _buffer.Size)), "Model is broken!");
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + fbeStructSize) > _buffer.Size))
                return 0;

            Write(FBEOffset, fbeStructOffset);
            Write(fbeStructOffset, fbeStructSize);
            Write(fbeStructOffset + 4, (uint)FBEType);

            _buffer.Shift(fbeStructOffset);
            return fbeStructOffset;
        }

        // Set the struct value (end phase)
        public void SetEnd(long fbeBegin)
        {
            _buffer.Unshift(fbeBegin);
        }

        // Set the struct value
        public override void Set(StructList fbeValue)
        {
            long fbeBegin = SetBegin();
            if (fbeBegin == 0)
                return;

            SetFields(fbeValue);
            SetEnd(fbeBegin);
        }

        // Set the struct fields values
        public void SetFields(StructList fbeValue)
        {
            f1.Set(fbeValue.f1);
            f2.Set(fbeValue.f2);
            f3.Set(fbeValue.f3);
            f4.Set(fbeValue.f4);
            f5.Set(fbeValue.f5);
            f6.Set(fbeValue.f6);
            f7.Set(fbeValue.f7);
            f8.Set(fbeValue.f8);
            f9.Set(fbeValue.f9);
            f10.Set(fbeValue.f10);
        }
    }

} // namespace com.chronoxor.test.FBE

namespace com.chronoxor.test.FBE {

    using global::com.chronoxor.test;

    // Fast Binary Encoding StructList model
    public class StructListModel : com.chronoxor.FBE.Model
    {
        public readonly FieldModelStructList model;

        public StructListModel() { model = new FieldModelStructList(Buffer, 4); }
        public StructListModel(com.chronoxor.FBE.Buffer buffer) : base(buffer) { model = new FieldModelStructList(Buffer, 4); }

        // Get the model size
        public long FBESize => model.FBESize + model.FBEExtra;
        // Get the model type
        public const long FBETypeConst = FieldModelStructList.FBETypeConst;
        public long FBEType => FBETypeConst;

        // Check if the struct value is valid
        public bool Verify()
        {
            if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
                return false;

            uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
            if (fbeFullSize < model.FBESize)
                return false;

            return model.Verify();
        }

        // Create a new model (begin phase)
        public long CreateBegin()
        {
            long fbeBegin = Buffer.Allocate(4 + model.FBESize);
            return fbeBegin;
        }

        // Create a new model (end phase)
        public long CreateEnd(long fbeBegin)
        {
            long fbeEnd = Buffer.Size;
            uint fbeFullSize = (uint)(fbeEnd - fbeBegin);
            Write(model.FBEOffset - 4, fbeFullSize);
            return fbeFullSize;
        }

        // Serialize the struct value
        public long Serialize(StructList value)
        {
            long fbeBegin = CreateBegin();
            model.Set(value);
            long fbeFullSize = CreateEnd(fbeBegin);
            return fbeFullSize;
        }

        // Deserialize the struct value
        public long Deserialize(out StructList value)
        {
            if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
            {
                value = StructList.Default;
                return 0;
            }

            uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
            Debug.Assert((fbeFullSize >= model.FBESize), "Model is broken!");
            if (fbeFullSize < model.FBESize)
            {
                value = StructList.Default;
                return 0;
            }

            model.Get(out value);
            return fbeFullSize;
        }

        // Move to the next struct value
        public void Next(long prev)
        {
            model.FBEShift(prev);
        }
    }

} // namespace com.chronoxor.test.FBE

namespace com.chronoxor.test.FBE {

    using global::com.chronoxor.test;

    // Fast Binary Encoding StructList final model
    public class FinalModelStructList : com.chronoxor.FBE.FinalModelValueType<StructList>
    {
        public readonly com.chronoxor.FBE.FinalModelVectorValueType<byte, com.chronoxor.FBE.FinalModelValueType<byte>> f1;
        public readonly com.chronoxor.FBE.FinalModelVectorOptionalValueType<byte, com.chronoxor.FBE.FinalModelValueType<byte>> f2;
        public readonly com.chronoxor.FBE.FinalModelVectorReferenceType<MemoryStream, com.chronoxor.FBE.FinalModelReferenceType<MemoryStream>> f3;
        public readonly com.chronoxor.FBE.FinalModelVectorOptionalReferenceType<MemoryStream, com.chronoxor.FBE.FinalModelReferenceType<MemoryStream>> f4;
        public readonly com.chronoxor.FBE.FinalModelVectorValueType<EnumSimple, com.chronoxor.test.FBE.FinalModelEnumSimple> f5;
        public readonly com.chronoxor.FBE.FinalModelVectorOptionalValueType<EnumSimple, com.chronoxor.test.FBE.FinalModelEnumSimple> f6;
        public readonly com.chronoxor.FBE.FinalModelVectorValueType<FlagsSimple, com.chronoxor.test.FBE.FinalModelFlagsSimple> f7;
        public readonly com.chronoxor.FBE.FinalModelVectorOptionalValueType<FlagsSimple, com.chronoxor.test.FBE.FinalModelFlagsSimple> f8;
        public readonly com.chronoxor.FBE.FinalModelVectorValueType<StructSimple, com.chronoxor.test.FBE.FinalModelStructSimple> f9;
        public readonly com.chronoxor.FBE.FinalModelVectorOptionalValueType<StructSimple, com.chronoxor.test.FBE.FinalModelStructSimple> f10;

        public FinalModelStructList(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset)
        {
            f1 = new com.chronoxor.FBE.FinalModelVectorValueType<byte, com.chronoxor.FBE.FinalModelValueType<byte>>(com.chronoxor.FBE.FinalModelValueType<byte>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.BYTE, buffer, 0), buffer, 0);
            f2 = new com.chronoxor.FBE.FinalModelVectorOptionalValueType<byte, com.chronoxor.FBE.FinalModelValueType<byte>>(com.chronoxor.FBE.FinalModelValueType<byte>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.BYTE, buffer, 0), buffer, 0);
            f3 = new com.chronoxor.FBE.FinalModelVectorReferenceType<MemoryStream, com.chronoxor.FBE.FinalModelReferenceType<MemoryStream>>(com.chronoxor.FBE.FinalModelReferenceType<MemoryStream>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.BYTES, buffer, 0), buffer, 0);
            f4 = new com.chronoxor.FBE.FinalModelVectorOptionalReferenceType<MemoryStream, com.chronoxor.FBE.FinalModelReferenceType<MemoryStream>>(com.chronoxor.FBE.FinalModelReferenceType<MemoryStream>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.BYTES, buffer, 0), buffer, 0);
            f5 = new com.chronoxor.FBE.FinalModelVectorValueType<EnumSimple, com.chronoxor.test.FBE.FinalModelEnumSimple>(new com.chronoxor.test.FBE.FinalModelEnumSimple(buffer, 0), buffer, 0);
            f6 = new com.chronoxor.FBE.FinalModelVectorOptionalValueType<EnumSimple, com.chronoxor.test.FBE.FinalModelEnumSimple>(new com.chronoxor.test.FBE.FinalModelEnumSimple(buffer, 0), buffer, 0);
            f7 = new com.chronoxor.FBE.FinalModelVectorValueType<FlagsSimple, com.chronoxor.test.FBE.FinalModelFlagsSimple>(new com.chronoxor.test.FBE.FinalModelFlagsSimple(buffer, 0), buffer, 0);
            f8 = new com.chronoxor.FBE.FinalModelVectorOptionalValueType<FlagsSimple, com.chronoxor.test.FBE.FinalModelFlagsSimple>(new com.chronoxor.test.FBE.FinalModelFlagsSimple(buffer, 0), buffer, 0);
            f9 = new com.chronoxor.FBE.FinalModelVectorValueType<StructSimple, com.chronoxor.test.FBE.FinalModelStructSimple>(new com.chronoxor.test.FBE.FinalModelStructSimple(buffer, 0), buffer, 0);
            f10 = new com.chronoxor.FBE.FinalModelVectorOptionalValueType<StructSimple, com.chronoxor.test.FBE.FinalModelStructSimple>(new com.chronoxor.test.FBE.FinalModelStructSimple(buffer, 0), buffer, 0);
        }

        // Get the allocation size
        public override long FBEAllocationSize(StructList fbeValue)
        {
            long fbeResult = 0
                + f1.FBEAllocationSize(fbeValue.f1)
                + f2.FBEAllocationSize(fbeValue.f2)
                + f3.FBEAllocationSize(fbeValue.f3)
                + f4.FBEAllocationSize(fbeValue.f4)
                + f5.FBEAllocationSize(fbeValue.f5)
                + f6.FBEAllocationSize(fbeValue.f6)
                + f7.FBEAllocationSize(fbeValue.f7)
                + f8.FBEAllocationSize(fbeValue.f8)
                + f9.FBEAllocationSize(fbeValue.f9)
                + f10.FBEAllocationSize(fbeValue.f10)
                ;
            return fbeResult;
        }

        // Get the final type
        public const long FBETypeConst = 131;
        public long FBEType => FBETypeConst;

        // Clone the final model
        public override com.chronoxor.FBE.FinalModelValueType<StructList> Clone() { return new FinalModelStructList(_buffer, _offset); }

        // Check if the struct value is valid
        public override long Verify()
        {
            _buffer.Shift(FBEOffset);
            long fbeResult = VerifyFields();
            _buffer.Unshift(FBEOffset);
            return fbeResult;
        }

        // Check if the struct fields are valid
        public long VerifyFields()
        {
            long fbeCurrentOffset = 0;
            long fbeFieldSize;

            f1.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f1.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f2.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f2.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f3.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f3.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f4.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f4.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f5.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f5.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f6.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f6.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f7.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f7.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f8.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f8.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f9.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f9.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f10.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f10.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            return fbeCurrentOffset;
        }

        // Get the struct value
        public override long Get(out StructList fbeValue)
        {
            _buffer.Shift(FBEOffset);
            long fbeSize = GetFields(out fbeValue);
            _buffer.Unshift(FBEOffset);
            return fbeSize;
        }

        // Get the struct fields values
        public long GetFields(out StructList fbeValue)
        {
            long fbeCurrentOffset = 0;
            long fbeCurrentSize = 0;
            long fbeFieldSize;

            fbeValue = StructList.Default;

            f1.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f1.Get(out fbeValue.f1);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f2.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f2.Get(out fbeValue.f2);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f3.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f3.Get(out fbeValue.f3);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f4.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f4.Get(out fbeValue.f4);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f5.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f5.Get(out fbeValue.f5);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f6.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f6.Get(out fbeValue.f6);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f7.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f7.Get(out fbeValue.f7);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f8.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f8.Get(out fbeValue.f8);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f9.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f9.Get(out fbeValue.f9);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f10.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f10.Get(out fbeValue.f10);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            return fbeCurrentSize;
        }

        // Set the struct value
        public override long Set(StructList fbeValue)
        {
            _buffer.Shift(FBEOffset);
            long fbeResult = SetFields(fbeValue);
            _buffer.Unshift(FBEOffset);
            return fbeResult;
        }

        // Set the struct fields values
        public long SetFields(StructList fbeValue)
        {
            long fbeCurrentOffset = 0;
            long fbeCurrentSize = 0;
            long fbeFieldSize;

            f1.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f1.Set(fbeValue.f1);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f2.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f2.Set(fbeValue.f2);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f3.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f3.Set(fbeValue.f3);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f4.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f4.Set(fbeValue.f4);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f5.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f5.Set(fbeValue.f5);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f6.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f6.Set(fbeValue.f6);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f7.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f7.Set(fbeValue.f7);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f8.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f8.Set(fbeValue.f8);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f9.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f9.Set(fbeValue.f9);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f10.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f10.Set(fbeValue.f10);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            return fbeCurrentSize;
        }
    }

} // namespace com.chronoxor.test.FBE

namespace com.chronoxor.test.FBE {

    using global::com.chronoxor.test;

    // Fast Binary Encoding StructList final model
    public class StructListFinalModel : com.chronoxor.FBE.Model
    {
        private readonly FinalModelStructList _model;

        public StructListFinalModel() { _model = new FinalModelStructList(Buffer, 8); }
        public StructListFinalModel(com.chronoxor.FBE.Buffer buffer) : base(buffer) { _model = new FinalModelStructList(Buffer, 8); }

        // Get the model type
        public const long FBETypeConst = FinalModelStructList.FBETypeConst;
        public long FBEType => FBETypeConst;

        // Check if the struct value is valid
        public bool Verify()
        {
            if ((Buffer.Offset + _model.FBEOffset) > Buffer.Size)
                return false;

            long fbeStructSize = ReadUInt32(_model.FBEOffset - 8);
            long fbeStructType = ReadUInt32(_model.FBEOffset - 4);
            if ((fbeStructSize <= 0) || (fbeStructType != FBEType))
                return false;

            return ((8 + _model.Verify()) == fbeStructSize);
        }

        // Serialize the struct value
        public long Serialize(StructList value)
        {
            long fbeInitialSize = Buffer.Size;

            uint fbeStructType = (uint)FBEType;
            uint fbeStructSize = (uint)(8 + _model.FBEAllocationSize(value));
            uint fbeStructOffset = (uint)(Buffer.Allocate(fbeStructSize) - Buffer.Offset);
            Debug.Assert(((Buffer.Offset + fbeStructOffset + fbeStructSize) <= Buffer.Size), "Model is broken!");
            if ((Buffer.Offset + fbeStructOffset + fbeStructSize) > Buffer.Size)
                return 0;

            fbeStructSize = (uint)(8 + _model.Set(value));
            Buffer.Resize(fbeInitialSize + fbeStructSize);

            Write(_model.FBEOffset - 8, fbeStructSize);
            Write(_model.FBEOffset - 4, fbeStructType);

            return fbeStructSize;
        }

        // Deserialize the struct value
        public long Deserialize(out StructList value)
        {
            Debug.Assert(((Buffer.Offset + _model.FBEOffset) <= Buffer.Size), "Model is broken!");
            if ((Buffer.Offset + _model.FBEOffset) > Buffer.Size)
            {
                value = StructList.Default;
                return 0;
            }

            long fbeStructSize = ReadUInt32(_model.FBEOffset - 8);
            long fbeStructType = ReadUInt32(_model.FBEOffset - 4);
            Debug.Assert(((fbeStructSize > 0) && (fbeStructType == FBEType)), "Model is broken!");
            if ((fbeStructSize <= 0) || (fbeStructType != FBEType))
            {
                value = StructList.Default;
                return 8;
            }

            return 8 + _model.Get(out value);
        }

        // Move to the next struct value
        public void Next(long prev)
        {
            _model.FBEShift(prev);
        }
    }

} // namespace com.chronoxor.test.FBE

namespace com.chronoxor.test {

    public struct StructSet : IComparable, IComparable<StructSet>, IEquatable<StructSet>
    {
        public HashSet<byte> f1;
        public HashSet<EnumSimple> f2;
        public HashSet<FlagsSimple> f3;
        public HashSet<StructSimple> f4;

        public const long FBETypeConst = 132;
        #if UTF8JSON
        [IgnoreDataMember]
        #else
        [JsonIgnore]
        #endif
        public long FBEType => FBETypeConst;

        public static StructSet Default => new StructSet
        {
            f1 = new HashSet<byte>()
            , f2 = new HashSet<EnumSimple>()
            , f3 = new HashSet<FlagsSimple>()
            , f4 = new HashSet<StructSimple>()
        };

        public StructSet(HashSet<byte> f1, HashSet<EnumSimple> f2, HashSet<FlagsSimple> f3, HashSet<StructSimple> f4)
        {
            this.f1 = f1;
            this.f2 = f2;
            this.f3 = f3;
            this.f4 = f4;
        }

        public StructSet Clone()
        {
            // Serialize the struct to the FBE stream
            var writer = new com.chronoxor.test.FBE.StructSetModel();
            writer.Serialize(this);

            // Deserialize the struct from the FBE stream
            var reader = new com.chronoxor.test.FBE.StructSetModel();
            reader.Attach(writer.Buffer);
            reader.Deserialize(out var result);
            return result;
        }

        public int CompareTo(object other)
        {
            int result = 0;
            return result;
        }

        public int CompareTo(StructSet other)
        {
            int result = 0;
            return result;
        }

        public override bool Equals(object other)
        {
            if (!(other is StructSet))
                return false;
            return true;
        }

        public bool Equals(StructSet other)
        {
            return true;
        }

        public override int GetHashCode()
        {
            int hash = 17;
            return hash;
        }

        public static bool operator==(StructSet lhs, StructSet rhs) => lhs.Equals(rhs);
        public static bool operator!=(StructSet lhs, StructSet rhs) => !(lhs == rhs);

        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("StructSet(");
            if (f1 != null)
            {
                bool first = true;
                sb.Append("f1=[").Append(f1.Count).Append("]{");
                foreach (var item in f1)
                {
                    sb.Append(first ? "" : ",").Append(item);
                    first = false;
                }
                sb.Append("}");
            }
            else
            {
                sb.Append("f1=[0]{}");
            }
            if (f2 != null)
            {
                bool first = true;
                sb.Append(",f2=[").Append(f2.Count).Append("]{");
                foreach (var item in f2)
                {
                    sb.Append(first ? "" : ",").Append(item);
                    first = false;
                }
                sb.Append("}");
            }
            else
            {
                sb.Append(",f2=[0]{}");
            }
            if (f3 != null)
            {
                bool first = true;
                sb.Append(",f3=[").Append(f3.Count).Append("]{");
                foreach (var item in f3)
                {
                    sb.Append(first ? "" : ",").Append(item);
                    first = false;
                }
                sb.Append("}");
            }
            else
            {
                sb.Append(",f3=[0]{}");
            }
            if (f4 != null)
            {
                bool first = true;
                sb.Append(",f4=[").Append(f4.Count).Append("]{");
                foreach (var item in f4)
                {
                    sb.Append(first ? "" : ",").Append(item);
                    first = false;
                }
                sb.Append("}");
            }
            else
            {
                sb.Append(",f4=[0]{}");
            }
            sb.Append(")");
            return sb.ToString();
        }

        public string ToJson()
        {
            var json = com.chronoxor.FBE.Json.ToJson(this);
            return json;
        }

        public static StructSet FromJson(string json)
        {
            var result = com.chronoxor.FBE.Json.FromJson<StructSet>(json);
            return result;
        }

        public static com.chronoxor.FBE.FieldModelValueType<StructSet> CreateFieldModel(com.chronoxor.FBE.Buffer buffer, long offset) { return new test.FBE.FieldModelStructSet(buffer, offset); }
    }

} // namespace com.chronoxor.test

namespace com.chronoxor.test.FBE {

    using global::com.chronoxor.test;

    // Fast Binary Encoding StructSet field model
    public class FieldModelStructSet : com.chronoxor.FBE.FieldModelValueType<StructSet>
    {
        public readonly com.chronoxor.FBE.FieldModelVectorValueType<byte, com.chronoxor.FBE.FieldModelValueType<byte>> f1;
        public readonly com.chronoxor.FBE.FieldModelVectorValueType<EnumSimple, com.chronoxor.test.FBE.FieldModelEnumSimple> f2;
        public readonly com.chronoxor.FBE.FieldModelVectorValueType<FlagsSimple, com.chronoxor.test.FBE.FieldModelFlagsSimple> f3;
        public readonly com.chronoxor.FBE.FieldModelVectorValueType<StructSimple, com.chronoxor.test.FBE.FieldModelStructSimple> f4;

        public FieldModelStructSet(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset)
        {
            f1 = new com.chronoxor.FBE.FieldModelVectorValueType<byte, com.chronoxor.FBE.FieldModelValueType<byte>>(com.chronoxor.FBE.FieldModelValueType<byte>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.BYTE, buffer, 4 + 4), buffer, 4 + 4);
            f2 = new com.chronoxor.FBE.FieldModelVectorValueType<EnumSimple, com.chronoxor.test.FBE.FieldModelEnumSimple>(new com.chronoxor.test.FBE.FieldModelEnumSimple(buffer, f1.FBEOffset + f1.FBESize), buffer, f1.FBEOffset + f1.FBESize);
            f3 = new com.chronoxor.FBE.FieldModelVectorValueType<FlagsSimple, com.chronoxor.test.FBE.FieldModelFlagsSimple>(new com.chronoxor.test.FBE.FieldModelFlagsSimple(buffer, f2.FBEOffset + f2.FBESize), buffer, f2.FBEOffset + f2.FBESize);
            f4 = new com.chronoxor.FBE.FieldModelVectorValueType<StructSimple, com.chronoxor.test.FBE.FieldModelStructSimple>(new com.chronoxor.test.FBE.FieldModelStructSimple(buffer, f3.FBEOffset + f3.FBESize), buffer, f3.FBEOffset + f3.FBESize);
        }

        // Get the field size
        public override long FBESize => 4;
        // Get the field body size
        public long FBEBody
        {
            get
            {
                long fbeResult = 4 + 4
                    + f1.FBESize
                    + f2.FBESize
                    + f3.FBESize
                    + f4.FBESize
                    ;
                return fbeResult;
            }
        }
        // Get the field extra size
        public override long FBEExtra
        {
            get
            {
                if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                    return 0;

                uint fbeStructOffset = ReadUInt32(FBEOffset);
                if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4) > _buffer.Size))
                    return 0;

                _buffer.Shift(fbeStructOffset);

                long fbeResult = FBEBody
                    + f1.FBEExtra
                    + f2.FBEExtra
                    + f3.FBEExtra
                    + f4.FBEExtra
                    ;

                _buffer.Unshift(fbeStructOffset);

                return fbeResult;
            }
        }
        // Get the field type
        public const long FBETypeConst = 132;
        public long FBEType => FBETypeConst;

        // Clone the field model
        public override com.chronoxor.FBE.FieldModelValueType<StructSet> Clone() { return new FieldModelStructSet(_buffer, _offset); }

        // Check if the struct value is valid
        public override bool Verify() { return Verify(true); }
        public bool Verify(bool fbeVerifyType)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return true;

            uint fbeStructOffset = ReadUInt32(FBEOffset);
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
                return false;

            uint fbeStructSize = ReadUInt32(fbeStructOffset);
            if (fbeStructSize < (4 + 4))
                return false;

            uint fbeStructType = ReadUInt32(fbeStructOffset + 4);
            if (fbeVerifyType && (fbeStructType != FBEType))
                return false;

            _buffer.Shift(fbeStructOffset);
            bool fbeResult = VerifyFields(fbeStructSize);
            _buffer.Unshift(fbeStructOffset);
            return fbeResult;
        }

        // Check if the struct fields are valid
        public bool VerifyFields(long fbeStructSize)
        {
            long fbeCurrentSize = 4 + 4;

            if ((fbeCurrentSize + f1.FBESize) > fbeStructSize)
                return true;
            if (!f1.Verify())
                return false;
            fbeCurrentSize += f1.FBESize;

            if ((fbeCurrentSize + f2.FBESize) > fbeStructSize)
                return true;
            if (!f2.Verify())
                return false;
            fbeCurrentSize += f2.FBESize;

            if ((fbeCurrentSize + f3.FBESize) > fbeStructSize)
                return true;
            if (!f3.Verify())
                return false;
            fbeCurrentSize += f3.FBESize;

            if ((fbeCurrentSize + f4.FBESize) > fbeStructSize)
                return true;
            if (!f4.Verify())
                return false;
            fbeCurrentSize += f4.FBESize;

            return true;
        }

        // Get the struct value (begin phase)
        public long GetBegin()
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            uint fbeStructOffset = ReadUInt32(FBEOffset);
            Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + 4 + 4) <= _buffer.Size)), "Model is broken!");
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
                return 0;

            uint fbeStructSize = ReadUInt32(fbeStructOffset);
            Debug.Assert((fbeStructSize >= (4 + 4)), "Model is broken!");
            if (fbeStructSize < (4 + 4))
                return 0;

            _buffer.Shift(fbeStructOffset);
            return fbeStructOffset;
        }

        // Get the struct value (end phase)
        public void GetEnd(long fbeBegin)
        {
            _buffer.Unshift(fbeBegin);
        }

        // Get the struct value
        public override void Get(out StructSet fbeValue) { Get(out fbeValue, StructSet.Default); }
        public override void Get(out StructSet fbeValue, StructSet defaults)
        {
            long fbeBegin = GetBegin();
            if (fbeBegin == 0)
            {
                fbeValue = defaults;
                return;
            }

            uint fbeStructSize = ReadUInt32(0);
            GetFields(out fbeValue, fbeStructSize);
            GetEnd(fbeBegin);
        }

        // Get the struct fields values
        public void GetFields(out StructSet fbeValue, long fbeStructSize)
        {
            long fbeCurrentSize = 4 + 4;

            fbeValue = StructSet.Default;

            if ((fbeCurrentSize + f1.FBESize) <= fbeStructSize)
                f1.Get(ref fbeValue.f1);
            else
                fbeValue.f1.Clear();
            fbeCurrentSize += f1.FBESize;

            if ((fbeCurrentSize + f2.FBESize) <= fbeStructSize)
                f2.Get(ref fbeValue.f2);
            else
                fbeValue.f2.Clear();
            fbeCurrentSize += f2.FBESize;

            if ((fbeCurrentSize + f3.FBESize) <= fbeStructSize)
                f3.Get(ref fbeValue.f3);
            else
                fbeValue.f3.Clear();
            fbeCurrentSize += f3.FBESize;

            if ((fbeCurrentSize + f4.FBESize) <= fbeStructSize)
                f4.Get(ref fbeValue.f4);
            else
                fbeValue.f4.Clear();
            fbeCurrentSize += f4.FBESize;
        }

        // Set the struct value (begin phase)
        public long SetBegin()
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            uint fbeStructSize = (uint)FBEBody;
            uint fbeStructOffset = (uint)(_buffer.Allocate(fbeStructSize) - _buffer.Offset);
            Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + fbeStructSize) <= _buffer.Size)), "Model is broken!");
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + fbeStructSize) > _buffer.Size))
                return 0;

            Write(FBEOffset, fbeStructOffset);
            Write(fbeStructOffset, fbeStructSize);
            Write(fbeStructOffset + 4, (uint)FBEType);

            _buffer.Shift(fbeStructOffset);
            return fbeStructOffset;
        }

        // Set the struct value (end phase)
        public void SetEnd(long fbeBegin)
        {
            _buffer.Unshift(fbeBegin);
        }

        // Set the struct value
        public override void Set(StructSet fbeValue)
        {
            long fbeBegin = SetBegin();
            if (fbeBegin == 0)
                return;

            SetFields(fbeValue);
            SetEnd(fbeBegin);
        }

        // Set the struct fields values
        public void SetFields(StructSet fbeValue)
        {
            f1.Set(fbeValue.f1);
            f2.Set(fbeValue.f2);
            f3.Set(fbeValue.f3);
            f4.Set(fbeValue.f4);
        }
    }

} // namespace com.chronoxor.test.FBE

namespace com.chronoxor.test.FBE {

    using global::com.chronoxor.test;

    // Fast Binary Encoding StructSet model
    public class StructSetModel : com.chronoxor.FBE.Model
    {
        public readonly FieldModelStructSet model;

        public StructSetModel() { model = new FieldModelStructSet(Buffer, 4); }
        public StructSetModel(com.chronoxor.FBE.Buffer buffer) : base(buffer) { model = new FieldModelStructSet(Buffer, 4); }

        // Get the model size
        public long FBESize => model.FBESize + model.FBEExtra;
        // Get the model type
        public const long FBETypeConst = FieldModelStructSet.FBETypeConst;
        public long FBEType => FBETypeConst;

        // Check if the struct value is valid
        public bool Verify()
        {
            if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
                return false;

            uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
            if (fbeFullSize < model.FBESize)
                return false;

            return model.Verify();
        }

        // Create a new model (begin phase)
        public long CreateBegin()
        {
            long fbeBegin = Buffer.Allocate(4 + model.FBESize);
            return fbeBegin;
        }

        // Create a new model (end phase)
        public long CreateEnd(long fbeBegin)
        {
            long fbeEnd = Buffer.Size;
            uint fbeFullSize = (uint)(fbeEnd - fbeBegin);
            Write(model.FBEOffset - 4, fbeFullSize);
            return fbeFullSize;
        }

        // Serialize the struct value
        public long Serialize(StructSet value)
        {
            long fbeBegin = CreateBegin();
            model.Set(value);
            long fbeFullSize = CreateEnd(fbeBegin);
            return fbeFullSize;
        }

        // Deserialize the struct value
        public long Deserialize(out StructSet value)
        {
            if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
            {
                value = StructSet.Default;
                return 0;
            }

            uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
            Debug.Assert((fbeFullSize >= model.FBESize), "Model is broken!");
            if (fbeFullSize < model.FBESize)
            {
                value = StructSet.Default;
                return 0;
            }

            model.Get(out value);
            return fbeFullSize;
        }

        // Move to the next struct value
        public void Next(long prev)
        {
            model.FBEShift(prev);
        }
    }

} // namespace com.chronoxor.test.FBE

namespace com.chronoxor.test.FBE {

    using global::com.chronoxor.test;

    // Fast Binary Encoding StructSet final model
    public class FinalModelStructSet : com.chronoxor.FBE.FinalModelValueType<StructSet>
    {
        public readonly com.chronoxor.FBE.FinalModelVectorValueType<byte, com.chronoxor.FBE.FinalModelValueType<byte>> f1;
        public readonly com.chronoxor.FBE.FinalModelVectorValueType<EnumSimple, com.chronoxor.test.FBE.FinalModelEnumSimple> f2;
        public readonly com.chronoxor.FBE.FinalModelVectorValueType<FlagsSimple, com.chronoxor.test.FBE.FinalModelFlagsSimple> f3;
        public readonly com.chronoxor.FBE.FinalModelVectorValueType<StructSimple, com.chronoxor.test.FBE.FinalModelStructSimple> f4;

        public FinalModelStructSet(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset)
        {
            f1 = new com.chronoxor.FBE.FinalModelVectorValueType<byte, com.chronoxor.FBE.FinalModelValueType<byte>>(com.chronoxor.FBE.FinalModelValueType<byte>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.BYTE, buffer, 0), buffer, 0);
            f2 = new com.chronoxor.FBE.FinalModelVectorValueType<EnumSimple, com.chronoxor.test.FBE.FinalModelEnumSimple>(new com.chronoxor.test.FBE.FinalModelEnumSimple(buffer, 0), buffer, 0);
            f3 = new com.chronoxor.FBE.FinalModelVectorValueType<FlagsSimple, com.chronoxor.test.FBE.FinalModelFlagsSimple>(new com.chronoxor.test.FBE.FinalModelFlagsSimple(buffer, 0), buffer, 0);
            f4 = new com.chronoxor.FBE.FinalModelVectorValueType<StructSimple, com.chronoxor.test.FBE.FinalModelStructSimple>(new com.chronoxor.test.FBE.FinalModelStructSimple(buffer, 0), buffer, 0);
        }

        // Get the allocation size
        public override long FBEAllocationSize(StructSet fbeValue)
        {
            long fbeResult = 0
                + f1.FBEAllocationSize(fbeValue.f1)
                + f2.FBEAllocationSize(fbeValue.f2)
                + f3.FBEAllocationSize(fbeValue.f3)
                + f4.FBEAllocationSize(fbeValue.f4)
                ;
            return fbeResult;
        }

        // Get the final type
        public const long FBETypeConst = 132;
        public long FBEType => FBETypeConst;

        // Clone the final model
        public override com.chronoxor.FBE.FinalModelValueType<StructSet> Clone() { return new FinalModelStructSet(_buffer, _offset); }

        // Check if the struct value is valid
        public override long Verify()
        {
            _buffer.Shift(FBEOffset);
            long fbeResult = VerifyFields();
            _buffer.Unshift(FBEOffset);
            return fbeResult;
        }

        // Check if the struct fields are valid
        public long VerifyFields()
        {
            long fbeCurrentOffset = 0;
            long fbeFieldSize;

            f1.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f1.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f2.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f2.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f3.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f3.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f4.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f4.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            return fbeCurrentOffset;
        }

        // Get the struct value
        public override long Get(out StructSet fbeValue)
        {
            _buffer.Shift(FBEOffset);
            long fbeSize = GetFields(out fbeValue);
            _buffer.Unshift(FBEOffset);
            return fbeSize;
        }

        // Get the struct fields values
        public long GetFields(out StructSet fbeValue)
        {
            long fbeCurrentOffset = 0;
            long fbeCurrentSize = 0;
            long fbeFieldSize;

            fbeValue = StructSet.Default;

            f1.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f1.Get(out fbeValue.f1);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f2.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f2.Get(out fbeValue.f2);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f3.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f3.Get(out fbeValue.f3);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f4.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f4.Get(out fbeValue.f4);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            return fbeCurrentSize;
        }

        // Set the struct value
        public override long Set(StructSet fbeValue)
        {
            _buffer.Shift(FBEOffset);
            long fbeResult = SetFields(fbeValue);
            _buffer.Unshift(FBEOffset);
            return fbeResult;
        }

        // Set the struct fields values
        public long SetFields(StructSet fbeValue)
        {
            long fbeCurrentOffset = 0;
            long fbeCurrentSize = 0;
            long fbeFieldSize;

            f1.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f1.Set(fbeValue.f1);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f2.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f2.Set(fbeValue.f2);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f3.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f3.Set(fbeValue.f3);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f4.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f4.Set(fbeValue.f4);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            return fbeCurrentSize;
        }
    }

} // namespace com.chronoxor.test.FBE

namespace com.chronoxor.test.FBE {

    using global::com.chronoxor.test;

    // Fast Binary Encoding StructSet final model
    public class StructSetFinalModel : com.chronoxor.FBE.Model
    {
        private readonly FinalModelStructSet _model;

        public StructSetFinalModel() { _model = new FinalModelStructSet(Buffer, 8); }
        public StructSetFinalModel(com.chronoxor.FBE.Buffer buffer) : base(buffer) { _model = new FinalModelStructSet(Buffer, 8); }

        // Get the model type
        public const long FBETypeConst = FinalModelStructSet.FBETypeConst;
        public long FBEType => FBETypeConst;

        // Check if the struct value is valid
        public bool Verify()
        {
            if ((Buffer.Offset + _model.FBEOffset) > Buffer.Size)
                return false;

            long fbeStructSize = ReadUInt32(_model.FBEOffset - 8);
            long fbeStructType = ReadUInt32(_model.FBEOffset - 4);
            if ((fbeStructSize <= 0) || (fbeStructType != FBEType))
                return false;

            return ((8 + _model.Verify()) == fbeStructSize);
        }

        // Serialize the struct value
        public long Serialize(StructSet value)
        {
            long fbeInitialSize = Buffer.Size;

            uint fbeStructType = (uint)FBEType;
            uint fbeStructSize = (uint)(8 + _model.FBEAllocationSize(value));
            uint fbeStructOffset = (uint)(Buffer.Allocate(fbeStructSize) - Buffer.Offset);
            Debug.Assert(((Buffer.Offset + fbeStructOffset + fbeStructSize) <= Buffer.Size), "Model is broken!");
            if ((Buffer.Offset + fbeStructOffset + fbeStructSize) > Buffer.Size)
                return 0;

            fbeStructSize = (uint)(8 + _model.Set(value));
            Buffer.Resize(fbeInitialSize + fbeStructSize);

            Write(_model.FBEOffset - 8, fbeStructSize);
            Write(_model.FBEOffset - 4, fbeStructType);

            return fbeStructSize;
        }

        // Deserialize the struct value
        public long Deserialize(out StructSet value)
        {
            Debug.Assert(((Buffer.Offset + _model.FBEOffset) <= Buffer.Size), "Model is broken!");
            if ((Buffer.Offset + _model.FBEOffset) > Buffer.Size)
            {
                value = StructSet.Default;
                return 0;
            }

            long fbeStructSize = ReadUInt32(_model.FBEOffset - 8);
            long fbeStructType = ReadUInt32(_model.FBEOffset - 4);
            Debug.Assert(((fbeStructSize > 0) && (fbeStructType == FBEType)), "Model is broken!");
            if ((fbeStructSize <= 0) || (fbeStructType != FBEType))
            {
                value = StructSet.Default;
                return 8;
            }

            return 8 + _model.Get(out value);
        }

        // Move to the next struct value
        public void Next(long prev)
        {
            _model.FBEShift(prev);
        }
    }

} // namespace com.chronoxor.test.FBE

namespace com.chronoxor.test {

    public struct StructMap : IComparable, IComparable<StructMap>, IEquatable<StructMap>
    {
        public SortedDictionary<int, byte> f1;
        public SortedDictionary<int, byte?> f2;
        public SortedDictionary<int, MemoryStream> f3;
        public SortedDictionary<int, MemoryStream> f4;
        public SortedDictionary<int, EnumSimple> f5;
        public SortedDictionary<int, EnumSimple?> f6;
        public SortedDictionary<int, FlagsSimple> f7;
        public SortedDictionary<int, FlagsSimple?> f8;
        public SortedDictionary<int, StructSimple> f9;
        public SortedDictionary<int, StructSimple?> f10;

        public const long FBETypeConst = 140;
        #if UTF8JSON
        [IgnoreDataMember]
        #else
        [JsonIgnore]
        #endif
        public long FBEType => FBETypeConst;

        public static StructMap Default => new StructMap
        {
            f1 = new SortedDictionary<int, byte>()
            , f2 = new SortedDictionary<int, byte?>()
            , f3 = new SortedDictionary<int, MemoryStream>()
            , f4 = new SortedDictionary<int, MemoryStream>()
            , f5 = new SortedDictionary<int, EnumSimple>()
            , f6 = new SortedDictionary<int, EnumSimple?>()
            , f7 = new SortedDictionary<int, FlagsSimple>()
            , f8 = new SortedDictionary<int, FlagsSimple?>()
            , f9 = new SortedDictionary<int, StructSimple>()
            , f10 = new SortedDictionary<int, StructSimple?>()
        };

        public StructMap(SortedDictionary<int, byte> f1, SortedDictionary<int, byte?> f2, SortedDictionary<int, MemoryStream> f3, SortedDictionary<int, MemoryStream> f4, SortedDictionary<int, EnumSimple> f5, SortedDictionary<int, EnumSimple?> f6, SortedDictionary<int, FlagsSimple> f7, SortedDictionary<int, FlagsSimple?> f8, SortedDictionary<int, StructSimple> f9, SortedDictionary<int, StructSimple?> f10)
        {
            this.f1 = f1;
            this.f2 = f2;
            this.f3 = f3;
            this.f4 = f4;
            this.f5 = f5;
            this.f6 = f6;
            this.f7 = f7;
            this.f8 = f8;
            this.f9 = f9;
            this.f10 = f10;
        }

        public StructMap Clone()
        {
            // Serialize the struct to the FBE stream
            var writer = new com.chronoxor.test.FBE.StructMapModel();
            writer.Serialize(this);

            // Deserialize the struct from the FBE stream
            var reader = new com.chronoxor.test.FBE.StructMapModel();
            reader.Attach(writer.Buffer);
            reader.Deserialize(out var result);
            return result;
        }

        public int CompareTo(object other)
        {
            int result = 0;
            return result;
        }

        public int CompareTo(StructMap other)
        {
            int result = 0;
            return result;
        }

        public override bool Equals(object other)
        {
            if (!(other is StructMap))
                return false;
            return true;
        }

        public bool Equals(StructMap other)
        {
            return true;
        }

        public override int GetHashCode()
        {
            int hash = 17;
            return hash;
        }

        public static bool operator==(StructMap lhs, StructMap rhs) => lhs.Equals(rhs);
        public static bool operator!=(StructMap lhs, StructMap rhs) => !(lhs == rhs);

        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("StructMap(");
            if (f1 != null)
            {
                bool first = true;
                sb.Append("f1=[").Append(f1.Count).Append("]<{");
                foreach (var item in f1)
                {
                    sb.Append(first ? "" : ",").Append(item.Key);
                    sb.Append("->");
                    sb.Append(item.Value);
                    first = false;
                }
                sb.Append("}>");
            }
            else
            {
                sb.Append("f1=[0]<{}>");
            }
            if (f2 != null)
            {
                bool first = true;
                sb.Append(",f2=[").Append(f2.Count).Append("]<{");
                foreach (var item in f2)
                {
                    sb.Append(first ? "" : ",").Append(item.Key);
                    sb.Append("->");
                    if (item.Value != null) sb.Append(item.Value); else sb.Append("null");
                    first = false;
                }
                sb.Append("}>");
            }
            else
            {
                sb.Append(",f2=[0]<{}>");
            }
            if (f3 != null)
            {
                bool first = true;
                sb.Append(",f3=[").Append(f3.Count).Append("]<{");
                foreach (var item in f3)
                {
                    sb.Append(first ? "" : ",").Append(item.Key);
                    sb.Append("->");
                    if (item.Value != null) sb.Append("bytes[").Append(item.Value.Length).Append("]"); else sb.Append("null");
                    first = false;
                }
                sb.Append("}>");
            }
            else
            {
                sb.Append(",f3=[0]<{}>");
            }
            if (f4 != null)
            {
                bool first = true;
                sb.Append(",f4=[").Append(f4.Count).Append("]<{");
                foreach (var item in f4)
                {
                    sb.Append(first ? "" : ",").Append(item.Key);
                    sb.Append("->");
                    if (item.Value != null) sb.Append("bytes[").Append(item.Value.Length).Append("]"); else sb.Append("null");
                    first = false;
                }
                sb.Append("}>");
            }
            else
            {
                sb.Append(",f4=[0]<{}>");
            }
            if (f5 != null)
            {
                bool first = true;
                sb.Append(",f5=[").Append(f5.Count).Append("]<{");
                foreach (var item in f5)
                {
                    sb.Append(first ? "" : ",").Append(item.Key);
                    sb.Append("->");
                    sb.Append(item.Value);
                    first = false;
                }
                sb.Append("}>");
            }
            else
            {
                sb.Append(",f5=[0]<{}>");
            }
            if (f6 != null)
            {
                bool first = true;
                sb.Append(",f6=[").Append(f6.Count).Append("]<{");
                foreach (var item in f6)
                {
                    sb.Append(first ? "" : ",").Append(item.Key);
                    sb.Append("->");
                    if (item.Value != null) sb.Append(item.Value); else sb.Append("null");
                    first = false;
                }
                sb.Append("}>");
            }
            else
            {
                sb.Append(",f6=[0]<{}>");
            }
            if (f7 != null)
            {
                bool first = true;
                sb.Append(",f7=[").Append(f7.Count).Append("]<{");
                foreach (var item in f7)
                {
                    sb.Append(first ? "" : ",").Append(item.Key);
                    sb.Append("->");
                    sb.Append(item.Value);
                    first = false;
                }
                sb.Append("}>");
            }
            else
            {
                sb.Append(",f7=[0]<{}>");
            }
            if (f8 != null)
            {
                bool first = true;
                sb.Append(",f8=[").Append(f8.Count).Append("]<{");
                foreach (var item in f8)
                {
                    sb.Append(first ? "" : ",").Append(item.Key);
                    sb.Append("->");
                    if (item.Value != null) sb.Append(item.Value); else sb.Append("null");
                    first = false;
                }
                sb.Append("}>");
            }
            else
            {
                sb.Append(",f8=[0]<{}>");
            }
            if (f9 != null)
            {
                bool first = true;
                sb.Append(",f9=[").Append(f9.Count).Append("]<{");
                foreach (var item in f9)
                {
                    sb.Append(first ? "" : ",").Append(item.Key);
                    sb.Append("->");
                    sb.Append(item.Value);
                    first = false;
                }
                sb.Append("}>");
            }
            else
            {
                sb.Append(",f9=[0]<{}>");
            }
            if (f10 != null)
            {
                bool first = true;
                sb.Append(",f10=[").Append(f10.Count).Append("]<{");
                foreach (var item in f10)
                {
                    sb.Append(first ? "" : ",").Append(item.Key);
                    sb.Append("->");
                    if (item.Value != null) sb.Append(item.Value); else sb.Append("null");
                    first = false;
                }
                sb.Append("}>");
            }
            else
            {
                sb.Append(",f10=[0]<{}>");
            }
            sb.Append(")");
            return sb.ToString();
        }

        public string ToJson()
        {
            var json = com.chronoxor.FBE.Json.ToJson(this);
            return json;
        }

        public static StructMap FromJson(string json)
        {
            var result = com.chronoxor.FBE.Json.FromJson<StructMap>(json);
            return result;
        }

        public static com.chronoxor.FBE.FieldModelValueType<StructMap> CreateFieldModel(com.chronoxor.FBE.Buffer buffer, long offset) { return new test.FBE.FieldModelStructMap(buffer, offset); }
    }

} // namespace com.chronoxor.test

namespace com.chronoxor.test.FBE {

    using global::com.chronoxor.test;

    // Fast Binary Encoding StructMap field model
    public class FieldModelStructMap : com.chronoxor.FBE.FieldModelValueType<StructMap>
    {
        public readonly com.chronoxor.FBE.FieldModelMapValueTypeKeyValueTypeValue<int, com.chronoxor.FBE.FieldModelValueType<int>, byte, com.chronoxor.FBE.FieldModelValueType<byte>> f1;
        public readonly com.chronoxor.FBE.FieldModelMapValueTypeKeyOptionalValueTypeValue<int, com.chronoxor.FBE.FieldModelValueType<int>, byte, com.chronoxor.FBE.FieldModelValueType<byte>> f2;
        public readonly com.chronoxor.FBE.FieldModelMapValueTypeKeyReferenceTypeValue<int, com.chronoxor.FBE.FieldModelValueType<int>, MemoryStream, com.chronoxor.FBE.FieldModelReferenceType<MemoryStream>> f3;
        public readonly com.chronoxor.FBE.FieldModelMapValueTypeKeyOptionalReferenceTypeValue<int, com.chronoxor.FBE.FieldModelValueType<int>, MemoryStream, com.chronoxor.FBE.FieldModelReferenceType<MemoryStream>> f4;
        public readonly com.chronoxor.FBE.FieldModelMapValueTypeKeyValueTypeValue<int, com.chronoxor.FBE.FieldModelValueType<int>, EnumSimple, com.chronoxor.test.FBE.FieldModelEnumSimple> f5;
        public readonly com.chronoxor.FBE.FieldModelMapValueTypeKeyOptionalValueTypeValue<int, com.chronoxor.FBE.FieldModelValueType<int>, EnumSimple, com.chronoxor.test.FBE.FieldModelEnumSimple> f6;
        public readonly com.chronoxor.FBE.FieldModelMapValueTypeKeyValueTypeValue<int, com.chronoxor.FBE.FieldModelValueType<int>, FlagsSimple, com.chronoxor.test.FBE.FieldModelFlagsSimple> f7;
        public readonly com.chronoxor.FBE.FieldModelMapValueTypeKeyOptionalValueTypeValue<int, com.chronoxor.FBE.FieldModelValueType<int>, FlagsSimple, com.chronoxor.test.FBE.FieldModelFlagsSimple> f8;
        public readonly com.chronoxor.FBE.FieldModelMapValueTypeKeyValueTypeValue<int, com.chronoxor.FBE.FieldModelValueType<int>, StructSimple, com.chronoxor.test.FBE.FieldModelStructSimple> f9;
        public readonly com.chronoxor.FBE.FieldModelMapValueTypeKeyOptionalValueTypeValue<int, com.chronoxor.FBE.FieldModelValueType<int>, StructSimple, com.chronoxor.test.FBE.FieldModelStructSimple> f10;

        public FieldModelStructMap(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset)
        {
            f1 = new com.chronoxor.FBE.FieldModelMapValueTypeKeyValueTypeValue<int, com.chronoxor.FBE.FieldModelValueType<int>, byte, com.chronoxor.FBE.FieldModelValueType<byte>>(com.chronoxor.FBE.FieldModelValueType<int>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.INT32, buffer, 4 + 4), com.chronoxor.FBE.FieldModelValueType<byte>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.BYTE, buffer, 4 + 4), buffer, 4 + 4);
            f2 = new com.chronoxor.FBE.FieldModelMapValueTypeKeyOptionalValueTypeValue<int, com.chronoxor.FBE.FieldModelValueType<int>, byte, com.chronoxor.FBE.FieldModelValueType<byte>>(com.chronoxor.FBE.FieldModelValueType<int>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.INT32, buffer, f1.FBEOffset + f1.FBESize), com.chronoxor.FBE.FieldModelValueType<byte>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.BYTE, buffer, f1.FBEOffset + f1.FBESize), buffer, f1.FBEOffset + f1.FBESize);
            f3 = new com.chronoxor.FBE.FieldModelMapValueTypeKeyReferenceTypeValue<int, com.chronoxor.FBE.FieldModelValueType<int>, MemoryStream, com.chronoxor.FBE.FieldModelReferenceType<MemoryStream>>(com.chronoxor.FBE.FieldModelValueType<int>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.INT32, buffer, f2.FBEOffset + f2.FBESize), com.chronoxor.FBE.FieldModelReferenceType<MemoryStream>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.BYTES, buffer, f2.FBEOffset + f2.FBESize), buffer, f2.FBEOffset + f2.FBESize);
            f4 = new com.chronoxor.FBE.FieldModelMapValueTypeKeyOptionalReferenceTypeValue<int, com.chronoxor.FBE.FieldModelValueType<int>, MemoryStream, com.chronoxor.FBE.FieldModelReferenceType<MemoryStream>>(com.chronoxor.FBE.FieldModelValueType<int>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.INT32, buffer, f3.FBEOffset + f3.FBESize), com.chronoxor.FBE.FieldModelReferenceType<MemoryStream>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.BYTES, buffer, f3.FBEOffset + f3.FBESize), buffer, f3.FBEOffset + f3.FBESize);
            f5 = new com.chronoxor.FBE.FieldModelMapValueTypeKeyValueTypeValue<int, com.chronoxor.FBE.FieldModelValueType<int>, EnumSimple, com.chronoxor.test.FBE.FieldModelEnumSimple>(com.chronoxor.FBE.FieldModelValueType<int>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.INT32, buffer, f4.FBEOffset + f4.FBESize), new com.chronoxor.test.FBE.FieldModelEnumSimple(buffer, f4.FBEOffset + f4.FBESize), buffer, f4.FBEOffset + f4.FBESize);
            f6 = new com.chronoxor.FBE.FieldModelMapValueTypeKeyOptionalValueTypeValue<int, com.chronoxor.FBE.FieldModelValueType<int>, EnumSimple, com.chronoxor.test.FBE.FieldModelEnumSimple>(com.chronoxor.FBE.FieldModelValueType<int>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.INT32, buffer, f5.FBEOffset + f5.FBESize), new com.chronoxor.test.FBE.FieldModelEnumSimple(buffer, f5.FBEOffset + f5.FBESize), buffer, f5.FBEOffset + f5.FBESize);
            f7 = new com.chronoxor.FBE.FieldModelMapValueTypeKeyValueTypeValue<int, com.chronoxor.FBE.FieldModelValueType<int>, FlagsSimple, com.chronoxor.test.FBE.FieldModelFlagsSimple>(com.chronoxor.FBE.FieldModelValueType<int>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.INT32, buffer, f6.FBEOffset + f6.FBESize), new com.chronoxor.test.FBE.FieldModelFlagsSimple(buffer, f6.FBEOffset + f6.FBESize), buffer, f6.FBEOffset + f6.FBESize);
            f8 = new com.chronoxor.FBE.FieldModelMapValueTypeKeyOptionalValueTypeValue<int, com.chronoxor.FBE.FieldModelValueType<int>, FlagsSimple, com.chronoxor.test.FBE.FieldModelFlagsSimple>(com.chronoxor.FBE.FieldModelValueType<int>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.INT32, buffer, f7.FBEOffset + f7.FBESize), new com.chronoxor.test.FBE.FieldModelFlagsSimple(buffer, f7.FBEOffset + f7.FBESize), buffer, f7.FBEOffset + f7.FBESize);
            f9 = new com.chronoxor.FBE.FieldModelMapValueTypeKeyValueTypeValue<int, com.chronoxor.FBE.FieldModelValueType<int>, StructSimple, com.chronoxor.test.FBE.FieldModelStructSimple>(com.chronoxor.FBE.FieldModelValueType<int>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.INT32, buffer, f8.FBEOffset + f8.FBESize), new com.chronoxor.test.FBE.FieldModelStructSimple(buffer, f8.FBEOffset + f8.FBESize), buffer, f8.FBEOffset + f8.FBESize);
            f10 = new com.chronoxor.FBE.FieldModelMapValueTypeKeyOptionalValueTypeValue<int, com.chronoxor.FBE.FieldModelValueType<int>, StructSimple, com.chronoxor.test.FBE.FieldModelStructSimple>(com.chronoxor.FBE.FieldModelValueType<int>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.INT32, buffer, f9.FBEOffset + f9.FBESize), new com.chronoxor.test.FBE.FieldModelStructSimple(buffer, f9.FBEOffset + f9.FBESize), buffer, f9.FBEOffset + f9.FBESize);
        }

        // Get the field size
        public override long FBESize => 4;
        // Get the field body size
        public long FBEBody
        {
            get
            {
                long fbeResult = 4 + 4
                    + f1.FBESize
                    + f2.FBESize
                    + f3.FBESize
                    + f4.FBESize
                    + f5.FBESize
                    + f6.FBESize
                    + f7.FBESize
                    + f8.FBESize
                    + f9.FBESize
                    + f10.FBESize
                    ;
                return fbeResult;
            }
        }
        // Get the field extra size
        public override long FBEExtra
        {
            get
            {
                if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                    return 0;

                uint fbeStructOffset = ReadUInt32(FBEOffset);
                if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4) > _buffer.Size))
                    return 0;

                _buffer.Shift(fbeStructOffset);

                long fbeResult = FBEBody
                    + f1.FBEExtra
                    + f2.FBEExtra
                    + f3.FBEExtra
                    + f4.FBEExtra
                    + f5.FBEExtra
                    + f6.FBEExtra
                    + f7.FBEExtra
                    + f8.FBEExtra
                    + f9.FBEExtra
                    + f10.FBEExtra
                    ;

                _buffer.Unshift(fbeStructOffset);

                return fbeResult;
            }
        }
        // Get the field type
        public const long FBETypeConst = 140;
        public long FBEType => FBETypeConst;

        // Clone the field model
        public override com.chronoxor.FBE.FieldModelValueType<StructMap> Clone() { return new FieldModelStructMap(_buffer, _offset); }

        // Check if the struct value is valid
        public override bool Verify() { return Verify(true); }
        public bool Verify(bool fbeVerifyType)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return true;

            uint fbeStructOffset = ReadUInt32(FBEOffset);
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
                return false;

            uint fbeStructSize = ReadUInt32(fbeStructOffset);
            if (fbeStructSize < (4 + 4))
                return false;

            uint fbeStructType = ReadUInt32(fbeStructOffset + 4);
            if (fbeVerifyType && (fbeStructType != FBEType))
                return false;

            _buffer.Shift(fbeStructOffset);
            bool fbeResult = VerifyFields(fbeStructSize);
            _buffer.Unshift(fbeStructOffset);
            return fbeResult;
        }

        // Check if the struct fields are valid
        public bool VerifyFields(long fbeStructSize)
        {
            long fbeCurrentSize = 4 + 4;

            if ((fbeCurrentSize + f1.FBESize) > fbeStructSize)
                return true;
            if (!f1.Verify())
                return false;
            fbeCurrentSize += f1.FBESize;

            if ((fbeCurrentSize + f2.FBESize) > fbeStructSize)
                return true;
            if (!f2.Verify())
                return false;
            fbeCurrentSize += f2.FBESize;

            if ((fbeCurrentSize + f3.FBESize) > fbeStructSize)
                return true;
            if (!f3.Verify())
                return false;
            fbeCurrentSize += f3.FBESize;

            if ((fbeCurrentSize + f4.FBESize) > fbeStructSize)
                return true;
            if (!f4.Verify())
                return false;
            fbeCurrentSize += f4.FBESize;

            if ((fbeCurrentSize + f5.FBESize) > fbeStructSize)
                return true;
            if (!f5.Verify())
                return false;
            fbeCurrentSize += f5.FBESize;

            if ((fbeCurrentSize + f6.FBESize) > fbeStructSize)
                return true;
            if (!f6.Verify())
                return false;
            fbeCurrentSize += f6.FBESize;

            if ((fbeCurrentSize + f7.FBESize) > fbeStructSize)
                return true;
            if (!f7.Verify())
                return false;
            fbeCurrentSize += f7.FBESize;

            if ((fbeCurrentSize + f8.FBESize) > fbeStructSize)
                return true;
            if (!f8.Verify())
                return false;
            fbeCurrentSize += f8.FBESize;

            if ((fbeCurrentSize + f9.FBESize) > fbeStructSize)
                return true;
            if (!f9.Verify())
                return false;
            fbeCurrentSize += f9.FBESize;

            if ((fbeCurrentSize + f10.FBESize) > fbeStructSize)
                return true;
            if (!f10.Verify())
                return false;
            fbeCurrentSize += f10.FBESize;

            return true;
        }

        // Get the struct value (begin phase)
        public long GetBegin()
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            uint fbeStructOffset = ReadUInt32(FBEOffset);
            Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + 4 + 4) <= _buffer.Size)), "Model is broken!");
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
                return 0;

            uint fbeStructSize = ReadUInt32(fbeStructOffset);
            Debug.Assert((fbeStructSize >= (4 + 4)), "Model is broken!");
            if (fbeStructSize < (4 + 4))
                return 0;

            _buffer.Shift(fbeStructOffset);
            return fbeStructOffset;
        }

        // Get the struct value (end phase)
        public void GetEnd(long fbeBegin)
        {
            _buffer.Unshift(fbeBegin);
        }

        // Get the struct value
        public override void Get(out StructMap fbeValue) { Get(out fbeValue, StructMap.Default); }
        public override void Get(out StructMap fbeValue, StructMap defaults)
        {
            long fbeBegin = GetBegin();
            if (fbeBegin == 0)
            {
                fbeValue = defaults;
                return;
            }

            uint fbeStructSize = ReadUInt32(0);
            GetFields(out fbeValue, fbeStructSize);
            GetEnd(fbeBegin);
        }

        // Get the struct fields values
        public void GetFields(out StructMap fbeValue, long fbeStructSize)
        {
            long fbeCurrentSize = 4 + 4;

            fbeValue = StructMap.Default;

            if ((fbeCurrentSize + f1.FBESize) <= fbeStructSize)
                f1.Get(ref fbeValue.f1);
            else
                fbeValue.f1.Clear();
            fbeCurrentSize += f1.FBESize;

            if ((fbeCurrentSize + f2.FBESize) <= fbeStructSize)
                f2.Get(ref fbeValue.f2);
            else
                fbeValue.f2.Clear();
            fbeCurrentSize += f2.FBESize;

            if ((fbeCurrentSize + f3.FBESize) <= fbeStructSize)
                f3.Get(ref fbeValue.f3);
            else
                fbeValue.f3.Clear();
            fbeCurrentSize += f3.FBESize;

            if ((fbeCurrentSize + f4.FBESize) <= fbeStructSize)
                f4.Get(ref fbeValue.f4);
            else
                fbeValue.f4.Clear();
            fbeCurrentSize += f4.FBESize;

            if ((fbeCurrentSize + f5.FBESize) <= fbeStructSize)
                f5.Get(ref fbeValue.f5);
            else
                fbeValue.f5.Clear();
            fbeCurrentSize += f5.FBESize;

            if ((fbeCurrentSize + f6.FBESize) <= fbeStructSize)
                f6.Get(ref fbeValue.f6);
            else
                fbeValue.f6.Clear();
            fbeCurrentSize += f6.FBESize;

            if ((fbeCurrentSize + f7.FBESize) <= fbeStructSize)
                f7.Get(ref fbeValue.f7);
            else
                fbeValue.f7.Clear();
            fbeCurrentSize += f7.FBESize;

            if ((fbeCurrentSize + f8.FBESize) <= fbeStructSize)
                f8.Get(ref fbeValue.f8);
            else
                fbeValue.f8.Clear();
            fbeCurrentSize += f8.FBESize;

            if ((fbeCurrentSize + f9.FBESize) <= fbeStructSize)
                f9.Get(ref fbeValue.f9);
            else
                fbeValue.f9.Clear();
            fbeCurrentSize += f9.FBESize;

            if ((fbeCurrentSize + f10.FBESize) <= fbeStructSize)
                f10.Get(ref fbeValue.f10);
            else
                fbeValue.f10.Clear();
            fbeCurrentSize += f10.FBESize;
        }

        // Set the struct value (begin phase)
        public long SetBegin()
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            uint fbeStructSize = (uint)FBEBody;
            uint fbeStructOffset = (uint)(_buffer.Allocate(fbeStructSize) - _buffer.Offset);
            Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + fbeStructSize) <= _buffer.Size)), "Model is broken!");
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + fbeStructSize) > _buffer.Size))
                return 0;

            Write(FBEOffset, fbeStructOffset);
            Write(fbeStructOffset, fbeStructSize);
            Write(fbeStructOffset + 4, (uint)FBEType);

            _buffer.Shift(fbeStructOffset);
            return fbeStructOffset;
        }

        // Set the struct value (end phase)
        public void SetEnd(long fbeBegin)
        {
            _buffer.Unshift(fbeBegin);
        }

        // Set the struct value
        public override void Set(StructMap fbeValue)
        {
            long fbeBegin = SetBegin();
            if (fbeBegin == 0)
                return;

            SetFields(fbeValue);
            SetEnd(fbeBegin);
        }

        // Set the struct fields values
        public void SetFields(StructMap fbeValue)
        {
            f1.Set(fbeValue.f1);
            f2.Set(fbeValue.f2);
            f3.Set(fbeValue.f3);
            f4.Set(fbeValue.f4);
            f5.Set(fbeValue.f5);
            f6.Set(fbeValue.f6);
            f7.Set(fbeValue.f7);
            f8.Set(fbeValue.f8);
            f9.Set(fbeValue.f9);
            f10.Set(fbeValue.f10);
        }
    }

} // namespace com.chronoxor.test.FBE

namespace com.chronoxor.test.FBE {

    using global::com.chronoxor.test;

    // Fast Binary Encoding StructMap model
    public class StructMapModel : com.chronoxor.FBE.Model
    {
        public readonly FieldModelStructMap model;

        public StructMapModel() { model = new FieldModelStructMap(Buffer, 4); }
        public StructMapModel(com.chronoxor.FBE.Buffer buffer) : base(buffer) { model = new FieldModelStructMap(Buffer, 4); }

        // Get the model size
        public long FBESize => model.FBESize + model.FBEExtra;
        // Get the model type
        public const long FBETypeConst = FieldModelStructMap.FBETypeConst;
        public long FBEType => FBETypeConst;

        // Check if the struct value is valid
        public bool Verify()
        {
            if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
                return false;

            uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
            if (fbeFullSize < model.FBESize)
                return false;

            return model.Verify();
        }

        // Create a new model (begin phase)
        public long CreateBegin()
        {
            long fbeBegin = Buffer.Allocate(4 + model.FBESize);
            return fbeBegin;
        }

        // Create a new model (end phase)
        public long CreateEnd(long fbeBegin)
        {
            long fbeEnd = Buffer.Size;
            uint fbeFullSize = (uint)(fbeEnd - fbeBegin);
            Write(model.FBEOffset - 4, fbeFullSize);
            return fbeFullSize;
        }

        // Serialize the struct value
        public long Serialize(StructMap value)
        {
            long fbeBegin = CreateBegin();
            model.Set(value);
            long fbeFullSize = CreateEnd(fbeBegin);
            return fbeFullSize;
        }

        // Deserialize the struct value
        public long Deserialize(out StructMap value)
        {
            if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
            {
                value = StructMap.Default;
                return 0;
            }

            uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
            Debug.Assert((fbeFullSize >= model.FBESize), "Model is broken!");
            if (fbeFullSize < model.FBESize)
            {
                value = StructMap.Default;
                return 0;
            }

            model.Get(out value);
            return fbeFullSize;
        }

        // Move to the next struct value
        public void Next(long prev)
        {
            model.FBEShift(prev);
        }
    }

} // namespace com.chronoxor.test.FBE

namespace com.chronoxor.test.FBE {

    using global::com.chronoxor.test;

    // Fast Binary Encoding StructMap final model
    public class FinalModelStructMap : com.chronoxor.FBE.FinalModelValueType<StructMap>
    {
        public readonly com.chronoxor.FBE.FinalModelMapValueTypeKeyValueTypeValue<int, com.chronoxor.FBE.FinalModelValueType<int>, byte, com.chronoxor.FBE.FinalModelValueType<byte>> f1;
        public readonly com.chronoxor.FBE.FinalModelMapValueTypeKeyOptionalValueTypeValue<int, com.chronoxor.FBE.FinalModelValueType<int>, byte, com.chronoxor.FBE.FinalModelValueType<byte>> f2;
        public readonly com.chronoxor.FBE.FinalModelMapValueTypeKeyReferenceTypeValue<int, com.chronoxor.FBE.FinalModelValueType<int>, MemoryStream, com.chronoxor.FBE.FinalModelReferenceType<MemoryStream>> f3;
        public readonly com.chronoxor.FBE.FinalModelMapValueTypeKeyOptionalReferenceTypeValue<int, com.chronoxor.FBE.FinalModelValueType<int>, MemoryStream, com.chronoxor.FBE.FinalModelReferenceType<MemoryStream>> f4;
        public readonly com.chronoxor.FBE.FinalModelMapValueTypeKeyValueTypeValue<int, com.chronoxor.FBE.FinalModelValueType<int>, EnumSimple, com.chronoxor.test.FBE.FinalModelEnumSimple> f5;
        public readonly com.chronoxor.FBE.FinalModelMapValueTypeKeyOptionalValueTypeValue<int, com.chronoxor.FBE.FinalModelValueType<int>, EnumSimple, com.chronoxor.test.FBE.FinalModelEnumSimple> f6;
        public readonly com.chronoxor.FBE.FinalModelMapValueTypeKeyValueTypeValue<int, com.chronoxor.FBE.FinalModelValueType<int>, FlagsSimple, com.chronoxor.test.FBE.FinalModelFlagsSimple> f7;
        public readonly com.chronoxor.FBE.FinalModelMapValueTypeKeyOptionalValueTypeValue<int, com.chronoxor.FBE.FinalModelValueType<int>, FlagsSimple, com.chronoxor.test.FBE.FinalModelFlagsSimple> f8;
        public readonly com.chronoxor.FBE.FinalModelMapValueTypeKeyValueTypeValue<int, com.chronoxor.FBE.FinalModelValueType<int>, StructSimple, com.chronoxor.test.FBE.FinalModelStructSimple> f9;
        public readonly com.chronoxor.FBE.FinalModelMapValueTypeKeyOptionalValueTypeValue<int, com.chronoxor.FBE.FinalModelValueType<int>, StructSimple, com.chronoxor.test.FBE.FinalModelStructSimple> f10;

        public FinalModelStructMap(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset)
        {
            f1 = new com.chronoxor.FBE.FinalModelMapValueTypeKeyValueTypeValue<int, com.chronoxor.FBE.FinalModelValueType<int>, byte, com.chronoxor.FBE.FinalModelValueType<byte>>(com.chronoxor.FBE.FinalModelValueType<int>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.INT32, buffer, 0), com.chronoxor.FBE.FinalModelValueType<byte>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.BYTE, buffer, 0), buffer, 0);
            f2 = new com.chronoxor.FBE.FinalModelMapValueTypeKeyOptionalValueTypeValue<int, com.chronoxor.FBE.FinalModelValueType<int>, byte, com.chronoxor.FBE.FinalModelValueType<byte>>(com.chronoxor.FBE.FinalModelValueType<int>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.INT32, buffer, 0), com.chronoxor.FBE.FinalModelValueType<byte>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.BYTE, buffer, 0), buffer, 0);
            f3 = new com.chronoxor.FBE.FinalModelMapValueTypeKeyReferenceTypeValue<int, com.chronoxor.FBE.FinalModelValueType<int>, MemoryStream, com.chronoxor.FBE.FinalModelReferenceType<MemoryStream>>(com.chronoxor.FBE.FinalModelValueType<int>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.INT32, buffer, 0), com.chronoxor.FBE.FinalModelReferenceType<MemoryStream>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.BYTES, buffer, 0), buffer, 0);
            f4 = new com.chronoxor.FBE.FinalModelMapValueTypeKeyOptionalReferenceTypeValue<int, com.chronoxor.FBE.FinalModelValueType<int>, MemoryStream, com.chronoxor.FBE.FinalModelReferenceType<MemoryStream>>(com.chronoxor.FBE.FinalModelValueType<int>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.INT32, buffer, 0), com.chronoxor.FBE.FinalModelReferenceType<MemoryStream>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.BYTES, buffer, 0), buffer, 0);
            f5 = new com.chronoxor.FBE.FinalModelMapValueTypeKeyValueTypeValue<int, com.chronoxor.FBE.FinalModelValueType<int>, EnumSimple, com.chronoxor.test.FBE.FinalModelEnumSimple>(com.chronoxor.FBE.FinalModelValueType<int>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.INT32, buffer, 0), new com.chronoxor.test.FBE.FinalModelEnumSimple(buffer, 0), buffer, 0);
            f6 = new com.chronoxor.FBE.FinalModelMapValueTypeKeyOptionalValueTypeValue<int, com.chronoxor.FBE.FinalModelValueType<int>, EnumSimple, com.chronoxor.test.FBE.FinalModelEnumSimple>(com.chronoxor.FBE.FinalModelValueType<int>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.INT32, buffer, 0), new com.chronoxor.test.FBE.FinalModelEnumSimple(buffer, 0), buffer, 0);
            f7 = new com.chronoxor.FBE.FinalModelMapValueTypeKeyValueTypeValue<int, com.chronoxor.FBE.FinalModelValueType<int>, FlagsSimple, com.chronoxor.test.FBE.FinalModelFlagsSimple>(com.chronoxor.FBE.FinalModelValueType<int>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.INT32, buffer, 0), new com.chronoxor.test.FBE.FinalModelFlagsSimple(buffer, 0), buffer, 0);
            f8 = new com.chronoxor.FBE.FinalModelMapValueTypeKeyOptionalValueTypeValue<int, com.chronoxor.FBE.FinalModelValueType<int>, FlagsSimple, com.chronoxor.test.FBE.FinalModelFlagsSimple>(com.chronoxor.FBE.FinalModelValueType<int>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.INT32, buffer, 0), new com.chronoxor.test.FBE.FinalModelFlagsSimple(buffer, 0), buffer, 0);
            f9 = new com.chronoxor.FBE.FinalModelMapValueTypeKeyValueTypeValue<int, com.chronoxor.FBE.FinalModelValueType<int>, StructSimple, com.chronoxor.test.FBE.FinalModelStructSimple>(com.chronoxor.FBE.FinalModelValueType<int>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.INT32, buffer, 0), new com.chronoxor.test.FBE.FinalModelStructSimple(buffer, 0), buffer, 0);
            f10 = new com.chronoxor.FBE.FinalModelMapValueTypeKeyOptionalValueTypeValue<int, com.chronoxor.FBE.FinalModelValueType<int>, StructSimple, com.chronoxor.test.FBE.FinalModelStructSimple>(com.chronoxor.FBE.FinalModelValueType<int>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.INT32, buffer, 0), new com.chronoxor.test.FBE.FinalModelStructSimple(buffer, 0), buffer, 0);
        }

        // Get the allocation size
        public override long FBEAllocationSize(StructMap fbeValue)
        {
            long fbeResult = 0
                + f1.FBEAllocationSize(fbeValue.f1)
                + f2.FBEAllocationSize(fbeValue.f2)
                + f3.FBEAllocationSize(fbeValue.f3)
                + f4.FBEAllocationSize(fbeValue.f4)
                + f5.FBEAllocationSize(fbeValue.f5)
                + f6.FBEAllocationSize(fbeValue.f6)
                + f7.FBEAllocationSize(fbeValue.f7)
                + f8.FBEAllocationSize(fbeValue.f8)
                + f9.FBEAllocationSize(fbeValue.f9)
                + f10.FBEAllocationSize(fbeValue.f10)
                ;
            return fbeResult;
        }

        // Get the final type
        public const long FBETypeConst = 140;
        public long FBEType => FBETypeConst;

        // Clone the final model
        public override com.chronoxor.FBE.FinalModelValueType<StructMap> Clone() { return new FinalModelStructMap(_buffer, _offset); }

        // Check if the struct value is valid
        public override long Verify()
        {
            _buffer.Shift(FBEOffset);
            long fbeResult = VerifyFields();
            _buffer.Unshift(FBEOffset);
            return fbeResult;
        }

        // Check if the struct fields are valid
        public long VerifyFields()
        {
            long fbeCurrentOffset = 0;
            long fbeFieldSize;

            f1.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f1.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f2.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f2.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f3.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f3.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f4.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f4.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f5.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f5.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f6.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f6.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f7.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f7.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f8.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f8.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f9.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f9.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f10.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f10.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            return fbeCurrentOffset;
        }

        // Get the struct value
        public override long Get(out StructMap fbeValue)
        {
            _buffer.Shift(FBEOffset);
            long fbeSize = GetFields(out fbeValue);
            _buffer.Unshift(FBEOffset);
            return fbeSize;
        }

        // Get the struct fields values
        public long GetFields(out StructMap fbeValue)
        {
            long fbeCurrentOffset = 0;
            long fbeCurrentSize = 0;
            long fbeFieldSize;

            fbeValue = StructMap.Default;

            f1.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f1.Get(out fbeValue.f1);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f2.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f2.Get(out fbeValue.f2);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f3.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f3.Get(out fbeValue.f3);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f4.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f4.Get(out fbeValue.f4);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f5.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f5.Get(out fbeValue.f5);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f6.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f6.Get(out fbeValue.f6);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f7.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f7.Get(out fbeValue.f7);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f8.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f8.Get(out fbeValue.f8);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f9.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f9.Get(out fbeValue.f9);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f10.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f10.Get(out fbeValue.f10);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            return fbeCurrentSize;
        }

        // Set the struct value
        public override long Set(StructMap fbeValue)
        {
            _buffer.Shift(FBEOffset);
            long fbeResult = SetFields(fbeValue);
            _buffer.Unshift(FBEOffset);
            return fbeResult;
        }

        // Set the struct fields values
        public long SetFields(StructMap fbeValue)
        {
            long fbeCurrentOffset = 0;
            long fbeCurrentSize = 0;
            long fbeFieldSize;

            f1.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f1.Set(fbeValue.f1);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f2.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f2.Set(fbeValue.f2);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f3.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f3.Set(fbeValue.f3);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f4.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f4.Set(fbeValue.f4);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f5.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f5.Set(fbeValue.f5);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f6.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f6.Set(fbeValue.f6);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f7.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f7.Set(fbeValue.f7);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f8.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f8.Set(fbeValue.f8);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f9.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f9.Set(fbeValue.f9);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f10.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f10.Set(fbeValue.f10);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            return fbeCurrentSize;
        }
    }

} // namespace com.chronoxor.test.FBE

namespace com.chronoxor.test.FBE {

    using global::com.chronoxor.test;

    // Fast Binary Encoding StructMap final model
    public class StructMapFinalModel : com.chronoxor.FBE.Model
    {
        private readonly FinalModelStructMap _model;

        public StructMapFinalModel() { _model = new FinalModelStructMap(Buffer, 8); }
        public StructMapFinalModel(com.chronoxor.FBE.Buffer buffer) : base(buffer) { _model = new FinalModelStructMap(Buffer, 8); }

        // Get the model type
        public const long FBETypeConst = FinalModelStructMap.FBETypeConst;
        public long FBEType => FBETypeConst;

        // Check if the struct value is valid
        public bool Verify()
        {
            if ((Buffer.Offset + _model.FBEOffset) > Buffer.Size)
                return false;

            long fbeStructSize = ReadUInt32(_model.FBEOffset - 8);
            long fbeStructType = ReadUInt32(_model.FBEOffset - 4);
            if ((fbeStructSize <= 0) || (fbeStructType != FBEType))
                return false;

            return ((8 + _model.Verify()) == fbeStructSize);
        }

        // Serialize the struct value
        public long Serialize(StructMap value)
        {
            long fbeInitialSize = Buffer.Size;

            uint fbeStructType = (uint)FBEType;
            uint fbeStructSize = (uint)(8 + _model.FBEAllocationSize(value));
            uint fbeStructOffset = (uint)(Buffer.Allocate(fbeStructSize) - Buffer.Offset);
            Debug.Assert(((Buffer.Offset + fbeStructOffset + fbeStructSize) <= Buffer.Size), "Model is broken!");
            if ((Buffer.Offset + fbeStructOffset + fbeStructSize) > Buffer.Size)
                return 0;

            fbeStructSize = (uint)(8 + _model.Set(value));
            Buffer.Resize(fbeInitialSize + fbeStructSize);

            Write(_model.FBEOffset - 8, fbeStructSize);
            Write(_model.FBEOffset - 4, fbeStructType);

            return fbeStructSize;
        }

        // Deserialize the struct value
        public long Deserialize(out StructMap value)
        {
            Debug.Assert(((Buffer.Offset + _model.FBEOffset) <= Buffer.Size), "Model is broken!");
            if ((Buffer.Offset + _model.FBEOffset) > Buffer.Size)
            {
                value = StructMap.Default;
                return 0;
            }

            long fbeStructSize = ReadUInt32(_model.FBEOffset - 8);
            long fbeStructType = ReadUInt32(_model.FBEOffset - 4);
            Debug.Assert(((fbeStructSize > 0) && (fbeStructType == FBEType)), "Model is broken!");
            if ((fbeStructSize <= 0) || (fbeStructType != FBEType))
            {
                value = StructMap.Default;
                return 8;
            }

            return 8 + _model.Get(out value);
        }

        // Move to the next struct value
        public void Next(long prev)
        {
            _model.FBEShift(prev);
        }
    }

} // namespace com.chronoxor.test.FBE

namespace com.chronoxor.test {

    public struct StructHash : IComparable, IComparable<StructHash>, IEquatable<StructHash>
    {
        public Dictionary<string, byte> f1;
        public Dictionary<string, byte?> f2;
        public Dictionary<string, MemoryStream> f3;
        public Dictionary<string, MemoryStream> f4;
        public Dictionary<string, EnumSimple> f5;
        public Dictionary<string, EnumSimple?> f6;
        public Dictionary<string, FlagsSimple> f7;
        public Dictionary<string, FlagsSimple?> f8;
        public Dictionary<string, StructSimple> f9;
        public Dictionary<string, StructSimple?> f10;

        public const long FBETypeConst = 141;
        #if UTF8JSON
        [IgnoreDataMember]
        #else
        [JsonIgnore]
        #endif
        public long FBEType => FBETypeConst;

        public static StructHash Default => new StructHash
        {
            f1 = new Dictionary<string, byte>()
            , f2 = new Dictionary<string, byte?>()
            , f3 = new Dictionary<string, MemoryStream>()
            , f4 = new Dictionary<string, MemoryStream>()
            , f5 = new Dictionary<string, EnumSimple>()
            , f6 = new Dictionary<string, EnumSimple?>()
            , f7 = new Dictionary<string, FlagsSimple>()
            , f8 = new Dictionary<string, FlagsSimple?>()
            , f9 = new Dictionary<string, StructSimple>()
            , f10 = new Dictionary<string, StructSimple?>()
        };

        public StructHash(Dictionary<string, byte> f1, Dictionary<string, byte?> f2, Dictionary<string, MemoryStream> f3, Dictionary<string, MemoryStream> f4, Dictionary<string, EnumSimple> f5, Dictionary<string, EnumSimple?> f6, Dictionary<string, FlagsSimple> f7, Dictionary<string, FlagsSimple?> f8, Dictionary<string, StructSimple> f9, Dictionary<string, StructSimple?> f10)
        {
            this.f1 = f1;
            this.f2 = f2;
            this.f3 = f3;
            this.f4 = f4;
            this.f5 = f5;
            this.f6 = f6;
            this.f7 = f7;
            this.f8 = f8;
            this.f9 = f9;
            this.f10 = f10;
        }

        public StructHash Clone()
        {
            // Serialize the struct to the FBE stream
            var writer = new com.chronoxor.test.FBE.StructHashModel();
            writer.Serialize(this);

            // Deserialize the struct from the FBE stream
            var reader = new com.chronoxor.test.FBE.StructHashModel();
            reader.Attach(writer.Buffer);
            reader.Deserialize(out var result);
            return result;
        }

        public int CompareTo(object other)
        {
            int result = 0;
            return result;
        }

        public int CompareTo(StructHash other)
        {
            int result = 0;
            return result;
        }

        public override bool Equals(object other)
        {
            if (!(other is StructHash))
                return false;
            return true;
        }

        public bool Equals(StructHash other)
        {
            return true;
        }

        public override int GetHashCode()
        {
            int hash = 17;
            return hash;
        }

        public static bool operator==(StructHash lhs, StructHash rhs) => lhs.Equals(rhs);
        public static bool operator!=(StructHash lhs, StructHash rhs) => !(lhs == rhs);

        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("StructHash(");
            if (f1 != null)
            {
                bool first = true;
                sb.Append("f1=[").Append(f1.Count).Append("][{");
                foreach (var item in f1)
                {
                    if (item.Key != null) sb.Append(first ? "" : ",").Append("\"").Append(item.Key).Append("\""); else sb.Append(first ? "" : ",").Append("null");
                    sb.Append("->");
                    sb.Append(item.Value);
                    first = false;
                }
                sb.Append("}]");
            }
            else
            {
                sb.Append("f1=[0][{}]");
            }
            if (f2 != null)
            {
                bool first = true;
                sb.Append(",f2=[").Append(f2.Count).Append("][{");
                foreach (var item in f2)
                {
                    if (item.Key != null) sb.Append(first ? "" : ",").Append("\"").Append(item.Key).Append("\""); else sb.Append(first ? "" : ",").Append("null");
                    sb.Append("->");
                    if (item.Value != null) sb.Append(item.Value); else sb.Append("null");
                    first = false;
                }
                sb.Append("}]");
            }
            else
            {
                sb.Append(",f2=[0][{}]");
            }
            if (f3 != null)
            {
                bool first = true;
                sb.Append(",f3=[").Append(f3.Count).Append("][{");
                foreach (var item in f3)
                {
                    if (item.Key != null) sb.Append(first ? "" : ",").Append("\"").Append(item.Key).Append("\""); else sb.Append(first ? "" : ",").Append("null");
                    sb.Append("->");
                    if (item.Value != null) sb.Append("bytes[").Append(item.Value.Length).Append("]"); else sb.Append("null");
                    first = false;
                }
                sb.Append("}]");
            }
            else
            {
                sb.Append(",f3=[0][{}]");
            }
            if (f4 != null)
            {
                bool first = true;
                sb.Append(",f4=[").Append(f4.Count).Append("][{");
                foreach (var item in f4)
                {
                    if (item.Key != null) sb.Append(first ? "" : ",").Append("\"").Append(item.Key).Append("\""); else sb.Append(first ? "" : ",").Append("null");
                    sb.Append("->");
                    if (item.Value != null) sb.Append("bytes[").Append(item.Value.Length).Append("]"); else sb.Append("null");
                    first = false;
                }
                sb.Append("}]");
            }
            else
            {
                sb.Append(",f4=[0][{}]");
            }
            if (f5 != null)
            {
                bool first = true;
                sb.Append(",f5=[").Append(f5.Count).Append("][{");
                foreach (var item in f5)
                {
                    if (item.Key != null) sb.Append(first ? "" : ",").Append("\"").Append(item.Key).Append("\""); else sb.Append(first ? "" : ",").Append("null");
                    sb.Append("->");
                    sb.Append(item.Value);
                    first = false;
                }
                sb.Append("}]");
            }
            else
            {
                sb.Append(",f5=[0][{}]");
            }
            if (f6 != null)
            {
                bool first = true;
                sb.Append(",f6=[").Append(f6.Count).Append("][{");
                foreach (var item in f6)
                {
                    if (item.Key != null) sb.Append(first ? "" : ",").Append("\"").Append(item.Key).Append("\""); else sb.Append(first ? "" : ",").Append("null");
                    sb.Append("->");
                    if (item.Value != null) sb.Append(item.Value); else sb.Append("null");
                    first = false;
                }
                sb.Append("}]");
            }
            else
            {
                sb.Append(",f6=[0][{}]");
            }
            if (f7 != null)
            {
                bool first = true;
                sb.Append(",f7=[").Append(f7.Count).Append("][{");
                foreach (var item in f7)
                {
                    if (item.Key != null) sb.Append(first ? "" : ",").Append("\"").Append(item.Key).Append("\""); else sb.Append(first ? "" : ",").Append("null");
                    sb.Append("->");
                    sb.Append(item.Value);
                    first = false;
                }
                sb.Append("}]");
            }
            else
            {
                sb.Append(",f7=[0][{}]");
            }
            if (f8 != null)
            {
                bool first = true;
                sb.Append(",f8=[").Append(f8.Count).Append("][{");
                foreach (var item in f8)
                {
                    if (item.Key != null) sb.Append(first ? "" : ",").Append("\"").Append(item.Key).Append("\""); else sb.Append(first ? "" : ",").Append("null");
                    sb.Append("->");
                    if (item.Value != null) sb.Append(item.Value); else sb.Append("null");
                    first = false;
                }
                sb.Append("}]");
            }
            else
            {
                sb.Append(",f8=[0][{}]");
            }
            if (f9 != null)
            {
                bool first = true;
                sb.Append(",f9=[").Append(f9.Count).Append("][{");
                foreach (var item in f9)
                {
                    if (item.Key != null) sb.Append(first ? "" : ",").Append("\"").Append(item.Key).Append("\""); else sb.Append(first ? "" : ",").Append("null");
                    sb.Append("->");
                    sb.Append(item.Value);
                    first = false;
                }
                sb.Append("}]");
            }
            else
            {
                sb.Append(",f9=[0][{}]");
            }
            if (f10 != null)
            {
                bool first = true;
                sb.Append(",f10=[").Append(f10.Count).Append("][{");
                foreach (var item in f10)
                {
                    if (item.Key != null) sb.Append(first ? "" : ",").Append("\"").Append(item.Key).Append("\""); else sb.Append(first ? "" : ",").Append("null");
                    sb.Append("->");
                    if (item.Value != null) sb.Append(item.Value); else sb.Append("null");
                    first = false;
                }
                sb.Append("}]");
            }
            else
            {
                sb.Append(",f10=[0][{}]");
            }
            sb.Append(")");
            return sb.ToString();
        }

        public string ToJson()
        {
            var json = com.chronoxor.FBE.Json.ToJson(this);
            return json;
        }

        public static StructHash FromJson(string json)
        {
            var result = com.chronoxor.FBE.Json.FromJson<StructHash>(json);
            return result;
        }

        public static com.chronoxor.FBE.FieldModelValueType<StructHash> CreateFieldModel(com.chronoxor.FBE.Buffer buffer, long offset) { return new test.FBE.FieldModelStructHash(buffer, offset); }
    }

} // namespace com.chronoxor.test

namespace com.chronoxor.test.FBE {

    using global::com.chronoxor.test;

    // Fast Binary Encoding StructHash field model
    public class FieldModelStructHash : com.chronoxor.FBE.FieldModelValueType<StructHash>
    {
        public readonly com.chronoxor.FBE.FieldModelMapReferenceTypeKeyValueTypeValue<string, com.chronoxor.FBE.FieldModelReferenceType<string>, byte, com.chronoxor.FBE.FieldModelValueType<byte>> f1;
        public readonly com.chronoxor.FBE.FieldModelMapReferenceTypeKeyOptionalValueTypeValue<string, com.chronoxor.FBE.FieldModelReferenceType<string>, byte, com.chronoxor.FBE.FieldModelValueType<byte>> f2;
        public readonly com.chronoxor.FBE.FieldModelMapReferenceTypeKeyReferenceTypeValue<string, com.chronoxor.FBE.FieldModelReferenceType<string>, MemoryStream, com.chronoxor.FBE.FieldModelReferenceType<MemoryStream>> f3;
        public readonly com.chronoxor.FBE.FieldModelMapReferenceTypeKeyOptionalReferenceTypeValue<string, com.chronoxor.FBE.FieldModelReferenceType<string>, MemoryStream, com.chronoxor.FBE.FieldModelReferenceType<MemoryStream>> f4;
        public readonly com.chronoxor.FBE.FieldModelMapReferenceTypeKeyValueTypeValue<string, com.chronoxor.FBE.FieldModelReferenceType<string>, EnumSimple, com.chronoxor.test.FBE.FieldModelEnumSimple> f5;
        public readonly com.chronoxor.FBE.FieldModelMapReferenceTypeKeyOptionalValueTypeValue<string, com.chronoxor.FBE.FieldModelReferenceType<string>, EnumSimple, com.chronoxor.test.FBE.FieldModelEnumSimple> f6;
        public readonly com.chronoxor.FBE.FieldModelMapReferenceTypeKeyValueTypeValue<string, com.chronoxor.FBE.FieldModelReferenceType<string>, FlagsSimple, com.chronoxor.test.FBE.FieldModelFlagsSimple> f7;
        public readonly com.chronoxor.FBE.FieldModelMapReferenceTypeKeyOptionalValueTypeValue<string, com.chronoxor.FBE.FieldModelReferenceType<string>, FlagsSimple, com.chronoxor.test.FBE.FieldModelFlagsSimple> f8;
        public readonly com.chronoxor.FBE.FieldModelMapReferenceTypeKeyValueTypeValue<string, com.chronoxor.FBE.FieldModelReferenceType<string>, StructSimple, com.chronoxor.test.FBE.FieldModelStructSimple> f9;
        public readonly com.chronoxor.FBE.FieldModelMapReferenceTypeKeyOptionalValueTypeValue<string, com.chronoxor.FBE.FieldModelReferenceType<string>, StructSimple, com.chronoxor.test.FBE.FieldModelStructSimple> f10;

        public FieldModelStructHash(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset)
        {
            f1 = new com.chronoxor.FBE.FieldModelMapReferenceTypeKeyValueTypeValue<string, com.chronoxor.FBE.FieldModelReferenceType<string>, byte, com.chronoxor.FBE.FieldModelValueType<byte>>(com.chronoxor.FBE.FieldModelReferenceType<string>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.STRING, buffer, 4 + 4), com.chronoxor.FBE.FieldModelValueType<byte>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.BYTE, buffer, 4 + 4), buffer, 4 + 4);
            f2 = new com.chronoxor.FBE.FieldModelMapReferenceTypeKeyOptionalValueTypeValue<string, com.chronoxor.FBE.FieldModelReferenceType<string>, byte, com.chronoxor.FBE.FieldModelValueType<byte>>(com.chronoxor.FBE.FieldModelReferenceType<string>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.STRING, buffer, f1.FBEOffset + f1.FBESize), com.chronoxor.FBE.FieldModelValueType<byte>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.BYTE, buffer, f1.FBEOffset + f1.FBESize), buffer, f1.FBEOffset + f1.FBESize);
            f3 = new com.chronoxor.FBE.FieldModelMapReferenceTypeKeyReferenceTypeValue<string, com.chronoxor.FBE.FieldModelReferenceType<string>, MemoryStream, com.chronoxor.FBE.FieldModelReferenceType<MemoryStream>>(com.chronoxor.FBE.FieldModelReferenceType<string>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.STRING, buffer, f2.FBEOffset + f2.FBESize), com.chronoxor.FBE.FieldModelReferenceType<MemoryStream>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.BYTES, buffer, f2.FBEOffset + f2.FBESize), buffer, f2.FBEOffset + f2.FBESize);
            f4 = new com.chronoxor.FBE.FieldModelMapReferenceTypeKeyOptionalReferenceTypeValue<string, com.chronoxor.FBE.FieldModelReferenceType<string>, MemoryStream, com.chronoxor.FBE.FieldModelReferenceType<MemoryStream>>(com.chronoxor.FBE.FieldModelReferenceType<string>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.STRING, buffer, f3.FBEOffset + f3.FBESize), com.chronoxor.FBE.FieldModelReferenceType<MemoryStream>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.BYTES, buffer, f3.FBEOffset + f3.FBESize), buffer, f3.FBEOffset + f3.FBESize);
            f5 = new com.chronoxor.FBE.FieldModelMapReferenceTypeKeyValueTypeValue<string, com.chronoxor.FBE.FieldModelReferenceType<string>, EnumSimple, com.chronoxor.test.FBE.FieldModelEnumSimple>(com.chronoxor.FBE.FieldModelReferenceType<string>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.STRING, buffer, f4.FBEOffset + f4.FBESize), new com.chronoxor.test.FBE.FieldModelEnumSimple(buffer, f4.FBEOffset + f4.FBESize), buffer, f4.FBEOffset + f4.FBESize);
            f6 = new com.chronoxor.FBE.FieldModelMapReferenceTypeKeyOptionalValueTypeValue<string, com.chronoxor.FBE.FieldModelReferenceType<string>, EnumSimple, com.chronoxor.test.FBE.FieldModelEnumSimple>(com.chronoxor.FBE.FieldModelReferenceType<string>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.STRING, buffer, f5.FBEOffset + f5.FBESize), new com.chronoxor.test.FBE.FieldModelEnumSimple(buffer, f5.FBEOffset + f5.FBESize), buffer, f5.FBEOffset + f5.FBESize);
            f7 = new com.chronoxor.FBE.FieldModelMapReferenceTypeKeyValueTypeValue<string, com.chronoxor.FBE.FieldModelReferenceType<string>, FlagsSimple, com.chronoxor.test.FBE.FieldModelFlagsSimple>(com.chronoxor.FBE.FieldModelReferenceType<string>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.STRING, buffer, f6.FBEOffset + f6.FBESize), new com.chronoxor.test.FBE.FieldModelFlagsSimple(buffer, f6.FBEOffset + f6.FBESize), buffer, f6.FBEOffset + f6.FBESize);
            f8 = new com.chronoxor.FBE.FieldModelMapReferenceTypeKeyOptionalValueTypeValue<string, com.chronoxor.FBE.FieldModelReferenceType<string>, FlagsSimple, com.chronoxor.test.FBE.FieldModelFlagsSimple>(com.chronoxor.FBE.FieldModelReferenceType<string>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.STRING, buffer, f7.FBEOffset + f7.FBESize), new com.chronoxor.test.FBE.FieldModelFlagsSimple(buffer, f7.FBEOffset + f7.FBESize), buffer, f7.FBEOffset + f7.FBESize);
            f9 = new com.chronoxor.FBE.FieldModelMapReferenceTypeKeyValueTypeValue<string, com.chronoxor.FBE.FieldModelReferenceType<string>, StructSimple, com.chronoxor.test.FBE.FieldModelStructSimple>(com.chronoxor.FBE.FieldModelReferenceType<string>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.STRING, buffer, f8.FBEOffset + f8.FBESize), new com.chronoxor.test.FBE.FieldModelStructSimple(buffer, f8.FBEOffset + f8.FBESize), buffer, f8.FBEOffset + f8.FBESize);
            f10 = new com.chronoxor.FBE.FieldModelMapReferenceTypeKeyOptionalValueTypeValue<string, com.chronoxor.FBE.FieldModelReferenceType<string>, StructSimple, com.chronoxor.test.FBE.FieldModelStructSimple>(com.chronoxor.FBE.FieldModelReferenceType<string>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.STRING, buffer, f9.FBEOffset + f9.FBESize), new com.chronoxor.test.FBE.FieldModelStructSimple(buffer, f9.FBEOffset + f9.FBESize), buffer, f9.FBEOffset + f9.FBESize);
        }

        // Get the field size
        public override long FBESize => 4;
        // Get the field body size
        public long FBEBody
        {
            get
            {
                long fbeResult = 4 + 4
                    + f1.FBESize
                    + f2.FBESize
                    + f3.FBESize
                    + f4.FBESize
                    + f5.FBESize
                    + f6.FBESize
                    + f7.FBESize
                    + f8.FBESize
                    + f9.FBESize
                    + f10.FBESize
                    ;
                return fbeResult;
            }
        }
        // Get the field extra size
        public override long FBEExtra
        {
            get
            {
                if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                    return 0;

                uint fbeStructOffset = ReadUInt32(FBEOffset);
                if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4) > _buffer.Size))
                    return 0;

                _buffer.Shift(fbeStructOffset);

                long fbeResult = FBEBody
                    + f1.FBEExtra
                    + f2.FBEExtra
                    + f3.FBEExtra
                    + f4.FBEExtra
                    + f5.FBEExtra
                    + f6.FBEExtra
                    + f7.FBEExtra
                    + f8.FBEExtra
                    + f9.FBEExtra
                    + f10.FBEExtra
                    ;

                _buffer.Unshift(fbeStructOffset);

                return fbeResult;
            }
        }
        // Get the field type
        public const long FBETypeConst = 141;
        public long FBEType => FBETypeConst;

        // Clone the field model
        public override com.chronoxor.FBE.FieldModelValueType<StructHash> Clone() { return new FieldModelStructHash(_buffer, _offset); }

        // Check if the struct value is valid
        public override bool Verify() { return Verify(true); }
        public bool Verify(bool fbeVerifyType)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return true;

            uint fbeStructOffset = ReadUInt32(FBEOffset);
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
                return false;

            uint fbeStructSize = ReadUInt32(fbeStructOffset);
            if (fbeStructSize < (4 + 4))
                return false;

            uint fbeStructType = ReadUInt32(fbeStructOffset + 4);
            if (fbeVerifyType && (fbeStructType != FBEType))
                return false;

            _buffer.Shift(fbeStructOffset);
            bool fbeResult = VerifyFields(fbeStructSize);
            _buffer.Unshift(fbeStructOffset);
            return fbeResult;
        }

        // Check if the struct fields are valid
        public bool VerifyFields(long fbeStructSize)
        {
            long fbeCurrentSize = 4 + 4;

            if ((fbeCurrentSize + f1.FBESize) > fbeStructSize)
                return true;
            if (!f1.Verify())
                return false;
            fbeCurrentSize += f1.FBESize;

            if ((fbeCurrentSize + f2.FBESize) > fbeStructSize)
                return true;
            if (!f2.Verify())
                return false;
            fbeCurrentSize += f2.FBESize;

            if ((fbeCurrentSize + f3.FBESize) > fbeStructSize)
                return true;
            if (!f3.Verify())
                return false;
            fbeCurrentSize += f3.FBESize;

            if ((fbeCurrentSize + f4.FBESize) > fbeStructSize)
                return true;
            if (!f4.Verify())
                return false;
            fbeCurrentSize += f4.FBESize;

            if ((fbeCurrentSize + f5.FBESize) > fbeStructSize)
                return true;
            if (!f5.Verify())
                return false;
            fbeCurrentSize += f5.FBESize;

            if ((fbeCurrentSize + f6.FBESize) > fbeStructSize)
                return true;
            if (!f6.Verify())
                return false;
            fbeCurrentSize += f6.FBESize;

            if ((fbeCurrentSize + f7.FBESize) > fbeStructSize)
                return true;
            if (!f7.Verify())
                return false;
            fbeCurrentSize += f7.FBESize;

            if ((fbeCurrentSize + f8.FBESize) > fbeStructSize)
                return true;
            if (!f8.Verify())
                return false;
            fbeCurrentSize += f8.FBESize;

            if ((fbeCurrentSize + f9.FBESize) > fbeStructSize)
                return true;
            if (!f9.Verify())
                return false;
            fbeCurrentSize += f9.FBESize;

            if ((fbeCurrentSize + f10.FBESize) > fbeStructSize)
                return true;
            if (!f10.Verify())
                return false;
            fbeCurrentSize += f10.FBESize;

            return true;
        }

        // Get the struct value (begin phase)
        public long GetBegin()
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            uint fbeStructOffset = ReadUInt32(FBEOffset);
            Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + 4 + 4) <= _buffer.Size)), "Model is broken!");
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
                return 0;

            uint fbeStructSize = ReadUInt32(fbeStructOffset);
            Debug.Assert((fbeStructSize >= (4 + 4)), "Model is broken!");
            if (fbeStructSize < (4 + 4))
                return 0;

            _buffer.Shift(fbeStructOffset);
            return fbeStructOffset;
        }

        // Get the struct value (end phase)
        public void GetEnd(long fbeBegin)
        {
            _buffer.Unshift(fbeBegin);
        }

        // Get the struct value
        public override void Get(out StructHash fbeValue) { Get(out fbeValue, StructHash.Default); }
        public override void Get(out StructHash fbeValue, StructHash defaults)
        {
            long fbeBegin = GetBegin();
            if (fbeBegin == 0)
            {
                fbeValue = defaults;
                return;
            }

            uint fbeStructSize = ReadUInt32(0);
            GetFields(out fbeValue, fbeStructSize);
            GetEnd(fbeBegin);
        }

        // Get the struct fields values
        public void GetFields(out StructHash fbeValue, long fbeStructSize)
        {
            long fbeCurrentSize = 4 + 4;

            fbeValue = StructHash.Default;

            if ((fbeCurrentSize + f1.FBESize) <= fbeStructSize)
                f1.Get(ref fbeValue.f1);
            else
                fbeValue.f1.Clear();
            fbeCurrentSize += f1.FBESize;

            if ((fbeCurrentSize + f2.FBESize) <= fbeStructSize)
                f2.Get(ref fbeValue.f2);
            else
                fbeValue.f2.Clear();
            fbeCurrentSize += f2.FBESize;

            if ((fbeCurrentSize + f3.FBESize) <= fbeStructSize)
                f3.Get(ref fbeValue.f3);
            else
                fbeValue.f3.Clear();
            fbeCurrentSize += f3.FBESize;

            if ((fbeCurrentSize + f4.FBESize) <= fbeStructSize)
                f4.Get(ref fbeValue.f4);
            else
                fbeValue.f4.Clear();
            fbeCurrentSize += f4.FBESize;

            if ((fbeCurrentSize + f5.FBESize) <= fbeStructSize)
                f5.Get(ref fbeValue.f5);
            else
                fbeValue.f5.Clear();
            fbeCurrentSize += f5.FBESize;

            if ((fbeCurrentSize + f6.FBESize) <= fbeStructSize)
                f6.Get(ref fbeValue.f6);
            else
                fbeValue.f6.Clear();
            fbeCurrentSize += f6.FBESize;

            if ((fbeCurrentSize + f7.FBESize) <= fbeStructSize)
                f7.Get(ref fbeValue.f7);
            else
                fbeValue.f7.Clear();
            fbeCurrentSize += f7.FBESize;

            if ((fbeCurrentSize + f8.FBESize) <= fbeStructSize)
                f8.Get(ref fbeValue.f8);
            else
                fbeValue.f8.Clear();
            fbeCurrentSize += f8.FBESize;

            if ((fbeCurrentSize + f9.FBESize) <= fbeStructSize)
                f9.Get(ref fbeValue.f9);
            else
                fbeValue.f9.Clear();
            fbeCurrentSize += f9.FBESize;

            if ((fbeCurrentSize + f10.FBESize) <= fbeStructSize)
                f10.Get(ref fbeValue.f10);
            else
                fbeValue.f10.Clear();
            fbeCurrentSize += f10.FBESize;
        }

        // Set the struct value (begin phase)
        public long SetBegin()
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            uint fbeStructSize = (uint)FBEBody;
            uint fbeStructOffset = (uint)(_buffer.Allocate(fbeStructSize) - _buffer.Offset);
            Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + fbeStructSize) <= _buffer.Size)), "Model is broken!");
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + fbeStructSize) > _buffer.Size))
                return 0;

            Write(FBEOffset, fbeStructOffset);
            Write(fbeStructOffset, fbeStructSize);
            Write(fbeStructOffset + 4, (uint)FBEType);

            _buffer.Shift(fbeStructOffset);
            return fbeStructOffset;
        }

        // Set the struct value (end phase)
        public void SetEnd(long fbeBegin)
        {
            _buffer.Unshift(fbeBegin);
        }

        // Set the struct value
        public override void Set(StructHash fbeValue)
        {
            long fbeBegin = SetBegin();
            if (fbeBegin == 0)
                return;

            SetFields(fbeValue);
            SetEnd(fbeBegin);
        }

        // Set the struct fields values
        public void SetFields(StructHash fbeValue)
        {
            f1.Set(fbeValue.f1);
            f2.Set(fbeValue.f2);
            f3.Set(fbeValue.f3);
            f4.Set(fbeValue.f4);
            f5.Set(fbeValue.f5);
            f6.Set(fbeValue.f6);
            f7.Set(fbeValue.f7);
            f8.Set(fbeValue.f8);
            f9.Set(fbeValue.f9);
            f10.Set(fbeValue.f10);
        }
    }

} // namespace com.chronoxor.test.FBE

namespace com.chronoxor.test.FBE {

    using global::com.chronoxor.test;

    // Fast Binary Encoding StructHash model
    public class StructHashModel : com.chronoxor.FBE.Model
    {
        public readonly FieldModelStructHash model;

        public StructHashModel() { model = new FieldModelStructHash(Buffer, 4); }
        public StructHashModel(com.chronoxor.FBE.Buffer buffer) : base(buffer) { model = new FieldModelStructHash(Buffer, 4); }

        // Get the model size
        public long FBESize => model.FBESize + model.FBEExtra;
        // Get the model type
        public const long FBETypeConst = FieldModelStructHash.FBETypeConst;
        public long FBEType => FBETypeConst;

        // Check if the struct value is valid
        public bool Verify()
        {
            if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
                return false;

            uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
            if (fbeFullSize < model.FBESize)
                return false;

            return model.Verify();
        }

        // Create a new model (begin phase)
        public long CreateBegin()
        {
            long fbeBegin = Buffer.Allocate(4 + model.FBESize);
            return fbeBegin;
        }

        // Create a new model (end phase)
        public long CreateEnd(long fbeBegin)
        {
            long fbeEnd = Buffer.Size;
            uint fbeFullSize = (uint)(fbeEnd - fbeBegin);
            Write(model.FBEOffset - 4, fbeFullSize);
            return fbeFullSize;
        }

        // Serialize the struct value
        public long Serialize(StructHash value)
        {
            long fbeBegin = CreateBegin();
            model.Set(value);
            long fbeFullSize = CreateEnd(fbeBegin);
            return fbeFullSize;
        }

        // Deserialize the struct value
        public long Deserialize(out StructHash value)
        {
            if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
            {
                value = StructHash.Default;
                return 0;
            }

            uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
            Debug.Assert((fbeFullSize >= model.FBESize), "Model is broken!");
            if (fbeFullSize < model.FBESize)
            {
                value = StructHash.Default;
                return 0;
            }

            model.Get(out value);
            return fbeFullSize;
        }

        // Move to the next struct value
        public void Next(long prev)
        {
            model.FBEShift(prev);
        }
    }

} // namespace com.chronoxor.test.FBE

namespace com.chronoxor.test.FBE {

    using global::com.chronoxor.test;

    // Fast Binary Encoding StructHash final model
    public class FinalModelStructHash : com.chronoxor.FBE.FinalModelValueType<StructHash>
    {
        public readonly com.chronoxor.FBE.FinalModelMapReferenceTypeKeyValueTypeValue<string, com.chronoxor.FBE.FinalModelReferenceType<string>, byte, com.chronoxor.FBE.FinalModelValueType<byte>> f1;
        public readonly com.chronoxor.FBE.FinalModelMapReferenceTypeKeyOptionalValueTypeValue<string, com.chronoxor.FBE.FinalModelReferenceType<string>, byte, com.chronoxor.FBE.FinalModelValueType<byte>> f2;
        public readonly com.chronoxor.FBE.FinalModelMapReferenceTypeKeyReferenceTypeValue<string, com.chronoxor.FBE.FinalModelReferenceType<string>, MemoryStream, com.chronoxor.FBE.FinalModelReferenceType<MemoryStream>> f3;
        public readonly com.chronoxor.FBE.FinalModelMapReferenceTypeKeyOptionalReferenceTypeValue<string, com.chronoxor.FBE.FinalModelReferenceType<string>, MemoryStream, com.chronoxor.FBE.FinalModelReferenceType<MemoryStream>> f4;
        public readonly com.chronoxor.FBE.FinalModelMapReferenceTypeKeyValueTypeValue<string, com.chronoxor.FBE.FinalModelReferenceType<string>, EnumSimple, com.chronoxor.test.FBE.FinalModelEnumSimple> f5;
        public readonly com.chronoxor.FBE.FinalModelMapReferenceTypeKeyOptionalValueTypeValue<string, com.chronoxor.FBE.FinalModelReferenceType<string>, EnumSimple, com.chronoxor.test.FBE.FinalModelEnumSimple> f6;
        public readonly com.chronoxor.FBE.FinalModelMapReferenceTypeKeyValueTypeValue<string, com.chronoxor.FBE.FinalModelReferenceType<string>, FlagsSimple, com.chronoxor.test.FBE.FinalModelFlagsSimple> f7;
        public readonly com.chronoxor.FBE.FinalModelMapReferenceTypeKeyOptionalValueTypeValue<string, com.chronoxor.FBE.FinalModelReferenceType<string>, FlagsSimple, com.chronoxor.test.FBE.FinalModelFlagsSimple> f8;
        public readonly com.chronoxor.FBE.FinalModelMapReferenceTypeKeyValueTypeValue<string, com.chronoxor.FBE.FinalModelReferenceType<string>, StructSimple, com.chronoxor.test.FBE.FinalModelStructSimple> f9;
        public readonly com.chronoxor.FBE.FinalModelMapReferenceTypeKeyOptionalValueTypeValue<string, com.chronoxor.FBE.FinalModelReferenceType<string>, StructSimple, com.chronoxor.test.FBE.FinalModelStructSimple> f10;

        public FinalModelStructHash(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset)
        {
            f1 = new com.chronoxor.FBE.FinalModelMapReferenceTypeKeyValueTypeValue<string, com.chronoxor.FBE.FinalModelReferenceType<string>, byte, com.chronoxor.FBE.FinalModelValueType<byte>>(com.chronoxor.FBE.FinalModelReferenceType<string>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.STRING, buffer, 0), com.chronoxor.FBE.FinalModelValueType<byte>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.BYTE, buffer, 0), buffer, 0);
            f2 = new com.chronoxor.FBE.FinalModelMapReferenceTypeKeyOptionalValueTypeValue<string, com.chronoxor.FBE.FinalModelReferenceType<string>, byte, com.chronoxor.FBE.FinalModelValueType<byte>>(com.chronoxor.FBE.FinalModelReferenceType<string>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.STRING, buffer, 0), com.chronoxor.FBE.FinalModelValueType<byte>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.BYTE, buffer, 0), buffer, 0);
            f3 = new com.chronoxor.FBE.FinalModelMapReferenceTypeKeyReferenceTypeValue<string, com.chronoxor.FBE.FinalModelReferenceType<string>, MemoryStream, com.chronoxor.FBE.FinalModelReferenceType<MemoryStream>>(com.chronoxor.FBE.FinalModelReferenceType<string>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.STRING, buffer, 0), com.chronoxor.FBE.FinalModelReferenceType<MemoryStream>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.BYTES, buffer, 0), buffer, 0);
            f4 = new com.chronoxor.FBE.FinalModelMapReferenceTypeKeyOptionalReferenceTypeValue<string, com.chronoxor.FBE.FinalModelReferenceType<string>, MemoryStream, com.chronoxor.FBE.FinalModelReferenceType<MemoryStream>>(com.chronoxor.FBE.FinalModelReferenceType<string>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.STRING, buffer, 0), com.chronoxor.FBE.FinalModelReferenceType<MemoryStream>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.BYTES, buffer, 0), buffer, 0);
            f5 = new com.chronoxor.FBE.FinalModelMapReferenceTypeKeyValueTypeValue<string, com.chronoxor.FBE.FinalModelReferenceType<string>, EnumSimple, com.chronoxor.test.FBE.FinalModelEnumSimple>(com.chronoxor.FBE.FinalModelReferenceType<string>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.STRING, buffer, 0), new com.chronoxor.test.FBE.FinalModelEnumSimple(buffer, 0), buffer, 0);
            f6 = new com.chronoxor.FBE.FinalModelMapReferenceTypeKeyOptionalValueTypeValue<string, com.chronoxor.FBE.FinalModelReferenceType<string>, EnumSimple, com.chronoxor.test.FBE.FinalModelEnumSimple>(com.chronoxor.FBE.FinalModelReferenceType<string>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.STRING, buffer, 0), new com.chronoxor.test.FBE.FinalModelEnumSimple(buffer, 0), buffer, 0);
            f7 = new com.chronoxor.FBE.FinalModelMapReferenceTypeKeyValueTypeValue<string, com.chronoxor.FBE.FinalModelReferenceType<string>, FlagsSimple, com.chronoxor.test.FBE.FinalModelFlagsSimple>(com.chronoxor.FBE.FinalModelReferenceType<string>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.STRING, buffer, 0), new com.chronoxor.test.FBE.FinalModelFlagsSimple(buffer, 0), buffer, 0);
            f8 = new com.chronoxor.FBE.FinalModelMapReferenceTypeKeyOptionalValueTypeValue<string, com.chronoxor.FBE.FinalModelReferenceType<string>, FlagsSimple, com.chronoxor.test.FBE.FinalModelFlagsSimple>(com.chronoxor.FBE.FinalModelReferenceType<string>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.STRING, buffer, 0), new com.chronoxor.test.FBE.FinalModelFlagsSimple(buffer, 0), buffer, 0);
            f9 = new com.chronoxor.FBE.FinalModelMapReferenceTypeKeyValueTypeValue<string, com.chronoxor.FBE.FinalModelReferenceType<string>, StructSimple, com.chronoxor.test.FBE.FinalModelStructSimple>(com.chronoxor.FBE.FinalModelReferenceType<string>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.STRING, buffer, 0), new com.chronoxor.test.FBE.FinalModelStructSimple(buffer, 0), buffer, 0);
            f10 = new com.chronoxor.FBE.FinalModelMapReferenceTypeKeyOptionalValueTypeValue<string, com.chronoxor.FBE.FinalModelReferenceType<string>, StructSimple, com.chronoxor.test.FBE.FinalModelStructSimple>(com.chronoxor.FBE.FinalModelReferenceType<string>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.STRING, buffer, 0), new com.chronoxor.test.FBE.FinalModelStructSimple(buffer, 0), buffer, 0);
        }

        // Get the allocation size
        public override long FBEAllocationSize(StructHash fbeValue)
        {
            long fbeResult = 0
                + f1.FBEAllocationSize(fbeValue.f1)
                + f2.FBEAllocationSize(fbeValue.f2)
                + f3.FBEAllocationSize(fbeValue.f3)
                + f4.FBEAllocationSize(fbeValue.f4)
                + f5.FBEAllocationSize(fbeValue.f5)
                + f6.FBEAllocationSize(fbeValue.f6)
                + f7.FBEAllocationSize(fbeValue.f7)
                + f8.FBEAllocationSize(fbeValue.f8)
                + f9.FBEAllocationSize(fbeValue.f9)
                + f10.FBEAllocationSize(fbeValue.f10)
                ;
            return fbeResult;
        }

        // Get the final type
        public const long FBETypeConst = 141;
        public long FBEType => FBETypeConst;

        // Clone the final model
        public override com.chronoxor.FBE.FinalModelValueType<StructHash> Clone() { return new FinalModelStructHash(_buffer, _offset); }

        // Check if the struct value is valid
        public override long Verify()
        {
            _buffer.Shift(FBEOffset);
            long fbeResult = VerifyFields();
            _buffer.Unshift(FBEOffset);
            return fbeResult;
        }

        // Check if the struct fields are valid
        public long VerifyFields()
        {
            long fbeCurrentOffset = 0;
            long fbeFieldSize;

            f1.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f1.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f2.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f2.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f3.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f3.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f4.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f4.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f5.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f5.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f6.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f6.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f7.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f7.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f8.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f8.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f9.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f9.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f10.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f10.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            return fbeCurrentOffset;
        }

        // Get the struct value
        public override long Get(out StructHash fbeValue)
        {
            _buffer.Shift(FBEOffset);
            long fbeSize = GetFields(out fbeValue);
            _buffer.Unshift(FBEOffset);
            return fbeSize;
        }

        // Get the struct fields values
        public long GetFields(out StructHash fbeValue)
        {
            long fbeCurrentOffset = 0;
            long fbeCurrentSize = 0;
            long fbeFieldSize;

            fbeValue = StructHash.Default;

            f1.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f1.Get(out fbeValue.f1);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f2.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f2.Get(out fbeValue.f2);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f3.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f3.Get(out fbeValue.f3);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f4.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f4.Get(out fbeValue.f4);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f5.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f5.Get(out fbeValue.f5);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f6.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f6.Get(out fbeValue.f6);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f7.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f7.Get(out fbeValue.f7);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f8.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f8.Get(out fbeValue.f8);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f9.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f9.Get(out fbeValue.f9);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f10.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f10.Get(out fbeValue.f10);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            return fbeCurrentSize;
        }

        // Set the struct value
        public override long Set(StructHash fbeValue)
        {
            _buffer.Shift(FBEOffset);
            long fbeResult = SetFields(fbeValue);
            _buffer.Unshift(FBEOffset);
            return fbeResult;
        }

        // Set the struct fields values
        public long SetFields(StructHash fbeValue)
        {
            long fbeCurrentOffset = 0;
            long fbeCurrentSize = 0;
            long fbeFieldSize;

            f1.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f1.Set(fbeValue.f1);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f2.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f2.Set(fbeValue.f2);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f3.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f3.Set(fbeValue.f3);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f4.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f4.Set(fbeValue.f4);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f5.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f5.Set(fbeValue.f5);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f6.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f6.Set(fbeValue.f6);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f7.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f7.Set(fbeValue.f7);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f8.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f8.Set(fbeValue.f8);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f9.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f9.Set(fbeValue.f9);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f10.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f10.Set(fbeValue.f10);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            return fbeCurrentSize;
        }
    }

} // namespace com.chronoxor.test.FBE

namespace com.chronoxor.test.FBE {

    using global::com.chronoxor.test;

    // Fast Binary Encoding StructHash final model
    public class StructHashFinalModel : com.chronoxor.FBE.Model
    {
        private readonly FinalModelStructHash _model;

        public StructHashFinalModel() { _model = new FinalModelStructHash(Buffer, 8); }
        public StructHashFinalModel(com.chronoxor.FBE.Buffer buffer) : base(buffer) { _model = new FinalModelStructHash(Buffer, 8); }

        // Get the model type
        public const long FBETypeConst = FinalModelStructHash.FBETypeConst;
        public long FBEType => FBETypeConst;

        // Check if the struct value is valid
        public bool Verify()
        {
            if ((Buffer.Offset + _model.FBEOffset) > Buffer.Size)
                return false;

            long fbeStructSize = ReadUInt32(_model.FBEOffset - 8);
            long fbeStructType = ReadUInt32(_model.FBEOffset - 4);
            if ((fbeStructSize <= 0) || (fbeStructType != FBEType))
                return false;

            return ((8 + _model.Verify()) == fbeStructSize);
        }

        // Serialize the struct value
        public long Serialize(StructHash value)
        {
            long fbeInitialSize = Buffer.Size;

            uint fbeStructType = (uint)FBEType;
            uint fbeStructSize = (uint)(8 + _model.FBEAllocationSize(value));
            uint fbeStructOffset = (uint)(Buffer.Allocate(fbeStructSize) - Buffer.Offset);
            Debug.Assert(((Buffer.Offset + fbeStructOffset + fbeStructSize) <= Buffer.Size), "Model is broken!");
            if ((Buffer.Offset + fbeStructOffset + fbeStructSize) > Buffer.Size)
                return 0;

            fbeStructSize = (uint)(8 + _model.Set(value));
            Buffer.Resize(fbeInitialSize + fbeStructSize);

            Write(_model.FBEOffset - 8, fbeStructSize);
            Write(_model.FBEOffset - 4, fbeStructType);

            return fbeStructSize;
        }

        // Deserialize the struct value
        public long Deserialize(out StructHash value)
        {
            Debug.Assert(((Buffer.Offset + _model.FBEOffset) <= Buffer.Size), "Model is broken!");
            if ((Buffer.Offset + _model.FBEOffset) > Buffer.Size)
            {
                value = StructHash.Default;
                return 0;
            }

            long fbeStructSize = ReadUInt32(_model.FBEOffset - 8);
            long fbeStructType = ReadUInt32(_model.FBEOffset - 4);
            Debug.Assert(((fbeStructSize > 0) && (fbeStructType == FBEType)), "Model is broken!");
            if ((fbeStructSize <= 0) || (fbeStructType != FBEType))
            {
                value = StructHash.Default;
                return 8;
            }

            return 8 + _model.Get(out value);
        }

        // Move to the next struct value
        public void Next(long prev)
        {
            _model.FBEShift(prev);
        }
    }

} // namespace com.chronoxor.test.FBE

namespace com.chronoxor.test {

    public struct StructHashEx : IComparable, IComparable<StructHashEx>, IEquatable<StructHashEx>
    {
        public Dictionary<StructSimple, StructNested> f1;
        public Dictionary<StructSimple, StructNested?> f2;

        public const long FBETypeConst = 142;
        #if UTF8JSON
        [IgnoreDataMember]
        #else
        [JsonIgnore]
        #endif
        public long FBEType => FBETypeConst;

        public static StructHashEx Default => new StructHashEx
        {
            f1 = new Dictionary<StructSimple, StructNested>()
            , f2 = new Dictionary<StructSimple, StructNested?>()
        };

        public StructHashEx(Dictionary<StructSimple, StructNested> f1, Dictionary<StructSimple, StructNested?> f2)
        {
            this.f1 = f1;
            this.f2 = f2;
        }

        public StructHashEx Clone()
        {
            // Serialize the struct to the FBE stream
            var writer = new com.chronoxor.test.FBE.StructHashExModel();
            writer.Serialize(this);

            // Deserialize the struct from the FBE stream
            var reader = new com.chronoxor.test.FBE.StructHashExModel();
            reader.Attach(writer.Buffer);
            reader.Deserialize(out var result);
            return result;
        }

        public int CompareTo(object other)
        {
            int result = 0;
            return result;
        }

        public int CompareTo(StructHashEx other)
        {
            int result = 0;
            return result;
        }

        public override bool Equals(object other)
        {
            if (!(other is StructHashEx))
                return false;
            return true;
        }

        public bool Equals(StructHashEx other)
        {
            return true;
        }

        public override int GetHashCode()
        {
            int hash = 17;
            return hash;
        }

        public static bool operator==(StructHashEx lhs, StructHashEx rhs) => lhs.Equals(rhs);
        public static bool operator!=(StructHashEx lhs, StructHashEx rhs) => !(lhs == rhs);

        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("StructHashEx(");
            if (f1 != null)
            {
                bool first = true;
                sb.Append("f1=[").Append(f1.Count).Append("][{");
                foreach (var item in f1)
                {
                    sb.Append(first ? "" : ",").Append(item.Key);
                    sb.Append("->");
                    sb.Append(item.Value);
                    first = false;
                }
                sb.Append("}]");
            }
            else
            {
                sb.Append("f1=[0][{}]");
            }
            if (f2 != null)
            {
                bool first = true;
                sb.Append(",f2=[").Append(f2.Count).Append("][{");
                foreach (var item in f2)
                {
                    sb.Append(first ? "" : ",").Append(item.Key);
                    sb.Append("->");
                    if (item.Value != null) sb.Append(item.Value); else sb.Append("null");
                    first = false;
                }
                sb.Append("}]");
            }
            else
            {
                sb.Append(",f2=[0][{}]");
            }
            sb.Append(")");
            return sb.ToString();
        }

        public string ToJson()
        {
            var json = com.chronoxor.FBE.Json.ToJson(this);
            return json;
        }

        public static StructHashEx FromJson(string json)
        {
            var result = com.chronoxor.FBE.Json.FromJson<StructHashEx>(json);
            return result;
        }

        public static com.chronoxor.FBE.FieldModelValueType<StructHashEx> CreateFieldModel(com.chronoxor.FBE.Buffer buffer, long offset) { return new test.FBE.FieldModelStructHashEx(buffer, offset); }
    }

} // namespace com.chronoxor.test

namespace com.chronoxor.test.FBE {

    using global::com.chronoxor.test;

    // Fast Binary Encoding StructHashEx field model
    public class FieldModelStructHashEx : com.chronoxor.FBE.FieldModelValueType<StructHashEx>
    {
        public readonly com.chronoxor.FBE.FieldModelMapValueTypeKeyValueTypeValue<StructSimple, com.chronoxor.test.FBE.FieldModelStructSimple, StructNested, com.chronoxor.test.FBE.FieldModelStructNested> f1;
        public readonly com.chronoxor.FBE.FieldModelMapValueTypeKeyOptionalValueTypeValue<StructSimple, com.chronoxor.test.FBE.FieldModelStructSimple, StructNested, com.chronoxor.test.FBE.FieldModelStructNested> f2;

        public FieldModelStructHashEx(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset)
        {
            f1 = new com.chronoxor.FBE.FieldModelMapValueTypeKeyValueTypeValue<StructSimple, com.chronoxor.test.FBE.FieldModelStructSimple, StructNested, com.chronoxor.test.FBE.FieldModelStructNested>(new com.chronoxor.test.FBE.FieldModelStructSimple(buffer, 4 + 4), new com.chronoxor.test.FBE.FieldModelStructNested(buffer, 4 + 4), buffer, 4 + 4);
            f2 = new com.chronoxor.FBE.FieldModelMapValueTypeKeyOptionalValueTypeValue<StructSimple, com.chronoxor.test.FBE.FieldModelStructSimple, StructNested, com.chronoxor.test.FBE.FieldModelStructNested>(new com.chronoxor.test.FBE.FieldModelStructSimple(buffer, f1.FBEOffset + f1.FBESize), new com.chronoxor.test.FBE.FieldModelStructNested(buffer, f1.FBEOffset + f1.FBESize), buffer, f1.FBEOffset + f1.FBESize);
        }

        // Get the field size
        public override long FBESize => 4;
        // Get the field body size
        public long FBEBody
        {
            get
            {
                long fbeResult = 4 + 4
                    + f1.FBESize
                    + f2.FBESize
                    ;
                return fbeResult;
            }
        }
        // Get the field extra size
        public override long FBEExtra
        {
            get
            {
                if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                    return 0;

                uint fbeStructOffset = ReadUInt32(FBEOffset);
                if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4) > _buffer.Size))
                    return 0;

                _buffer.Shift(fbeStructOffset);

                long fbeResult = FBEBody
                    + f1.FBEExtra
                    + f2.FBEExtra
                    ;

                _buffer.Unshift(fbeStructOffset);

                return fbeResult;
            }
        }
        // Get the field type
        public const long FBETypeConst = 142;
        public long FBEType => FBETypeConst;

        // Clone the field model
        public override com.chronoxor.FBE.FieldModelValueType<StructHashEx> Clone() { return new FieldModelStructHashEx(_buffer, _offset); }

        // Check if the struct value is valid
        public override bool Verify() { return Verify(true); }
        public bool Verify(bool fbeVerifyType)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return true;

            uint fbeStructOffset = ReadUInt32(FBEOffset);
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
                return false;

            uint fbeStructSize = ReadUInt32(fbeStructOffset);
            if (fbeStructSize < (4 + 4))
                return false;

            uint fbeStructType = ReadUInt32(fbeStructOffset + 4);
            if (fbeVerifyType && (fbeStructType != FBEType))
                return false;

            _buffer.Shift(fbeStructOffset);
            bool fbeResult = VerifyFields(fbeStructSize);
            _buffer.Unshift(fbeStructOffset);
            return fbeResult;
        }

        // Check if the struct fields are valid
        public bool VerifyFields(long fbeStructSize)
        {
            long fbeCurrentSize = 4 + 4;

            if ((fbeCurrentSize + f1.FBESize) > fbeStructSize)
                return true;
            if (!f1.Verify())
                return false;
            fbeCurrentSize += f1.FBESize;

            if ((fbeCurrentSize + f2.FBESize) > fbeStructSize)
                return true;
            if (!f2.Verify())
                return false;
            fbeCurrentSize += f2.FBESize;

            return true;
        }

        // Get the struct value (begin phase)
        public long GetBegin()
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            uint fbeStructOffset = ReadUInt32(FBEOffset);
            Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + 4 + 4) <= _buffer.Size)), "Model is broken!");
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
                return 0;

            uint fbeStructSize = ReadUInt32(fbeStructOffset);
            Debug.Assert((fbeStructSize >= (4 + 4)), "Model is broken!");
            if (fbeStructSize < (4 + 4))
                return 0;

            _buffer.Shift(fbeStructOffset);
            return fbeStructOffset;
        }

        // Get the struct value (end phase)
        public void GetEnd(long fbeBegin)
        {
            _buffer.Unshift(fbeBegin);
        }

        // Get the struct value
        public override void Get(out StructHashEx fbeValue) { Get(out fbeValue, StructHashEx.Default); }
        public override void Get(out StructHashEx fbeValue, StructHashEx defaults)
        {
            long fbeBegin = GetBegin();
            if (fbeBegin == 0)
            {
                fbeValue = defaults;
                return;
            }

            uint fbeStructSize = ReadUInt32(0);
            GetFields(out fbeValue, fbeStructSize);
            GetEnd(fbeBegin);
        }

        // Get the struct fields values
        public void GetFields(out StructHashEx fbeValue, long fbeStructSize)
        {
            long fbeCurrentSize = 4 + 4;

            fbeValue = StructHashEx.Default;

            if ((fbeCurrentSize + f1.FBESize) <= fbeStructSize)
                f1.Get(ref fbeValue.f1);
            else
                fbeValue.f1.Clear();
            fbeCurrentSize += f1.FBESize;

            if ((fbeCurrentSize + f2.FBESize) <= fbeStructSize)
                f2.Get(ref fbeValue.f2);
            else
                fbeValue.f2.Clear();
            fbeCurrentSize += f2.FBESize;
        }

        // Set the struct value (begin phase)
        public long SetBegin()
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            uint fbeStructSize = (uint)FBEBody;
            uint fbeStructOffset = (uint)(_buffer.Allocate(fbeStructSize) - _buffer.Offset);
            Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + fbeStructSize) <= _buffer.Size)), "Model is broken!");
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + fbeStructSize) > _buffer.Size))
                return 0;

            Write(FBEOffset, fbeStructOffset);
            Write(fbeStructOffset, fbeStructSize);
            Write(fbeStructOffset + 4, (uint)FBEType);

            _buffer.Shift(fbeStructOffset);
            return fbeStructOffset;
        }

        // Set the struct value (end phase)
        public void SetEnd(long fbeBegin)
        {
            _buffer.Unshift(fbeBegin);
        }

        // Set the struct value
        public override void Set(StructHashEx fbeValue)
        {
            long fbeBegin = SetBegin();
            if (fbeBegin == 0)
                return;

            SetFields(fbeValue);
            SetEnd(fbeBegin);
        }

        // Set the struct fields values
        public void SetFields(StructHashEx fbeValue)
        {
            f1.Set(fbeValue.f1);
            f2.Set(fbeValue.f2);
        }
    }

} // namespace com.chronoxor.test.FBE

namespace com.chronoxor.test.FBE {

    using global::com.chronoxor.test;

    // Fast Binary Encoding StructHashEx model
    public class StructHashExModel : com.chronoxor.FBE.Model
    {
        public readonly FieldModelStructHashEx model;

        public StructHashExModel() { model = new FieldModelStructHashEx(Buffer, 4); }
        public StructHashExModel(com.chronoxor.FBE.Buffer buffer) : base(buffer) { model = new FieldModelStructHashEx(Buffer, 4); }

        // Get the model size
        public long FBESize => model.FBESize + model.FBEExtra;
        // Get the model type
        public const long FBETypeConst = FieldModelStructHashEx.FBETypeConst;
        public long FBEType => FBETypeConst;

        // Check if the struct value is valid
        public bool Verify()
        {
            if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
                return false;

            uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
            if (fbeFullSize < model.FBESize)
                return false;

            return model.Verify();
        }

        // Create a new model (begin phase)
        public long CreateBegin()
        {
            long fbeBegin = Buffer.Allocate(4 + model.FBESize);
            return fbeBegin;
        }

        // Create a new model (end phase)
        public long CreateEnd(long fbeBegin)
        {
            long fbeEnd = Buffer.Size;
            uint fbeFullSize = (uint)(fbeEnd - fbeBegin);
            Write(model.FBEOffset - 4, fbeFullSize);
            return fbeFullSize;
        }

        // Serialize the struct value
        public long Serialize(StructHashEx value)
        {
            long fbeBegin = CreateBegin();
            model.Set(value);
            long fbeFullSize = CreateEnd(fbeBegin);
            return fbeFullSize;
        }

        // Deserialize the struct value
        public long Deserialize(out StructHashEx value)
        {
            if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
            {
                value = StructHashEx.Default;
                return 0;
            }

            uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
            Debug.Assert((fbeFullSize >= model.FBESize), "Model is broken!");
            if (fbeFullSize < model.FBESize)
            {
                value = StructHashEx.Default;
                return 0;
            }

            model.Get(out value);
            return fbeFullSize;
        }

        // Move to the next struct value
        public void Next(long prev)
        {
            model.FBEShift(prev);
        }
    }

} // namespace com.chronoxor.test.FBE

namespace com.chronoxor.test.FBE {

    using global::com.chronoxor.test;

    // Fast Binary Encoding StructHashEx final model
    public class FinalModelStructHashEx : com.chronoxor.FBE.FinalModelValueType<StructHashEx>
    {
        public readonly com.chronoxor.FBE.FinalModelMapValueTypeKeyValueTypeValue<StructSimple, com.chronoxor.test.FBE.FinalModelStructSimple, StructNested, com.chronoxor.test.FBE.FinalModelStructNested> f1;
        public readonly com.chronoxor.FBE.FinalModelMapValueTypeKeyOptionalValueTypeValue<StructSimple, com.chronoxor.test.FBE.FinalModelStructSimple, StructNested, com.chronoxor.test.FBE.FinalModelStructNested> f2;

        public FinalModelStructHashEx(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset)
        {
            f1 = new com.chronoxor.FBE.FinalModelMapValueTypeKeyValueTypeValue<StructSimple, com.chronoxor.test.FBE.FinalModelStructSimple, StructNested, com.chronoxor.test.FBE.FinalModelStructNested>(new com.chronoxor.test.FBE.FinalModelStructSimple(buffer, 0), new com.chronoxor.test.FBE.FinalModelStructNested(buffer, 0), buffer, 0);
            f2 = new com.chronoxor.FBE.FinalModelMapValueTypeKeyOptionalValueTypeValue<StructSimple, com.chronoxor.test.FBE.FinalModelStructSimple, StructNested, com.chronoxor.test.FBE.FinalModelStructNested>(new com.chronoxor.test.FBE.FinalModelStructSimple(buffer, 0), new com.chronoxor.test.FBE.FinalModelStructNested(buffer, 0), buffer, 0);
        }

        // Get the allocation size
        public override long FBEAllocationSize(StructHashEx fbeValue)
        {
            long fbeResult = 0
                + f1.FBEAllocationSize(fbeValue.f1)
                + f2.FBEAllocationSize(fbeValue.f2)
                ;
            return fbeResult;
        }

        // Get the final type
        public const long FBETypeConst = 142;
        public long FBEType => FBETypeConst;

        // Clone the final model
        public override com.chronoxor.FBE.FinalModelValueType<StructHashEx> Clone() { return new FinalModelStructHashEx(_buffer, _offset); }

        // Check if the struct value is valid
        public override long Verify()
        {
            _buffer.Shift(FBEOffset);
            long fbeResult = VerifyFields();
            _buffer.Unshift(FBEOffset);
            return fbeResult;
        }

        // Check if the struct fields are valid
        public long VerifyFields()
        {
            long fbeCurrentOffset = 0;
            long fbeFieldSize;

            f1.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f1.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            f2.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f2.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            return fbeCurrentOffset;
        }

        // Get the struct value
        public override long Get(out StructHashEx fbeValue)
        {
            _buffer.Shift(FBEOffset);
            long fbeSize = GetFields(out fbeValue);
            _buffer.Unshift(FBEOffset);
            return fbeSize;
        }

        // Get the struct fields values
        public long GetFields(out StructHashEx fbeValue)
        {
            long fbeCurrentOffset = 0;
            long fbeCurrentSize = 0;
            long fbeFieldSize;

            fbeValue = StructHashEx.Default;

            f1.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f1.Get(out fbeValue.f1);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f2.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f2.Get(out fbeValue.f2);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            return fbeCurrentSize;
        }

        // Set the struct value
        public override long Set(StructHashEx fbeValue)
        {
            _buffer.Shift(FBEOffset);
            long fbeResult = SetFields(fbeValue);
            _buffer.Unshift(FBEOffset);
            return fbeResult;
        }

        // Set the struct fields values
        public long SetFields(StructHashEx fbeValue)
        {
            long fbeCurrentOffset = 0;
            long fbeCurrentSize = 0;
            long fbeFieldSize;

            f1.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f1.Set(fbeValue.f1);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            f2.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = f2.Set(fbeValue.f2);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            return fbeCurrentSize;
        }
    }

} // namespace com.chronoxor.test.FBE

namespace com.chronoxor.test.FBE {

    using global::com.chronoxor.test;

    // Fast Binary Encoding StructHashEx final model
    public class StructHashExFinalModel : com.chronoxor.FBE.Model
    {
        private readonly FinalModelStructHashEx _model;

        public StructHashExFinalModel() { _model = new FinalModelStructHashEx(Buffer, 8); }
        public StructHashExFinalModel(com.chronoxor.FBE.Buffer buffer) : base(buffer) { _model = new FinalModelStructHashEx(Buffer, 8); }

        // Get the model type
        public const long FBETypeConst = FinalModelStructHashEx.FBETypeConst;
        public long FBEType => FBETypeConst;

        // Check if the struct value is valid
        public bool Verify()
        {
            if ((Buffer.Offset + _model.FBEOffset) > Buffer.Size)
                return false;

            long fbeStructSize = ReadUInt32(_model.FBEOffset - 8);
            long fbeStructType = ReadUInt32(_model.FBEOffset - 4);
            if ((fbeStructSize <= 0) || (fbeStructType != FBEType))
                return false;

            return ((8 + _model.Verify()) == fbeStructSize);
        }

        // Serialize the struct value
        public long Serialize(StructHashEx value)
        {
            long fbeInitialSize = Buffer.Size;

            uint fbeStructType = (uint)FBEType;
            uint fbeStructSize = (uint)(8 + _model.FBEAllocationSize(value));
            uint fbeStructOffset = (uint)(Buffer.Allocate(fbeStructSize) - Buffer.Offset);
            Debug.Assert(((Buffer.Offset + fbeStructOffset + fbeStructSize) <= Buffer.Size), "Model is broken!");
            if ((Buffer.Offset + fbeStructOffset + fbeStructSize) > Buffer.Size)
                return 0;

            fbeStructSize = (uint)(8 + _model.Set(value));
            Buffer.Resize(fbeInitialSize + fbeStructSize);

            Write(_model.FBEOffset - 8, fbeStructSize);
            Write(_model.FBEOffset - 4, fbeStructType);

            return fbeStructSize;
        }

        // Deserialize the struct value
        public long Deserialize(out StructHashEx value)
        {
            Debug.Assert(((Buffer.Offset + _model.FBEOffset) <= Buffer.Size), "Model is broken!");
            if ((Buffer.Offset + _model.FBEOffset) > Buffer.Size)
            {
                value = StructHashEx.Default;
                return 0;
            }

            long fbeStructSize = ReadUInt32(_model.FBEOffset - 8);
            long fbeStructType = ReadUInt32(_model.FBEOffset - 4);
            Debug.Assert(((fbeStructSize > 0) && (fbeStructType == FBEType)), "Model is broken!");
            if ((fbeStructSize <= 0) || (fbeStructType != FBEType))
            {
                value = StructHashEx.Default;
                return 8;
            }

            return 8 + _model.Get(out value);
        }

        // Move to the next struct value
        public void Next(long prev)
        {
            _model.FBEShift(prev);
        }
    }

} // namespace com.chronoxor.test.FBE

namespace com.chronoxor.test {

    public struct StructEmpty : IComparable, IComparable<StructEmpty>, IEquatable<StructEmpty>
    {

        public const long FBETypeConst = 143;
        #if UTF8JSON
        [IgnoreDataMember]
        #else
        [JsonIgnore]
        #endif
        public long FBEType => FBETypeConst;

        public static StructEmpty Default => new StructEmpty
        {
        };

        public StructEmpty Clone()
        {
            // Serialize the struct to the FBE stream
            var writer = new com.chronoxor.test.FBE.StructEmptyModel();
            writer.Serialize(this);

            // Deserialize the struct from the FBE stream
            var reader = new com.chronoxor.test.FBE.StructEmptyModel();
            reader.Attach(writer.Buffer);
            reader.Deserialize(out var result);
            return result;
        }

        public int CompareTo(object other)
        {
            int result = 0;
            return result;
        }

        public int CompareTo(StructEmpty other)
        {
            int result = 0;
            return result;
        }

        public override bool Equals(object other)
        {
            if (!(other is StructEmpty))
                return false;
            return true;
        }

        public bool Equals(StructEmpty other)
        {
            return true;
        }

        public override int GetHashCode()
        {
            int hash = 17;
            return hash;
        }

        public static bool operator==(StructEmpty lhs, StructEmpty rhs) => lhs.Equals(rhs);
        public static bool operator!=(StructEmpty lhs, StructEmpty rhs) => !(lhs == rhs);

        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("StructEmpty(");
            sb.Append(")");
            return sb.ToString();
        }

        public string ToJson()
        {
            var json = com.chronoxor.FBE.Json.ToJson(this);
            return json;
        }

        public static StructEmpty FromJson(string json)
        {
            var result = com.chronoxor.FBE.Json.FromJson<StructEmpty>(json);
            return result;
        }

        public static com.chronoxor.FBE.FieldModelValueType<StructEmpty> CreateFieldModel(com.chronoxor.FBE.Buffer buffer, long offset) { return new test.FBE.FieldModelStructEmpty(buffer, offset); }
    }

} // namespace com.chronoxor.test

namespace com.chronoxor.test.FBE {

    using global::com.chronoxor.test;

    // Fast Binary Encoding StructEmpty field model
    public class FieldModelStructEmpty : com.chronoxor.FBE.FieldModelValueType<StructEmpty>
    {

        public FieldModelStructEmpty(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset)
        {
        }

        // Get the field size
        public override long FBESize => 4;
        // Get the field body size
        public long FBEBody
        {
            get
            {
                long fbeResult = 4 + 4
                    ;
                return fbeResult;
            }
        }
        // Get the field extra size
        public override long FBEExtra
        {
            get
            {
                if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                    return 0;

                uint fbeStructOffset = ReadUInt32(FBEOffset);
                if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4) > _buffer.Size))
                    return 0;

                _buffer.Shift(fbeStructOffset);

                long fbeResult = FBEBody
                    ;

                _buffer.Unshift(fbeStructOffset);

                return fbeResult;
            }
        }
        // Get the field type
        public const long FBETypeConst = 143;
        public long FBEType => FBETypeConst;

        // Clone the field model
        public override com.chronoxor.FBE.FieldModelValueType<StructEmpty> Clone() { return new FieldModelStructEmpty(_buffer, _offset); }

        // Check if the struct value is valid
        public override bool Verify() { return Verify(true); }
        public bool Verify(bool fbeVerifyType)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return true;

            uint fbeStructOffset = ReadUInt32(FBEOffset);
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
                return false;

            uint fbeStructSize = ReadUInt32(fbeStructOffset);
            if (fbeStructSize < (4 + 4))
                return false;

            uint fbeStructType = ReadUInt32(fbeStructOffset + 4);
            if (fbeVerifyType && (fbeStructType != FBEType))
                return false;

            _buffer.Shift(fbeStructOffset);
            bool fbeResult = VerifyFields(fbeStructSize);
            _buffer.Unshift(fbeStructOffset);
            return fbeResult;
        }

        // Check if the struct fields are valid
        public bool VerifyFields(long fbeStructSize)
        {
            return true;
        }

        // Get the struct value (begin phase)
        public long GetBegin()
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            uint fbeStructOffset = ReadUInt32(FBEOffset);
            Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + 4 + 4) <= _buffer.Size)), "Model is broken!");
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
                return 0;

            uint fbeStructSize = ReadUInt32(fbeStructOffset);
            Debug.Assert((fbeStructSize >= (4 + 4)), "Model is broken!");
            if (fbeStructSize < (4 + 4))
                return 0;

            _buffer.Shift(fbeStructOffset);
            return fbeStructOffset;
        }

        // Get the struct value (end phase)
        public void GetEnd(long fbeBegin)
        {
            _buffer.Unshift(fbeBegin);
        }

        // Get the struct value
        public override void Get(out StructEmpty fbeValue) { Get(out fbeValue, StructEmpty.Default); }
        public override void Get(out StructEmpty fbeValue, StructEmpty defaults)
        {
            long fbeBegin = GetBegin();
            if (fbeBegin == 0)
            {
                fbeValue = defaults;
                return;
            }

            uint fbeStructSize = ReadUInt32(0);
            GetFields(out fbeValue, fbeStructSize);
            GetEnd(fbeBegin);
        }

        // Get the struct fields values
        public void GetFields(out StructEmpty fbeValue, long fbeStructSize)
        {
        }

        // Set the struct value (begin phase)
        public long SetBegin()
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            uint fbeStructSize = (uint)FBEBody;
            uint fbeStructOffset = (uint)(_buffer.Allocate(fbeStructSize) - _buffer.Offset);
            Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + fbeStructSize) <= _buffer.Size)), "Model is broken!");
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + fbeStructSize) > _buffer.Size))
                return 0;

            Write(FBEOffset, fbeStructOffset);
            Write(fbeStructOffset, fbeStructSize);
            Write(fbeStructOffset + 4, (uint)FBEType);

            _buffer.Shift(fbeStructOffset);
            return fbeStructOffset;
        }

        // Set the struct value (end phase)
        public void SetEnd(long fbeBegin)
        {
            _buffer.Unshift(fbeBegin);
        }

        // Set the struct value
        public override void Set(StructEmpty fbeValue)
        {
            long fbeBegin = SetBegin();
            if (fbeBegin == 0)
                return;

            SetFields(fbeValue);
            SetEnd(fbeBegin);
        }

        // Set the struct fields values
        public void SetFields(StructEmpty fbeValue)
        {
        }
    }

} // namespace com.chronoxor.test.FBE

namespace com.chronoxor.test.FBE {

    using global::com.chronoxor.test;

    // Fast Binary Encoding StructEmpty model
    public class StructEmptyModel : com.chronoxor.FBE.Model
    {
        public readonly FieldModelStructEmpty model;

        public StructEmptyModel() { model = new FieldModelStructEmpty(Buffer, 4); }
        public StructEmptyModel(com.chronoxor.FBE.Buffer buffer) : base(buffer) { model = new FieldModelStructEmpty(Buffer, 4); }

        // Get the model size
        public long FBESize => model.FBESize + model.FBEExtra;
        // Get the model type
        public const long FBETypeConst = FieldModelStructEmpty.FBETypeConst;
        public long FBEType => FBETypeConst;

        // Check if the struct value is valid
        public bool Verify()
        {
            if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
                return false;

            uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
            if (fbeFullSize < model.FBESize)
                return false;

            return model.Verify();
        }

        // Create a new model (begin phase)
        public long CreateBegin()
        {
            long fbeBegin = Buffer.Allocate(4 + model.FBESize);
            return fbeBegin;
        }

        // Create a new model (end phase)
        public long CreateEnd(long fbeBegin)
        {
            long fbeEnd = Buffer.Size;
            uint fbeFullSize = (uint)(fbeEnd - fbeBegin);
            Write(model.FBEOffset - 4, fbeFullSize);
            return fbeFullSize;
        }

        // Serialize the struct value
        public long Serialize(StructEmpty value)
        {
            long fbeBegin = CreateBegin();
            model.Set(value);
            long fbeFullSize = CreateEnd(fbeBegin);
            return fbeFullSize;
        }

        // Deserialize the struct value
        public long Deserialize(out StructEmpty value)
        {
            if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
            {
                value = StructEmpty.Default;
                return 0;
            }

            uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
            Debug.Assert((fbeFullSize >= model.FBESize), "Model is broken!");
            if (fbeFullSize < model.FBESize)
            {
                value = StructEmpty.Default;
                return 0;
            }

            model.Get(out value);
            return fbeFullSize;
        }

        // Move to the next struct value
        public void Next(long prev)
        {
            model.FBEShift(prev);
        }
    }

} // namespace com.chronoxor.test.FBE

namespace com.chronoxor.test.FBE {

    using global::com.chronoxor.test;

    // Fast Binary Encoding StructEmpty final model
    public class FinalModelStructEmpty : com.chronoxor.FBE.FinalModelValueType<StructEmpty>
    {

        public FinalModelStructEmpty(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset)
        {
        }

        // Get the allocation size
        public override long FBEAllocationSize(StructEmpty fbeValue)
        {
            long fbeResult = 0
                ;
            return fbeResult;
        }

        // Get the final type
        public const long FBETypeConst = 143;
        public long FBEType => FBETypeConst;

        // Clone the final model
        public override com.chronoxor.FBE.FinalModelValueType<StructEmpty> Clone() { return new FinalModelStructEmpty(_buffer, _offset); }

        // Check if the struct value is valid
        public override long Verify()
        {
            _buffer.Shift(FBEOffset);
            long fbeResult = VerifyFields();
            _buffer.Unshift(FBEOffset);
            return fbeResult;
        }

        // Check if the struct fields are valid
        public long VerifyFields()
        {
            return 0;
        }

        // Get the struct value
        public override long Get(out StructEmpty fbeValue)
        {
            _buffer.Shift(FBEOffset);
            long fbeSize = GetFields(out fbeValue);
            _buffer.Unshift(FBEOffset);
            return fbeSize;
        }

        // Get the struct fields values
        public long GetFields(out StructEmpty fbeValue)
        {
            return 0;
        }

        // Set the struct value
        public override long Set(StructEmpty fbeValue)
        {
            _buffer.Shift(FBEOffset);
            long fbeResult = SetFields(fbeValue);
            _buffer.Unshift(FBEOffset);
            return fbeResult;
        }

        // Set the struct fields values
        public long SetFields(StructEmpty fbeValue)
        {
            return 0;
        }
    }

} // namespace com.chronoxor.test.FBE

namespace com.chronoxor.test.FBE {

    using global::com.chronoxor.test;

    // Fast Binary Encoding StructEmpty final model
    public class StructEmptyFinalModel : com.chronoxor.FBE.Model
    {
        private readonly FinalModelStructEmpty _model;

        public StructEmptyFinalModel() { _model = new FinalModelStructEmpty(Buffer, 8); }
        public StructEmptyFinalModel(com.chronoxor.FBE.Buffer buffer) : base(buffer) { _model = new FinalModelStructEmpty(Buffer, 8); }

        // Get the model type
        public const long FBETypeConst = FinalModelStructEmpty.FBETypeConst;
        public long FBEType => FBETypeConst;

        // Check if the struct value is valid
        public bool Verify()
        {
            if ((Buffer.Offset + _model.FBEOffset) > Buffer.Size)
                return false;

            long fbeStructSize = ReadUInt32(_model.FBEOffset - 8);
            long fbeStructType = ReadUInt32(_model.FBEOffset - 4);
            if ((fbeStructSize <= 0) || (fbeStructType != FBEType))
                return false;

            return ((8 + _model.Verify()) == fbeStructSize);
        }

        // Serialize the struct value
        public long Serialize(StructEmpty value)
        {
            long fbeInitialSize = Buffer.Size;

            uint fbeStructType = (uint)FBEType;
            uint fbeStructSize = (uint)(8 + _model.FBEAllocationSize(value));
            uint fbeStructOffset = (uint)(Buffer.Allocate(fbeStructSize) - Buffer.Offset);
            Debug.Assert(((Buffer.Offset + fbeStructOffset + fbeStructSize) <= Buffer.Size), "Model is broken!");
            if ((Buffer.Offset + fbeStructOffset + fbeStructSize) > Buffer.Size)
                return 0;

            fbeStructSize = (uint)(8 + _model.Set(value));
            Buffer.Resize(fbeInitialSize + fbeStructSize);

            Write(_model.FBEOffset - 8, fbeStructSize);
            Write(_model.FBEOffset - 4, fbeStructType);

            return fbeStructSize;
        }

        // Deserialize the struct value
        public long Deserialize(out StructEmpty value)
        {
            Debug.Assert(((Buffer.Offset + _model.FBEOffset) <= Buffer.Size), "Model is broken!");
            if ((Buffer.Offset + _model.FBEOffset) > Buffer.Size)
            {
                value = StructEmpty.Default;
                return 0;
            }

            long fbeStructSize = ReadUInt32(_model.FBEOffset - 8);
            long fbeStructType = ReadUInt32(_model.FBEOffset - 4);
            Debug.Assert(((fbeStructSize > 0) && (fbeStructType == FBEType)), "Model is broken!");
            if ((fbeStructSize <= 0) || (fbeStructType != FBEType))
            {
                value = StructEmpty.Default;
                return 8;
            }

            return 8 + _model.Get(out value);
        }

        // Move to the next struct value
        public void Next(long prev)
        {
            _model.FBEShift(prev);
        }
    }

} // namespace com.chronoxor.test.FBE

namespace com.chronoxor.test.FBE {

    // Fast Binary Encoding com.chronoxor.test protocol version
    public static class ProtocolVersion
    {
        // Protocol major version
        public const int Major = 123;
        // Protocol minor version
        public const int Minor = 456;
    }

} // namespace com.chronoxor.test.FBE

namespace com.chronoxor.test.FBE {

    // Fast Binary Encoding com.chronoxor.test sender listener interface
    public interface ISenderListener : com.chronoxor.proto.FBE.ISenderListener
    {
    }

    // Fast Binary Encoding com.chronoxor.test sender
    public class Sender : com.chronoxor.FBE.Sender, ISenderListener
    {
        // Imported senders
        public readonly proto.FBE.Sender protoSender;

        // Sender models accessors

        public Sender() : base(false)
        {
            protoSender = new proto.FBE.Sender(Buffer);
        }
        public Sender(com.chronoxor.FBE.Buffer buffer) : base(buffer, false)
        {
            protoSender = new proto.FBE.Sender(Buffer);
        }

        public long Send(object obj) { return SendListener(this, obj); }
        public long SendListener(ISenderListener listener, object obj)
        {
            switch (obj)
            {
                default: break;
            }

            long result;
            result = protoSender.SendListener(listener, obj);
            if (result > 0)
                return result;

            return 0;
        }

    }

} // namespace com.chronoxor.test.FBE

namespace com.chronoxor.test.FBE {

    // Fast Binary Encoding com.chronoxor.test receiver listener interface
    public interface IReceiverListener : com.chronoxor.proto.FBE.IReceiverListener
    {
        // Receive handlers
    }

    // Fast Binary Encoding com.chronoxor.test receiver
    public class Receiver : com.chronoxor.FBE.Receiver, IReceiverListener
    {
        // Imported receivers
        public proto.FBE.Receiver protoReceiver;

        // Receiver values accessors

        // Receiver models accessors

        public Receiver() : base(false)
        {
            protoReceiver = new proto.FBE.Receiver(Buffer);
        }
        public Receiver(com.chronoxor.FBE.Buffer buffer) : base(buffer, false)
        {
            protoReceiver = new proto.FBE.Receiver(Buffer);
        }

        internal override bool OnReceive(long type, byte[] buffer, long offset, long size) { return OnReceiveListener(this, type, buffer, offset, size); }
        internal bool OnReceiveListener(IReceiverListener listener, long type, byte[] buffer, long offset, long size)
        {
            switch (type)
            {
                default: break;
            }

            if (protoReceiver.OnReceiveListener(listener, type, buffer, offset, size))
                return true;

            return false;
        }
    }

} // namespace com.chronoxor.test.FBE

namespace com.chronoxor.test.FBE {

    // Fast Binary Encoding com.chronoxor.test proxy listener interface
    public interface IProxyListener : com.chronoxor.proto.FBE.IProxyListener
    {
        // Proxy handlers
    }

    // Fast Binary Encoding com.chronoxor.test proxy
    public class Proxy : com.chronoxor.FBE.Receiver, IProxyListener
    {
        // Imported proxy
        public proto.FBE.Proxy protoProxy;

        // Proxy models accessors

        public Proxy() : base(false)
        {
            protoProxy = new proto.FBE.Proxy(Buffer);
        }
        public Proxy(com.chronoxor.FBE.Buffer buffer) : base(buffer, false)
        {
            protoProxy = new proto.FBE.Proxy(Buffer);
        }

        internal override bool OnReceive(long type, byte[] buffer, long offset, long size) { return OnReceiveListener(this, type, buffer, offset, size); }
        internal bool OnReceiveListener(IProxyListener listener, long type, byte[] buffer, long offset, long size)
        {
            switch (type)
            {
                default: break;
            }

            if (protoProxy.OnReceiveListener(listener, type, buffer, offset, size))
                return true;

            return false;
        }
    }

} // namespace com.chronoxor.test.FBE

namespace com.chronoxor.test.FBE {

    // Fast Binary Encoding com.chronoxor.test client listener interface
    public interface IClientListener : com.chronoxor.proto.FBE.IClientListener, ISenderListener, IReceiverListener
    {
    }

    // Fast Binary Encoding com.chronoxor.test client
    public class Client : com.chronoxor.FBE.Client, IClientListener
    {
        // Imported clients
        public readonly proto.FBE.Client protoClient;

        // Client sender models accessors

        // Client receiver values accessors

        // Client receiver models accessors

        public Client() : base(false)
        {
            protoClient = new proto.FBE.Client(SendBuffer, ReceiveBuffer);
        }
        public Client(com.chronoxor.FBE.Buffer sendBuffer, com.chronoxor.FBE.Buffer receiveBuffer) : base(sendBuffer, receiveBuffer, false)
        {
            protoClient = new proto.FBE.Client(SendBuffer, ReceiveBuffer);
        }

        public long Send(object obj) { return SendListener(this, obj); }
        public long SendListener(IClientListener listener, object obj)
        {
            switch (obj)
            {
                default: break;
            }

            long result;
            result = protoClient.SendListener(listener, obj);
            if (result > 0)
                return result;

            return 0;
        }


        // Reset client requests
        internal override void ResetRequests()
        {
            base.ResetRequests();

            protoClient.ResetRequests();
        }

        // Watchdog client requests for timeouts
        internal override void WatchdogRequests(DateTime utc)
        {
            base.WatchdogRequests(utc);

            protoClient.WatchdogRequests(utc);
        }

        internal override bool OnReceive(long type, byte[] buffer, long offset, long size) { return OnReceiveListener(this, type, buffer, offset, size); }
        internal bool OnReceiveListener(IClientListener listener, long type, byte[] buffer, long offset, long size)
        {
            switch (type)
            {
                default: break;
            }

            if (protoClient.OnReceiveListener(listener, type, buffer, offset, size))
                return true;

            return false;
        }

    }

} // namespace com.chronoxor.test.FBE

namespace com.chronoxor.test.FBE {

    // Fast Binary Encoding com.chronoxor.test final sender listener interface
    public interface IFinalSenderListener : com.chronoxor.proto.FBE.IFinalSenderListener
    {
    }

    // Fast Binary Encoding com.chronoxor.test final sender
    public class FinalSender : com.chronoxor.FBE.Sender, IFinalSenderListener
    {
        // Imported senders
        public readonly proto.FBE.FinalSender protoSender;

        // Sender models accessors

        public FinalSender() : base(true)
        {
            protoSender = new proto.FBE.FinalSender(Buffer);
        }
        public FinalSender(com.chronoxor.FBE.Buffer buffer) : base(buffer, true)
        {
            protoSender = new proto.FBE.FinalSender(Buffer);
        }

        public long Send(object obj) { return SendListener(this, obj); }
        public long SendListener(IFinalSenderListener listener, object obj)
        {
            switch (obj)
            {
                default: break;
            }

            long result;
            result = protoSender.SendListener(listener, obj);
            if (result > 0)
                return result;

            return 0;
        }

    }

} // namespace com.chronoxor.test.FBE

namespace com.chronoxor.test.FBE {

    // Fast Binary Encoding com.chronoxor.test final receiver listener interface
    public interface IFinalReceiverListener : com.chronoxor.proto.FBE.IFinalReceiverListener
    {
        // Receive handlers
    }

    // Fast Binary Encoding com.chronoxor.test final receiver
    public class FinalReceiver : com.chronoxor.FBE.Receiver, IFinalReceiverListener
    {
        // Imported receivers
        public proto.FBE.FinalReceiver protoReceiver;

        // Receiver values accessors

        // Receiver models accessors

        public FinalReceiver() : base(true)
        {
            protoReceiver = new proto.FBE.FinalReceiver(Buffer);
        }
        public FinalReceiver(com.chronoxor.FBE.Buffer buffer) : base(buffer, true)
        {
            protoReceiver = new proto.FBE.FinalReceiver(Buffer);
        }

        internal override bool OnReceive(long type, byte[] buffer, long offset, long size) { return OnReceiveListener(this, type, buffer, offset, size); }
        internal bool OnReceiveListener(IFinalReceiverListener listener, long type, byte[] buffer, long offset, long size)
        {
            switch (type)
            {
                default: break;
            }

            if (protoReceiver.OnReceiveListener(listener, type, buffer, offset, size))
                return true;

            return false;
        }
    }

} // namespace com.chronoxor.test.FBE

namespace com.chronoxor.test.FBE {

    // Fast Binary Encoding com.chronoxor.test final client listener interface
    public interface IFinalClientListener : com.chronoxor.proto.FBE.IFinalClientListener, IFinalSenderListener, IFinalReceiverListener
    {
    }

    // Fast Binary Encoding com.chronoxor.test final client
    public class FinalClient : com.chronoxor.FBE.Client, IFinalClientListener
    {
        // Imported clients
        public readonly proto.FBE.FinalClient protoClient;

        // Client sender models accessors

        // Client receiver values accessors

        // Client receiver models accessors

        public FinalClient() : base(true)
        {
            protoClient = new proto.FBE.FinalClient(SendBuffer, ReceiveBuffer);
        }
        public FinalClient(com.chronoxor.FBE.Buffer sendBuffer, com.chronoxor.FBE.Buffer receiveBuffer) : base(sendBuffer, receiveBuffer, true)
        {
            protoClient = new proto.FBE.FinalClient(SendBuffer, ReceiveBuffer);
        }

        public long Send(object obj) { return SendListener(this, obj); }
        public long SendListener(IFinalClientListener listener, object obj)
        {
            switch (obj)
            {
                default: break;
            }

            long result;
            result = protoClient.SendListener(listener, obj);
            if (result > 0)
                return result;

            return 0;
        }


        // Reset client requests
        internal override void ResetRequests()
        {
            base.ResetRequests();

            protoClient.ResetRequests();
        }

        // Watchdog client requests for timeouts
        internal override void WatchdogRequests(DateTime utc)
        {
            base.WatchdogRequests(utc);

            protoClient.WatchdogRequests(utc);
        }

        internal override bool OnReceive(long type, byte[] buffer, long offset, long size) { return OnReceiveListener(this, type, buffer, offset, size); }
        internal bool OnReceiveListener(IFinalClientListener listener, long type, byte[] buffer, long offset, long size)
        {
            switch (type)
            {
                default: break;
            }

            if (protoClient.OnReceiveListener(listener, type, buffer, offset, size))
                return true;

            return false;
        }

    }

} // namespace com.chronoxor.test.FBE

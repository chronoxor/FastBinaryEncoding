//------------------------------------------------------------------------------
// <auto-generated>
//     Automatically generated by the Fast Binary Encoding compiler, do not modify!
//     https://github.com/chronoxor/FastBinaryEncoding
//     Source: proto.fbe
//     FBE version: 1.14.5.0
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Numerics;
using System.Runtime.Serialization;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
#if UTF8JSON
using Utf8Json;
using Utf8Json.Resolvers;
#elif NEWTONSOFTJSON
using Newtonsoft.Json;
#else
using System.Text.Json;
using System.Text.Json.Serialization;
#endif

namespace com.chronoxor.proto {

#if UTF8JSON
    public class OrderSideConverter : IJsonFormatter<OrderSide>
    {
        public void Serialize(ref JsonWriter writer, OrderSide value, IJsonFormatterResolver jsonFormatterResolver)
        {
            writer.WriteByte(value.Value);
        }

        public OrderSide Deserialize(ref JsonReader reader, IJsonFormatterResolver jsonFormatterResolver)
        {
            return new OrderSide(reader.ReadByte());
        }
    }

    [JsonFormatter(typeof(OrderSideConverter))]
#elif NEWTONSOFTJSON
    public class OrderSideConverter : JsonConverter
    {
        public override bool CanConvert(Type objectType)
        {
            return objectType == typeof(OrderSide);
        }

        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
        {
            writer.WriteValue(((OrderSide)value).Value);
        }

        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
        {
            if (reader.Value == null)
                return null;

            switch (reader.Value)
            {
                case long longValue:
                    return new OrderSide((byte)longValue);
                case BigInteger bigValue:
                    return new OrderSide((byte)bigValue);
                default:
                    return null;
            }
        }
    }

    [JsonConverter(typeof(OrderSideConverter))]
#else
    public class OrderSideConverter : JsonConverter<OrderSide>
    {
        public override void Write(Utf8JsonWriter writer, OrderSide value, JsonSerializerOptions options) => writer.WriteNumberValue(value.Value);
        public override OrderSide Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => new OrderSide(reader.GetByte());
    }

    [JsonConverter(typeof(OrderSideConverter))]
#endif
    public struct OrderSide : IComparable, IComparable<OrderSide>, IEquatable<OrderSide>
    {
        public byte Value { get; internal set; }

        public OrderSide(byte value) : this()
        {
            Value = value;
        }

        public OrderSide(OrderSide value) : this()
        {
            Value = value.Value;
        }

        public int CompareTo(object other)
        {
            return Value.CompareTo(((OrderSide)other).Value);
        }

        public int CompareTo(OrderSide other)
        {
            return Value.CompareTo(other.Value);
        }

        public override bool Equals(object other)
        {
            return (other is OrderSide value) && Value.Equals(value.Value);
        }

        public bool Equals(OrderSide other)
        {
            return Value.Equals(other.Value);
        }

        public override int GetHashCode()
        {
            return Value.GetHashCode();
        }

        public static bool operator==(OrderSide value1, OrderSide value2)
        {
            return value1.Value == value2.Value;
        }

        public static bool operator!=(OrderSide value1, OrderSide value2)
        {
            return value1.Value != value2.Value;
        }

        public static OrderSide Default => new OrderSide();

        public static com.chronoxor.FBE.FieldModelValueType<OrderSide> CreateFieldModel(com.chronoxor.FBE.Buffer buffer, long offset) { return new proto.FBE.FieldModelOrderSide(buffer, offset); }

        public const byte _buy_ = (byte)0U + 0;
        public const byte _sell_ = (byte)0U + 1;

        public static OrderSide buy = new OrderSide(_buy_);
        public static OrderSide sell = new OrderSide(_sell_);

        public override string ToString()
        {
            if (this == buy) return "buy";
            if (this == sell) return "sell";
            return "<unknown>";
        }
    }

} // namespace com.chronoxor.proto

namespace com.chronoxor.proto.FBE {

    using global::com.chronoxor.proto;

    // Fast Binary Encoding OrderSide field model
    public class FieldModelOrderSide : com.chronoxor.FBE.FieldModelValueType<OrderSide>
    {
        public FieldModelOrderSide(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset) {}

        // Get the field size
        public override long FBESize => 1;

        // Clone the field model
        public override com.chronoxor.FBE.FieldModelValueType<OrderSide> Clone() { return new FieldModelOrderSide(_buffer, _offset); }

        // Get the value
        public override void Get(out OrderSide value) { Get(out value, OrderSide.Default); }
        public override void Get(out OrderSide value, OrderSide defaults)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
            {
                value = defaults;
                return;
            }

            value = new OrderSide((byte)ReadByte(FBEOffset));
        }

        // Set the value
        public override void Set(OrderSide value)
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return;

            Write(FBEOffset, value.Value);
        }
    }

} // namespace com.chronoxor.proto.FBE

namespace com.chronoxor.proto.FBE {

    using global::com.chronoxor.proto;

    // Fast Binary Encoding OrderSide final model
    public class FinalModelOrderSide : com.chronoxor.FBE.FinalModelValueType<OrderSide>
    {
        public FinalModelOrderSide(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset) {}

        // Get the allocation size
        public override long FBEAllocationSize(OrderSide value) { return FBESize; }

        // Get the final size
        public override long FBESize => 1;

        // Clone the final model
        public override com.chronoxor.FBE.FinalModelValueType<OrderSide> Clone() { return new FinalModelOrderSide(_buffer, _offset); }

        // Check if the value is valid
        public override long Verify()
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return long.MaxValue;

            return FBESize;
        }

        // Get the value
        public override long Get(out OrderSide value)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
            {
                value = OrderSide.Default;
                return 0;
            }

            value = new OrderSide((byte)ReadByte(FBEOffset));
            return FBESize;
        }

        // Set the value
        public override long Set(OrderSide value)
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            Write(FBEOffset, value.Value);
            return FBESize;
        }
    }

} // namespace com.chronoxor.proto.FBE

namespace com.chronoxor.proto {

#if UTF8JSON
    public class OrderTypeConverter : IJsonFormatter<OrderType>
    {
        public void Serialize(ref JsonWriter writer, OrderType value, IJsonFormatterResolver jsonFormatterResolver)
        {
            writer.WriteByte(value.Value);
        }

        public OrderType Deserialize(ref JsonReader reader, IJsonFormatterResolver jsonFormatterResolver)
        {
            return new OrderType(reader.ReadByte());
        }
    }

    [JsonFormatter(typeof(OrderTypeConverter))]
#elif NEWTONSOFTJSON
    public class OrderTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type objectType)
        {
            return objectType == typeof(OrderType);
        }

        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
        {
            writer.WriteValue(((OrderType)value).Value);
        }

        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
        {
            if (reader.Value == null)
                return null;

            switch (reader.Value)
            {
                case long longValue:
                    return new OrderType((byte)longValue);
                case BigInteger bigValue:
                    return new OrderType((byte)bigValue);
                default:
                    return null;
            }
        }
    }

    [JsonConverter(typeof(OrderTypeConverter))]
#else
    public class OrderTypeConverter : JsonConverter<OrderType>
    {
        public override void Write(Utf8JsonWriter writer, OrderType value, JsonSerializerOptions options) => writer.WriteNumberValue(value.Value);
        public override OrderType Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => new OrderType(reader.GetByte());
    }

    [JsonConverter(typeof(OrderTypeConverter))]
#endif
    public struct OrderType : IComparable, IComparable<OrderType>, IEquatable<OrderType>
    {
        public byte Value { get; internal set; }

        public OrderType(byte value) : this()
        {
            Value = value;
        }

        public OrderType(OrderType value) : this()
        {
            Value = value.Value;
        }

        public int CompareTo(object other)
        {
            return Value.CompareTo(((OrderType)other).Value);
        }

        public int CompareTo(OrderType other)
        {
            return Value.CompareTo(other.Value);
        }

        public override bool Equals(object other)
        {
            return (other is OrderType value) && Value.Equals(value.Value);
        }

        public bool Equals(OrderType other)
        {
            return Value.Equals(other.Value);
        }

        public override int GetHashCode()
        {
            return Value.GetHashCode();
        }

        public static bool operator==(OrderType value1, OrderType value2)
        {
            return value1.Value == value2.Value;
        }

        public static bool operator!=(OrderType value1, OrderType value2)
        {
            return value1.Value != value2.Value;
        }

        public static OrderType Default => new OrderType();

        public static com.chronoxor.FBE.FieldModelValueType<OrderType> CreateFieldModel(com.chronoxor.FBE.Buffer buffer, long offset) { return new proto.FBE.FieldModelOrderType(buffer, offset); }

        public const byte _market_ = (byte)0U + 0;
        public const byte _limit_ = (byte)0U + 1;
        public const byte _stop_ = (byte)0U + 2;

        public static OrderType market = new OrderType(_market_);
        public static OrderType limit = new OrderType(_limit_);
        public static OrderType stop = new OrderType(_stop_);

        public override string ToString()
        {
            if (this == market) return "market";
            if (this == limit) return "limit";
            if (this == stop) return "stop";
            return "<unknown>";
        }
    }

} // namespace com.chronoxor.proto

namespace com.chronoxor.proto.FBE {

    using global::com.chronoxor.proto;

    // Fast Binary Encoding OrderType field model
    public class FieldModelOrderType : com.chronoxor.FBE.FieldModelValueType<OrderType>
    {
        public FieldModelOrderType(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset) {}

        // Get the field size
        public override long FBESize => 1;

        // Clone the field model
        public override com.chronoxor.FBE.FieldModelValueType<OrderType> Clone() { return new FieldModelOrderType(_buffer, _offset); }

        // Get the value
        public override void Get(out OrderType value) { Get(out value, OrderType.Default); }
        public override void Get(out OrderType value, OrderType defaults)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
            {
                value = defaults;
                return;
            }

            value = new OrderType((byte)ReadByte(FBEOffset));
        }

        // Set the value
        public override void Set(OrderType value)
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return;

            Write(FBEOffset, value.Value);
        }
    }

} // namespace com.chronoxor.proto.FBE

namespace com.chronoxor.proto.FBE {

    using global::com.chronoxor.proto;

    // Fast Binary Encoding OrderType final model
    public class FinalModelOrderType : com.chronoxor.FBE.FinalModelValueType<OrderType>
    {
        public FinalModelOrderType(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset) {}

        // Get the allocation size
        public override long FBEAllocationSize(OrderType value) { return FBESize; }

        // Get the final size
        public override long FBESize => 1;

        // Clone the final model
        public override com.chronoxor.FBE.FinalModelValueType<OrderType> Clone() { return new FinalModelOrderType(_buffer, _offset); }

        // Check if the value is valid
        public override long Verify()
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return long.MaxValue;

            return FBESize;
        }

        // Get the value
        public override long Get(out OrderType value)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
            {
                value = OrderType.Default;
                return 0;
            }

            value = new OrderType((byte)ReadByte(FBEOffset));
            return FBESize;
        }

        // Set the value
        public override long Set(OrderType value)
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            Write(FBEOffset, value.Value);
            return FBESize;
        }
    }

} // namespace com.chronoxor.proto.FBE

namespace com.chronoxor.proto {

#if UTF8JSON
    public class StateConverter : IJsonFormatter<State>
    {
        public void Serialize(ref JsonWriter writer, State value, IJsonFormatterResolver jsonFormatterResolver)
        {
            writer.WriteByte(value.Value);
        }

        public State Deserialize(ref JsonReader reader, IJsonFormatterResolver jsonFormatterResolver)
        {
            return new State(reader.ReadByte());
        }
    }

    [JsonFormatter(typeof(StateConverter))]
#elif NEWTONSOFTJSON
    public class StateConverter : JsonConverter
    {
        public override bool CanConvert(Type objectType)
        {
            return objectType == typeof(State);
        }

        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
        {
            writer.WriteValue(((State)value).Value);
        }

        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
        {
            if (reader.Value == null)
                return null;

            switch (reader.Value)
            {
                case long longValue:
                    return new State((byte)longValue);
                case BigInteger bigValue:
                    return new State((byte)bigValue);
                default:
                    return null;
            }
        }
    }

    [JsonConverter(typeof(StateConverter))]
#else
    public class StateConverter : JsonConverter<State>
    {
        public override void Write(Utf8JsonWriter writer, State value, JsonSerializerOptions options) => writer.WriteNumberValue(value.Value);
        public override State Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => new State(reader.GetByte());
    }

    [JsonConverter(typeof(StateConverter))]
#endif
    public struct State : IComparable, IComparable<State>, IEquatable<State>
    {
        public byte Value { get; internal set; }

        public State(byte value) : this()
        {
            Value = value;
        }

        public State(State value) : this()
        {
            Value = value.Value;
        }

        public bool HasFlags(State flags)
        {
            return (((Value & flags.Value) != 0) && ((Value & flags.Value) == flags.Value));
        }

        public State SetFlags(State flags)
        {
            Value |= flags.Value;
            return this;
        }

        public State RemoveFlags(State flags)
        {
            Value &= (byte)~flags.Value;
            return this;
        }

        public int CompareTo(object other)
        {
            return Value.CompareTo(((State)other).Value);
        }

        public int CompareTo(State other)
        {
            return Value.CompareTo(other.Value);
        }

        public override bool Equals(object other)
        {
            return (other is State value) && Value.Equals(value.Value);
        }

        public bool Equals(State other)
        {
            return Value.Equals(other.Value);
        }

        public override int GetHashCode()
        {
            return Value.GetHashCode();
        }

        public static bool operator==(State flags1, State flags2)
        {
            return flags1.Value == flags2.Value;
        }

        public static bool operator!=(State flags1, State flags2)
        {
            return flags1.Value != flags2.Value;
        }

        public static State operator&(State flags1, State flags2)
        {
            return new State((byte)(flags1.Value & flags2.Value));
        }

        public static State operator|(State flags1, State flags2)
        {
            return new State((byte)(flags1.Value | flags2.Value));
        }

        public static State operator^(State flags1, State flags2)
        {
            return new State((byte)(flags1.Value ^ flags2.Value));
        }

        public static State Default => new State();

        public static com.chronoxor.FBE.FieldModelValueType<State> CreateFieldModel(com.chronoxor.FBE.Buffer buffer, long offset) { return new proto.FBE.FieldModelState(buffer, offset); }

        public const byte _unknown_ = (byte)0x00U;
        public const byte _invalid_ = (byte)0x01U;
        public const byte _initialized_ = (byte)0x02U;
        public const byte _calculated_ = (byte)0x04U;
        public const byte _broken_ = (byte)0x08U;
        public const byte _good_ = _initialized_ | _calculated_;
        public const byte _bad_ = _unknown_ | _invalid_ | _broken_;

        public static State unknown = new State(_unknown_);
        public static State invalid = new State(_invalid_);
        public static State initialized = new State(_initialized_);
        public static State calculated = new State(_calculated_);
        public static State broken = new State(_broken_);
        public static State good = new State(_good_);
        public static State bad = new State(_bad_);

        public override string ToString()
        {
            var value = new State(Value);
            var sb = new StringBuilder();
            bool first = true;
            if (HasFlags(unknown))
            {
                sb.Append(first ? "" : "|").Append("unknown");
                first = false;
            }
            if (HasFlags(invalid))
            {
                sb.Append(first ? "" : "|").Append("invalid");
                first = false;
            }
            if (HasFlags(initialized))
            {
                sb.Append(first ? "" : "|").Append("initialized");
                first = false;
            }
            if (HasFlags(calculated))
            {
                sb.Append(first ? "" : "|").Append("calculated");
                first = false;
            }
            if (HasFlags(broken))
            {
                sb.Append(first ? "" : "|").Append("broken");
                first = false;
            }
            if (HasFlags(good))
            {
                sb.Append(first ? "" : "|").Append("good");
                first = false;
            }
            if (HasFlags(bad))
            {
                sb.Append(first ? "" : "|").Append("bad");
                first = false;
            }
            return sb.ToString();
        }
    }

} // namespace com.chronoxor.proto

namespace com.chronoxor.proto.FBE {

    using global::com.chronoxor.proto;

    // Fast Binary Encoding State field model
    public class FieldModelState : com.chronoxor.FBE.FieldModelValueType<State>
    {
        public FieldModelState(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset) {}

        // Get the field size
        public override long FBESize => 1;

        // Clone the field model
        public override com.chronoxor.FBE.FieldModelValueType<State> Clone() { return new FieldModelState(_buffer, _offset); }

        // Get the value
        public override void Get(out State value) { Get(out value, State.Default); }
        public override void Get(out State value, State defaults)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
            {
                value = defaults;
                return;
            }

            value = new State((byte)ReadByte(FBEOffset));
        }

        // Set the value
        public override void Set(State value)
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return;

            Write(FBEOffset, value.Value);
        }
    }

} // namespace com.chronoxor.proto.FBE

namespace com.chronoxor.proto.FBE {

    using global::com.chronoxor.proto;

    // Fast Binary Encoding State final model
    public class FinalModelState : com.chronoxor.FBE.FinalModelValueType<State>
    {
        public FinalModelState(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset) {}

        // Get the allocation size
        public override long FBEAllocationSize(State value) { return FBESize; }

        // Get the final size
        public override long FBESize => 1;

        // Clone the final model
        public override com.chronoxor.FBE.FinalModelValueType<State> Clone() { return new FinalModelState(_buffer, _offset); }

        // Check if the value is valid
        public override long Verify()
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return long.MaxValue;

            return FBESize;
        }

        // Get the value
        public override long Get(out State value)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
            {
                value = State.Default;
                return 0;
            }

            value = new State((byte)ReadByte(FBEOffset));
            return FBESize;
        }

        // Set the value
        public override long Set(State value)
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            Write(FBEOffset, value.Value);
            return FBESize;
        }
    }

} // namespace com.chronoxor.proto.FBE

namespace com.chronoxor.proto {

    public struct Order : IComparable, IComparable<Order>, IEquatable<Order>
    {
        public int id;
        public string symbol;
        public OrderSide side;
        public OrderType type;
        public double price;
        public double volume;

        public const long FBETypeConst = 1;
        #if UTF8JSON
        [IgnoreDataMember]
        #else
        [JsonIgnore]
        #endif
        public long FBEType => FBETypeConst;

        public static Order Default => new Order
        {
            id = (int)0
            , symbol = ""
            , side = global::com.chronoxor.proto.OrderSide.Default
            , type = global::com.chronoxor.proto.OrderType.Default
            , price = (double)0.0D
            , volume = (double)0.0D
        };

        public Order(int id, string symbol, OrderSide side, OrderType type, double price, double volume)
        {
            this.id = id;
            this.symbol = symbol;
            this.side = side;
            this.type = type;
            this.price = price;
            this.volume = volume;
        }

        public Order Clone()
        {
            // Serialize the struct to the FBE stream
            var writer = new com.chronoxor.proto.FBE.OrderModel();
            writer.Serialize(this);

            // Deserialize the struct from the FBE stream
            var reader = new com.chronoxor.proto.FBE.OrderModel();
            reader.Attach(writer.Buffer);
            reader.Deserialize(out var result);
            return result;
        }

        public int CompareTo(object other)
        {
            int result = 0;
            result = id.CompareTo(((Order)other).id);
            if (result != 0)
                return result;
            return result;
        }

        public int CompareTo(Order other)
        {
            int result = 0;
            result = id.CompareTo(other.id);
            if (result != 0)
                return result;
            return result;
        }

        public override bool Equals(object other)
        {
            if (!(other is Order))
                return false;
            if (!id.Equals(((Order)other).id))
                return false;
            return true;
        }

        public bool Equals(Order other)
        {
            if (!id.Equals(other.id))
                return false;
            return true;
        }

        public override int GetHashCode()
        {
            int hash = 17;
            hash = hash * 31 + id.GetHashCode();
            return hash;
        }

        public static bool operator==(Order lhs, Order rhs) => lhs.Equals(rhs);
        public static bool operator!=(Order lhs, Order rhs) => !(lhs == rhs);

        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("Order(");
            sb.Append("id="); sb.Append(id);
            sb.Append(",symbol="); if (symbol != null) sb.Append("\"").Append(symbol).Append("\""); else sb.Append("null");
            sb.Append(",side="); sb.Append(side);
            sb.Append(",type="); sb.Append(type);
            sb.Append(",price="); sb.Append(price.ToString(CultureInfo.InvariantCulture));
            sb.Append(",volume="); sb.Append(volume.ToString(CultureInfo.InvariantCulture));
            sb.Append(")");
            return sb.ToString();
        }

        public string ToJson()
        {
            var json = com.chronoxor.FBE.Json.ToJson(this);
            return json;
        }

        public static Order FromJson(string json)
        {
            var result = com.chronoxor.FBE.Json.FromJson<Order>(json);
            return result;
        }

        public static com.chronoxor.FBE.FieldModelValueType<Order> CreateFieldModel(com.chronoxor.FBE.Buffer buffer, long offset) { return new proto.FBE.FieldModelOrder(buffer, offset); }
    }

} // namespace com.chronoxor.proto

namespace com.chronoxor.proto.FBE {

    using global::com.chronoxor.proto;

    // Fast Binary Encoding Order field model
    public class FieldModelOrder : com.chronoxor.FBE.FieldModelValueType<Order>
    {
        public readonly com.chronoxor.FBE.FieldModelValueType<int> id;
        public readonly com.chronoxor.FBE.FieldModelReferenceType<string> symbol;
        public readonly com.chronoxor.proto.FBE.FieldModelOrderSide side;
        public readonly com.chronoxor.proto.FBE.FieldModelOrderType type;
        public readonly com.chronoxor.FBE.FieldModelValueType<double> price;
        public readonly com.chronoxor.FBE.FieldModelValueType<double> volume;

        public FieldModelOrder(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset)
        {
            id = com.chronoxor.FBE.FieldModelValueType<int>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.INT32, buffer, 4 + 4);
            symbol = com.chronoxor.FBE.FieldModelReferenceType<string>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.STRING, buffer, id.FBEOffset + id.FBESize);
            side = new com.chronoxor.proto.FBE.FieldModelOrderSide(buffer, symbol.FBEOffset + symbol.FBESize);
            type = new com.chronoxor.proto.FBE.FieldModelOrderType(buffer, side.FBEOffset + side.FBESize);
            price = com.chronoxor.FBE.FieldModelValueType<double>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.DOUBLE, buffer, type.FBEOffset + type.FBESize);
            volume = com.chronoxor.FBE.FieldModelValueType<double>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.DOUBLE, buffer, price.FBEOffset + price.FBESize);
        }

        // Get the field size
        public override long FBESize => 4;
        // Get the field body size
        public long FBEBody
        {
            get
            {
                long fbeResult = 4 + 4
                    + id.FBESize
                    + symbol.FBESize
                    + side.FBESize
                    + type.FBESize
                    + price.FBESize
                    + volume.FBESize
                    ;
                return fbeResult;
            }
        }
        // Get the field extra size
        public override long FBEExtra
        {
            get
            {
                if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                    return 0;

                uint fbeStructOffset = ReadUInt32(FBEOffset);
                if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4) > _buffer.Size))
                    return 0;

                _buffer.Shift(fbeStructOffset);

                long fbeResult = FBEBody
                    + id.FBEExtra
                    + symbol.FBEExtra
                    + side.FBEExtra
                    + type.FBEExtra
                    + price.FBEExtra
                    + volume.FBEExtra
                    ;

                _buffer.Unshift(fbeStructOffset);

                return fbeResult;
            }
        }
        // Get the field type
        public const long FBETypeConst = 1;
        public long FBEType => FBETypeConst;

        // Clone the field model
        public override com.chronoxor.FBE.FieldModelValueType<Order> Clone() { return new FieldModelOrder(_buffer, _offset); }

        // Check if the struct value is valid
        public override bool Verify() { return Verify(true); }
        public bool Verify(bool fbeVerifyType)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return true;

            uint fbeStructOffset = ReadUInt32(FBEOffset);
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
                return false;

            uint fbeStructSize = ReadUInt32(fbeStructOffset);
            if (fbeStructSize < (4 + 4))
                return false;

            uint fbeStructType = ReadUInt32(fbeStructOffset + 4);
            if (fbeVerifyType && (fbeStructType != FBEType))
                return false;

            _buffer.Shift(fbeStructOffset);
            bool fbeResult = VerifyFields(fbeStructSize);
            _buffer.Unshift(fbeStructOffset);
            return fbeResult;
        }

        // Check if the struct fields are valid
        public bool VerifyFields(long fbeStructSize)
        {
            long fbeCurrentSize = 4 + 4;

            if ((fbeCurrentSize + id.FBESize) > fbeStructSize)
                return true;
            if (!id.Verify())
                return false;
            fbeCurrentSize += id.FBESize;

            if ((fbeCurrentSize + symbol.FBESize) > fbeStructSize)
                return true;
            if (!symbol.Verify())
                return false;
            fbeCurrentSize += symbol.FBESize;

            if ((fbeCurrentSize + side.FBESize) > fbeStructSize)
                return true;
            if (!side.Verify())
                return false;
            fbeCurrentSize += side.FBESize;

            if ((fbeCurrentSize + type.FBESize) > fbeStructSize)
                return true;
            if (!type.Verify())
                return false;
            fbeCurrentSize += type.FBESize;

            if ((fbeCurrentSize + price.FBESize) > fbeStructSize)
                return true;
            if (!price.Verify())
                return false;
            fbeCurrentSize += price.FBESize;

            if ((fbeCurrentSize + volume.FBESize) > fbeStructSize)
                return true;
            if (!volume.Verify())
                return false;
            fbeCurrentSize += volume.FBESize;

            return true;
        }

        // Get the struct value (begin phase)
        public long GetBegin()
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            uint fbeStructOffset = ReadUInt32(FBEOffset);
            Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + 4 + 4) <= _buffer.Size)), "Model is broken!");
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
                return 0;

            uint fbeStructSize = ReadUInt32(fbeStructOffset);
            Debug.Assert((fbeStructSize >= (4 + 4)), "Model is broken!");
            if (fbeStructSize < (4 + 4))
                return 0;

            _buffer.Shift(fbeStructOffset);
            return fbeStructOffset;
        }

        // Get the struct value (end phase)
        public void GetEnd(long fbeBegin)
        {
            _buffer.Unshift(fbeBegin);
        }

        // Get the struct value
        public override void Get(out Order fbeValue) { Get(out fbeValue, Order.Default); }
        public override void Get(out Order fbeValue, Order defaults)
        {
            long fbeBegin = GetBegin();
            if (fbeBegin == 0)
            {
                fbeValue = defaults;
                return;
            }

            uint fbeStructSize = ReadUInt32(0);
            GetFields(out fbeValue, fbeStructSize);
            GetEnd(fbeBegin);
        }

        // Get the struct fields values
        public void GetFields(out Order fbeValue, long fbeStructSize)
        {
            long fbeCurrentSize = 4 + 4;

            fbeValue = Order.Default;

            if ((fbeCurrentSize + id.FBESize) <= fbeStructSize)
                id.Get(out fbeValue.id);
            else
                fbeValue.id = (int)0;
            fbeCurrentSize += id.FBESize;

            if ((fbeCurrentSize + symbol.FBESize) <= fbeStructSize)
                symbol.Get(out fbeValue.symbol);
            else
                fbeValue.symbol = "";
            fbeCurrentSize += symbol.FBESize;

            if ((fbeCurrentSize + side.FBESize) <= fbeStructSize)
                side.Get(out fbeValue.side);
            else
                fbeValue.side = global::com.chronoxor.proto.OrderSide.Default;
            fbeCurrentSize += side.FBESize;

            if ((fbeCurrentSize + type.FBESize) <= fbeStructSize)
                type.Get(out fbeValue.type);
            else
                fbeValue.type = global::com.chronoxor.proto.OrderType.Default;
            fbeCurrentSize += type.FBESize;

            if ((fbeCurrentSize + price.FBESize) <= fbeStructSize)
                price.Get(out fbeValue.price, (double)0.0D);
            else
                fbeValue.price = (double)0.0D;
            fbeCurrentSize += price.FBESize;

            if ((fbeCurrentSize + volume.FBESize) <= fbeStructSize)
                volume.Get(out fbeValue.volume, (double)0.0D);
            else
                fbeValue.volume = (double)0.0D;
            fbeCurrentSize += volume.FBESize;
        }

        // Set the struct value (begin phase)
        public long SetBegin()
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            uint fbeStructSize = (uint)FBEBody;
            uint fbeStructOffset = (uint)(_buffer.Allocate(fbeStructSize) - _buffer.Offset);
            Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + fbeStructSize) <= _buffer.Size)), "Model is broken!");
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + fbeStructSize) > _buffer.Size))
                return 0;

            Write(FBEOffset, fbeStructOffset);
            Write(fbeStructOffset, fbeStructSize);
            Write(fbeStructOffset + 4, (uint)FBEType);

            _buffer.Shift(fbeStructOffset);
            return fbeStructOffset;
        }

        // Set the struct value (end phase)
        public void SetEnd(long fbeBegin)
        {
            _buffer.Unshift(fbeBegin);
        }

        // Set the struct value
        public override void Set(Order fbeValue)
        {
            long fbeBegin = SetBegin();
            if (fbeBegin == 0)
                return;

            SetFields(fbeValue);
            SetEnd(fbeBegin);
        }

        // Set the struct fields values
        public void SetFields(Order fbeValue)
        {
            id.Set(fbeValue.id);
            symbol.Set(fbeValue.symbol);
            side.Set(fbeValue.side);
            type.Set(fbeValue.type);
            price.Set(fbeValue.price);
            volume.Set(fbeValue.volume);
        }
    }

} // namespace com.chronoxor.proto.FBE

namespace com.chronoxor.proto.FBE {

    using global::com.chronoxor.proto;

    // Fast Binary Encoding Order model
    public class OrderModel : com.chronoxor.FBE.Model
    {
        public readonly FieldModelOrder model;

        public OrderModel() { model = new FieldModelOrder(Buffer, 4); }
        public OrderModel(com.chronoxor.FBE.Buffer buffer) : base(buffer) { model = new FieldModelOrder(Buffer, 4); }

        // Get the model size
        public long FBESize => model.FBESize + model.FBEExtra;
        // Get the model type
        public const long FBETypeConst = FieldModelOrder.FBETypeConst;
        public long FBEType => FBETypeConst;

        // Check if the struct value is valid
        public bool Verify()
        {
            if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
                return false;

            uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
            if (fbeFullSize < model.FBESize)
                return false;

            return model.Verify();
        }

        // Create a new model (begin phase)
        public long CreateBegin()
        {
            long fbeBegin = Buffer.Allocate(4 + model.FBESize);
            return fbeBegin;
        }

        // Create a new model (end phase)
        public long CreateEnd(long fbeBegin)
        {
            long fbeEnd = Buffer.Size;
            uint fbeFullSize = (uint)(fbeEnd - fbeBegin);
            Write(model.FBEOffset - 4, fbeFullSize);
            return fbeFullSize;
        }

        // Serialize the struct value
        public long Serialize(Order value)
        {
            long fbeBegin = CreateBegin();
            model.Set(value);
            long fbeFullSize = CreateEnd(fbeBegin);
            return fbeFullSize;
        }

        // Deserialize the struct value
        public long Deserialize(out Order value)
        {
            if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
            {
                value = Order.Default;
                return 0;
            }

            uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
            Debug.Assert((fbeFullSize >= model.FBESize), "Model is broken!");
            if (fbeFullSize < model.FBESize)
            {
                value = Order.Default;
                return 0;
            }

            model.Get(out value);
            return fbeFullSize;
        }

        // Move to the next struct value
        public void Next(long prev)
        {
            model.FBEShift(prev);
        }
    }

} // namespace com.chronoxor.proto.FBE

namespace com.chronoxor.proto.FBE {

    using global::com.chronoxor.proto;

    // Fast Binary Encoding Order final model
    public class FinalModelOrder : com.chronoxor.FBE.FinalModelValueType<Order>
    {
        public readonly com.chronoxor.FBE.FinalModelValueType<int> id;
        public readonly com.chronoxor.FBE.FinalModelReferenceType<string> symbol;
        public readonly com.chronoxor.proto.FBE.FinalModelOrderSide side;
        public readonly com.chronoxor.proto.FBE.FinalModelOrderType type;
        public readonly com.chronoxor.FBE.FinalModelValueType<double> price;
        public readonly com.chronoxor.FBE.FinalModelValueType<double> volume;

        public FinalModelOrder(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset)
        {
            id = com.chronoxor.FBE.FinalModelValueType<int>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.INT32, buffer, 0);
            symbol = com.chronoxor.FBE.FinalModelReferenceType<string>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.STRING, buffer, 0);
            side = new com.chronoxor.proto.FBE.FinalModelOrderSide(buffer, 0);
            type = new com.chronoxor.proto.FBE.FinalModelOrderType(buffer, 0);
            price = com.chronoxor.FBE.FinalModelValueType<double>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.DOUBLE, buffer, 0);
            volume = com.chronoxor.FBE.FinalModelValueType<double>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.DOUBLE, buffer, 0);
        }

        // Get the allocation size
        public override long FBEAllocationSize(Order fbeValue)
        {
            long fbeResult = 0
                + id.FBEAllocationSize(fbeValue.id)
                + symbol.FBEAllocationSize(fbeValue.symbol)
                + side.FBEAllocationSize(fbeValue.side)
                + type.FBEAllocationSize(fbeValue.type)
                + price.FBEAllocationSize(fbeValue.price)
                + volume.FBEAllocationSize(fbeValue.volume)
                ;
            return fbeResult;
        }

        // Get the final type
        public const long FBETypeConst = 1;
        public long FBEType => FBETypeConst;

        // Clone the final model
        public override com.chronoxor.FBE.FinalModelValueType<Order> Clone() { return new FinalModelOrder(_buffer, _offset); }

        // Check if the struct value is valid
        public override long Verify()
        {
            _buffer.Shift(FBEOffset);
            long fbeResult = VerifyFields();
            _buffer.Unshift(FBEOffset);
            return fbeResult;
        }

        // Check if the struct fields are valid
        public long VerifyFields()
        {
            long fbeCurrentOffset = 0;
            long fbeFieldSize;

            id.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = id.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            symbol.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = symbol.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            side.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = side.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            type.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = type.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            price.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = price.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            volume.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = volume.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            return fbeCurrentOffset;
        }

        // Get the struct value
        public override long Get(out Order fbeValue)
        {
            _buffer.Shift(FBEOffset);
            long fbeSize = GetFields(out fbeValue);
            _buffer.Unshift(FBEOffset);
            return fbeSize;
        }

        // Get the struct fields values
        public long GetFields(out Order fbeValue)
        {
            long fbeCurrentOffset = 0;
            long fbeCurrentSize = 0;
            long fbeFieldSize;

            fbeValue = Order.Default;

            id.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = id.Get(out fbeValue.id);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            symbol.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = symbol.Get(out fbeValue.symbol);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            side.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = side.Get(out fbeValue.side);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            type.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = type.Get(out fbeValue.type);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            price.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = price.Get(out fbeValue.price);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            volume.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = volume.Get(out fbeValue.volume);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            return fbeCurrentSize;
        }

        // Set the struct value
        public override long Set(Order fbeValue)
        {
            _buffer.Shift(FBEOffset);
            long fbeResult = SetFields(fbeValue);
            _buffer.Unshift(FBEOffset);
            return fbeResult;
        }

        // Set the struct fields values
        public long SetFields(Order fbeValue)
        {
            long fbeCurrentOffset = 0;
            long fbeCurrentSize = 0;
            long fbeFieldSize;

            id.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = id.Set(fbeValue.id);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            symbol.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = symbol.Set(fbeValue.symbol);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            side.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = side.Set(fbeValue.side);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            type.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = type.Set(fbeValue.type);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            price.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = price.Set(fbeValue.price);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            volume.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = volume.Set(fbeValue.volume);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            return fbeCurrentSize;
        }
    }

} // namespace com.chronoxor.proto.FBE

namespace com.chronoxor.proto.FBE {

    using global::com.chronoxor.proto;

    // Fast Binary Encoding Order final model
    public class OrderFinalModel : com.chronoxor.FBE.Model
    {
        private readonly FinalModelOrder _model;

        public OrderFinalModel() { _model = new FinalModelOrder(Buffer, 8); }
        public OrderFinalModel(com.chronoxor.FBE.Buffer buffer) : base(buffer) { _model = new FinalModelOrder(Buffer, 8); }

        // Get the model type
        public const long FBETypeConst = FinalModelOrder.FBETypeConst;
        public long FBEType => FBETypeConst;

        // Check if the struct value is valid
        public bool Verify()
        {
            if ((Buffer.Offset + _model.FBEOffset) > Buffer.Size)
                return false;

            long fbeStructSize = ReadUInt32(_model.FBEOffset - 8);
            long fbeStructType = ReadUInt32(_model.FBEOffset - 4);
            if ((fbeStructSize <= 0) || (fbeStructType != FBEType))
                return false;

            return ((8 + _model.Verify()) == fbeStructSize);
        }

        // Serialize the struct value
        public long Serialize(Order value)
        {
            long fbeInitialSize = Buffer.Size;

            uint fbeStructType = (uint)FBEType;
            uint fbeStructSize = (uint)(8 + _model.FBEAllocationSize(value));
            uint fbeStructOffset = (uint)(Buffer.Allocate(fbeStructSize) - Buffer.Offset);
            Debug.Assert(((Buffer.Offset + fbeStructOffset + fbeStructSize) <= Buffer.Size), "Model is broken!");
            if ((Buffer.Offset + fbeStructOffset + fbeStructSize) > Buffer.Size)
                return 0;

            fbeStructSize = (uint)(8 + _model.Set(value));
            Buffer.Resize(fbeInitialSize + fbeStructSize);

            Write(_model.FBEOffset - 8, fbeStructSize);
            Write(_model.FBEOffset - 4, fbeStructType);

            return fbeStructSize;
        }

        // Deserialize the struct value
        public long Deserialize(out Order value)
        {
            Debug.Assert(((Buffer.Offset + _model.FBEOffset) <= Buffer.Size), "Model is broken!");
            if ((Buffer.Offset + _model.FBEOffset) > Buffer.Size)
            {
                value = Order.Default;
                return 0;
            }

            long fbeStructSize = ReadUInt32(_model.FBEOffset - 8);
            long fbeStructType = ReadUInt32(_model.FBEOffset - 4);
            Debug.Assert(((fbeStructSize > 0) && (fbeStructType == FBEType)), "Model is broken!");
            if ((fbeStructSize <= 0) || (fbeStructType != FBEType))
            {
                value = Order.Default;
                return 8;
            }

            return 8 + _model.Get(out value);
        }

        // Move to the next struct value
        public void Next(long prev)
        {
            _model.FBEShift(prev);
        }
    }

} // namespace com.chronoxor.proto.FBE

namespace com.chronoxor.proto {

    public struct Balance : IComparable, IComparable<Balance>, IEquatable<Balance>
    {
        public string currency;
        public double amount;

        public const long FBETypeConst = 2;
        #if UTF8JSON
        [IgnoreDataMember]
        #else
        [JsonIgnore]
        #endif
        public long FBEType => FBETypeConst;

        public static Balance Default => new Balance
        {
            currency = ""
            , amount = (double)0.0D
        };

        public Balance(string currency, double amount)
        {
            this.currency = currency;
            this.amount = amount;
        }

        public Balance Clone()
        {
            // Serialize the struct to the FBE stream
            var writer = new com.chronoxor.proto.FBE.BalanceModel();
            writer.Serialize(this);

            // Deserialize the struct from the FBE stream
            var reader = new com.chronoxor.proto.FBE.BalanceModel();
            reader.Attach(writer.Buffer);
            reader.Deserialize(out var result);
            return result;
        }

        public int CompareTo(object other)
        {
            int result = 0;
            result = currency.CompareTo(((Balance)other).currency);
            if (result != 0)
                return result;
            return result;
        }

        public int CompareTo(Balance other)
        {
            int result = 0;
            result = currency.CompareTo(other.currency);
            if (result != 0)
                return result;
            return result;
        }

        public override bool Equals(object other)
        {
            if (!(other is Balance))
                return false;
            if (!currency.Equals(((Balance)other).currency))
                return false;
            return true;
        }

        public bool Equals(Balance other)
        {
            if (!currency.Equals(other.currency))
                return false;
            return true;
        }

        public override int GetHashCode()
        {
            int hash = 17;
            hash = hash * 31 + currency.GetHashCode();
            return hash;
        }

        public static bool operator==(Balance lhs, Balance rhs) => lhs.Equals(rhs);
        public static bool operator!=(Balance lhs, Balance rhs) => !(lhs == rhs);

        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("Balance(");
            sb.Append("currency="); if (currency != null) sb.Append("\"").Append(currency).Append("\""); else sb.Append("null");
            sb.Append(",amount="); sb.Append(amount.ToString(CultureInfo.InvariantCulture));
            sb.Append(")");
            return sb.ToString();
        }

        public string ToJson()
        {
            var json = com.chronoxor.FBE.Json.ToJson(this);
            return json;
        }

        public static Balance FromJson(string json)
        {
            var result = com.chronoxor.FBE.Json.FromJson<Balance>(json);
            return result;
        }

        public static com.chronoxor.FBE.FieldModelValueType<Balance> CreateFieldModel(com.chronoxor.FBE.Buffer buffer, long offset) { return new proto.FBE.FieldModelBalance(buffer, offset); }
    }

} // namespace com.chronoxor.proto

namespace com.chronoxor.proto.FBE {

    using global::com.chronoxor.proto;

    // Fast Binary Encoding Balance field model
    public class FieldModelBalance : com.chronoxor.FBE.FieldModelValueType<Balance>
    {
        public readonly com.chronoxor.FBE.FieldModelReferenceType<string> currency;
        public readonly com.chronoxor.FBE.FieldModelValueType<double> amount;

        public FieldModelBalance(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset)
        {
            currency = com.chronoxor.FBE.FieldModelReferenceType<string>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.STRING, buffer, 4 + 4);
            amount = com.chronoxor.FBE.FieldModelValueType<double>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.DOUBLE, buffer, currency.FBEOffset + currency.FBESize);
        }

        // Get the field size
        public override long FBESize => 4;
        // Get the field body size
        public long FBEBody
        {
            get
            {
                long fbeResult = 4 + 4
                    + currency.FBESize
                    + amount.FBESize
                    ;
                return fbeResult;
            }
        }
        // Get the field extra size
        public override long FBEExtra
        {
            get
            {
                if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                    return 0;

                uint fbeStructOffset = ReadUInt32(FBEOffset);
                if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4) > _buffer.Size))
                    return 0;

                _buffer.Shift(fbeStructOffset);

                long fbeResult = FBEBody
                    + currency.FBEExtra
                    + amount.FBEExtra
                    ;

                _buffer.Unshift(fbeStructOffset);

                return fbeResult;
            }
        }
        // Get the field type
        public const long FBETypeConst = 2;
        public long FBEType => FBETypeConst;

        // Clone the field model
        public override com.chronoxor.FBE.FieldModelValueType<Balance> Clone() { return new FieldModelBalance(_buffer, _offset); }

        // Check if the struct value is valid
        public override bool Verify() { return Verify(true); }
        public bool Verify(bool fbeVerifyType)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return true;

            uint fbeStructOffset = ReadUInt32(FBEOffset);
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
                return false;

            uint fbeStructSize = ReadUInt32(fbeStructOffset);
            if (fbeStructSize < (4 + 4))
                return false;

            uint fbeStructType = ReadUInt32(fbeStructOffset + 4);
            if (fbeVerifyType && (fbeStructType != FBEType))
                return false;

            _buffer.Shift(fbeStructOffset);
            bool fbeResult = VerifyFields(fbeStructSize);
            _buffer.Unshift(fbeStructOffset);
            return fbeResult;
        }

        // Check if the struct fields are valid
        public bool VerifyFields(long fbeStructSize)
        {
            long fbeCurrentSize = 4 + 4;

            if ((fbeCurrentSize + currency.FBESize) > fbeStructSize)
                return true;
            if (!currency.Verify())
                return false;
            fbeCurrentSize += currency.FBESize;

            if ((fbeCurrentSize + amount.FBESize) > fbeStructSize)
                return true;
            if (!amount.Verify())
                return false;
            fbeCurrentSize += amount.FBESize;

            return true;
        }

        // Get the struct value (begin phase)
        public long GetBegin()
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            uint fbeStructOffset = ReadUInt32(FBEOffset);
            Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + 4 + 4) <= _buffer.Size)), "Model is broken!");
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
                return 0;

            uint fbeStructSize = ReadUInt32(fbeStructOffset);
            Debug.Assert((fbeStructSize >= (4 + 4)), "Model is broken!");
            if (fbeStructSize < (4 + 4))
                return 0;

            _buffer.Shift(fbeStructOffset);
            return fbeStructOffset;
        }

        // Get the struct value (end phase)
        public void GetEnd(long fbeBegin)
        {
            _buffer.Unshift(fbeBegin);
        }

        // Get the struct value
        public override void Get(out Balance fbeValue) { Get(out fbeValue, Balance.Default); }
        public override void Get(out Balance fbeValue, Balance defaults)
        {
            long fbeBegin = GetBegin();
            if (fbeBegin == 0)
            {
                fbeValue = defaults;
                return;
            }

            uint fbeStructSize = ReadUInt32(0);
            GetFields(out fbeValue, fbeStructSize);
            GetEnd(fbeBegin);
        }

        // Get the struct fields values
        public void GetFields(out Balance fbeValue, long fbeStructSize)
        {
            long fbeCurrentSize = 4 + 4;

            fbeValue = Balance.Default;

            if ((fbeCurrentSize + currency.FBESize) <= fbeStructSize)
                currency.Get(out fbeValue.currency);
            else
                fbeValue.currency = "";
            fbeCurrentSize += currency.FBESize;

            if ((fbeCurrentSize + amount.FBESize) <= fbeStructSize)
                amount.Get(out fbeValue.amount, (double)0.0D);
            else
                fbeValue.amount = (double)0.0D;
            fbeCurrentSize += amount.FBESize;
        }

        // Set the struct value (begin phase)
        public long SetBegin()
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            uint fbeStructSize = (uint)FBEBody;
            uint fbeStructOffset = (uint)(_buffer.Allocate(fbeStructSize) - _buffer.Offset);
            Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + fbeStructSize) <= _buffer.Size)), "Model is broken!");
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + fbeStructSize) > _buffer.Size))
                return 0;

            Write(FBEOffset, fbeStructOffset);
            Write(fbeStructOffset, fbeStructSize);
            Write(fbeStructOffset + 4, (uint)FBEType);

            _buffer.Shift(fbeStructOffset);
            return fbeStructOffset;
        }

        // Set the struct value (end phase)
        public void SetEnd(long fbeBegin)
        {
            _buffer.Unshift(fbeBegin);
        }

        // Set the struct value
        public override void Set(Balance fbeValue)
        {
            long fbeBegin = SetBegin();
            if (fbeBegin == 0)
                return;

            SetFields(fbeValue);
            SetEnd(fbeBegin);
        }

        // Set the struct fields values
        public void SetFields(Balance fbeValue)
        {
            currency.Set(fbeValue.currency);
            amount.Set(fbeValue.amount);
        }
    }

} // namespace com.chronoxor.proto.FBE

namespace com.chronoxor.proto.FBE {

    using global::com.chronoxor.proto;

    // Fast Binary Encoding Balance model
    public class BalanceModel : com.chronoxor.FBE.Model
    {
        public readonly FieldModelBalance model;

        public BalanceModel() { model = new FieldModelBalance(Buffer, 4); }
        public BalanceModel(com.chronoxor.FBE.Buffer buffer) : base(buffer) { model = new FieldModelBalance(Buffer, 4); }

        // Get the model size
        public long FBESize => model.FBESize + model.FBEExtra;
        // Get the model type
        public const long FBETypeConst = FieldModelBalance.FBETypeConst;
        public long FBEType => FBETypeConst;

        // Check if the struct value is valid
        public bool Verify()
        {
            if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
                return false;

            uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
            if (fbeFullSize < model.FBESize)
                return false;

            return model.Verify();
        }

        // Create a new model (begin phase)
        public long CreateBegin()
        {
            long fbeBegin = Buffer.Allocate(4 + model.FBESize);
            return fbeBegin;
        }

        // Create a new model (end phase)
        public long CreateEnd(long fbeBegin)
        {
            long fbeEnd = Buffer.Size;
            uint fbeFullSize = (uint)(fbeEnd - fbeBegin);
            Write(model.FBEOffset - 4, fbeFullSize);
            return fbeFullSize;
        }

        // Serialize the struct value
        public long Serialize(Balance value)
        {
            long fbeBegin = CreateBegin();
            model.Set(value);
            long fbeFullSize = CreateEnd(fbeBegin);
            return fbeFullSize;
        }

        // Deserialize the struct value
        public long Deserialize(out Balance value)
        {
            if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
            {
                value = Balance.Default;
                return 0;
            }

            uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
            Debug.Assert((fbeFullSize >= model.FBESize), "Model is broken!");
            if (fbeFullSize < model.FBESize)
            {
                value = Balance.Default;
                return 0;
            }

            model.Get(out value);
            return fbeFullSize;
        }

        // Move to the next struct value
        public void Next(long prev)
        {
            model.FBEShift(prev);
        }
    }

} // namespace com.chronoxor.proto.FBE

namespace com.chronoxor.proto.FBE {

    using global::com.chronoxor.proto;

    // Fast Binary Encoding Balance final model
    public class FinalModelBalance : com.chronoxor.FBE.FinalModelValueType<Balance>
    {
        public readonly com.chronoxor.FBE.FinalModelReferenceType<string> currency;
        public readonly com.chronoxor.FBE.FinalModelValueType<double> amount;

        public FinalModelBalance(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset)
        {
            currency = com.chronoxor.FBE.FinalModelReferenceType<string>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.STRING, buffer, 0);
            amount = com.chronoxor.FBE.FinalModelValueType<double>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.DOUBLE, buffer, 0);
        }

        // Get the allocation size
        public override long FBEAllocationSize(Balance fbeValue)
        {
            long fbeResult = 0
                + currency.FBEAllocationSize(fbeValue.currency)
                + amount.FBEAllocationSize(fbeValue.amount)
                ;
            return fbeResult;
        }

        // Get the final type
        public const long FBETypeConst = 2;
        public long FBEType => FBETypeConst;

        // Clone the final model
        public override com.chronoxor.FBE.FinalModelValueType<Balance> Clone() { return new FinalModelBalance(_buffer, _offset); }

        // Check if the struct value is valid
        public override long Verify()
        {
            _buffer.Shift(FBEOffset);
            long fbeResult = VerifyFields();
            _buffer.Unshift(FBEOffset);
            return fbeResult;
        }

        // Check if the struct fields are valid
        public long VerifyFields()
        {
            long fbeCurrentOffset = 0;
            long fbeFieldSize;

            currency.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = currency.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            amount.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = amount.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            return fbeCurrentOffset;
        }

        // Get the struct value
        public override long Get(out Balance fbeValue)
        {
            _buffer.Shift(FBEOffset);
            long fbeSize = GetFields(out fbeValue);
            _buffer.Unshift(FBEOffset);
            return fbeSize;
        }

        // Get the struct fields values
        public long GetFields(out Balance fbeValue)
        {
            long fbeCurrentOffset = 0;
            long fbeCurrentSize = 0;
            long fbeFieldSize;

            fbeValue = Balance.Default;

            currency.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = currency.Get(out fbeValue.currency);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            amount.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = amount.Get(out fbeValue.amount);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            return fbeCurrentSize;
        }

        // Set the struct value
        public override long Set(Balance fbeValue)
        {
            _buffer.Shift(FBEOffset);
            long fbeResult = SetFields(fbeValue);
            _buffer.Unshift(FBEOffset);
            return fbeResult;
        }

        // Set the struct fields values
        public long SetFields(Balance fbeValue)
        {
            long fbeCurrentOffset = 0;
            long fbeCurrentSize = 0;
            long fbeFieldSize;

            currency.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = currency.Set(fbeValue.currency);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            amount.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = amount.Set(fbeValue.amount);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            return fbeCurrentSize;
        }
    }

} // namespace com.chronoxor.proto.FBE

namespace com.chronoxor.proto.FBE {

    using global::com.chronoxor.proto;

    // Fast Binary Encoding Balance final model
    public class BalanceFinalModel : com.chronoxor.FBE.Model
    {
        private readonly FinalModelBalance _model;

        public BalanceFinalModel() { _model = new FinalModelBalance(Buffer, 8); }
        public BalanceFinalModel(com.chronoxor.FBE.Buffer buffer) : base(buffer) { _model = new FinalModelBalance(Buffer, 8); }

        // Get the model type
        public const long FBETypeConst = FinalModelBalance.FBETypeConst;
        public long FBEType => FBETypeConst;

        // Check if the struct value is valid
        public bool Verify()
        {
            if ((Buffer.Offset + _model.FBEOffset) > Buffer.Size)
                return false;

            long fbeStructSize = ReadUInt32(_model.FBEOffset - 8);
            long fbeStructType = ReadUInt32(_model.FBEOffset - 4);
            if ((fbeStructSize <= 0) || (fbeStructType != FBEType))
                return false;

            return ((8 + _model.Verify()) == fbeStructSize);
        }

        // Serialize the struct value
        public long Serialize(Balance value)
        {
            long fbeInitialSize = Buffer.Size;

            uint fbeStructType = (uint)FBEType;
            uint fbeStructSize = (uint)(8 + _model.FBEAllocationSize(value));
            uint fbeStructOffset = (uint)(Buffer.Allocate(fbeStructSize) - Buffer.Offset);
            Debug.Assert(((Buffer.Offset + fbeStructOffset + fbeStructSize) <= Buffer.Size), "Model is broken!");
            if ((Buffer.Offset + fbeStructOffset + fbeStructSize) > Buffer.Size)
                return 0;

            fbeStructSize = (uint)(8 + _model.Set(value));
            Buffer.Resize(fbeInitialSize + fbeStructSize);

            Write(_model.FBEOffset - 8, fbeStructSize);
            Write(_model.FBEOffset - 4, fbeStructType);

            return fbeStructSize;
        }

        // Deserialize the struct value
        public long Deserialize(out Balance value)
        {
            Debug.Assert(((Buffer.Offset + _model.FBEOffset) <= Buffer.Size), "Model is broken!");
            if ((Buffer.Offset + _model.FBEOffset) > Buffer.Size)
            {
                value = Balance.Default;
                return 0;
            }

            long fbeStructSize = ReadUInt32(_model.FBEOffset - 8);
            long fbeStructType = ReadUInt32(_model.FBEOffset - 4);
            Debug.Assert(((fbeStructSize > 0) && (fbeStructType == FBEType)), "Model is broken!");
            if ((fbeStructSize <= 0) || (fbeStructType != FBEType))
            {
                value = Balance.Default;
                return 8;
            }

            return 8 + _model.Get(out value);
        }

        // Move to the next struct value
        public void Next(long prev)
        {
            _model.FBEShift(prev);
        }
    }

} // namespace com.chronoxor.proto.FBE

namespace com.chronoxor.proto {

    public struct Account : IComparable, IComparable<Account>, IEquatable<Account>
    {
        public int id;
        public string name;
        public State state;
        public Balance wallet;
        public Balance? asset;
        public List<Order> orders;

        public const long FBETypeConst = 3;
        #if UTF8JSON
        [IgnoreDataMember]
        #else
        [JsonIgnore]
        #endif
        public long FBEType => FBETypeConst;

        public static Account Default => new Account
        {
            id = (int)0
            , name = ""
            , state = global::com.chronoxor.proto.State.initialized | global::com.chronoxor.proto.State.bad
            , wallet = global::com.chronoxor.proto.Balance.Default
            , asset = null
            , orders = new List<Order>()
        };

        public Account(int id, string name, State state, Balance wallet, Balance? asset, List<Order> orders)
        {
            this.id = id;
            this.name = name;
            this.state = state;
            this.wallet = wallet;
            this.asset = asset;
            this.orders = orders;
        }

        public Account Clone()
        {
            // Serialize the struct to the FBE stream
            var writer = new com.chronoxor.proto.FBE.AccountModel();
            writer.Serialize(this);

            // Deserialize the struct from the FBE stream
            var reader = new com.chronoxor.proto.FBE.AccountModel();
            reader.Attach(writer.Buffer);
            reader.Deserialize(out var result);
            return result;
        }

        public int CompareTo(object other)
        {
            int result = 0;
            result = id.CompareTo(((Account)other).id);
            if (result != 0)
                return result;
            return result;
        }

        public int CompareTo(Account other)
        {
            int result = 0;
            result = id.CompareTo(other.id);
            if (result != 0)
                return result;
            return result;
        }

        public override bool Equals(object other)
        {
            if (!(other is Account))
                return false;
            if (!id.Equals(((Account)other).id))
                return false;
            return true;
        }

        public bool Equals(Account other)
        {
            if (!id.Equals(other.id))
                return false;
            return true;
        }

        public override int GetHashCode()
        {
            int hash = 17;
            hash = hash * 31 + id.GetHashCode();
            return hash;
        }

        public static bool operator==(Account lhs, Account rhs) => lhs.Equals(rhs);
        public static bool operator!=(Account lhs, Account rhs) => !(lhs == rhs);

        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("Account(");
            sb.Append("id="); sb.Append(id);
            sb.Append(",name="); if (name != null) sb.Append("\"").Append(name).Append("\""); else sb.Append("null");
            sb.Append(",state="); sb.Append(state);
            sb.Append(",wallet="); sb.Append(wallet);
            sb.Append(",asset="); if (asset != null) sb.Append(asset); else sb.Append("null");
            if (orders != null)
            {
                bool first = true;
                sb.Append(",orders=[").Append(orders.Count).Append("][");
                foreach (var item in orders)
                {
                    sb.Append(first ? "" : ",").Append(item);
                    first = false;
                }
                sb.Append("]");
            }
            else
            {
                sb.Append(",orders=[0][]");
            }
            sb.Append(")");
            return sb.ToString();
        }

        public string ToJson()
        {
            var json = com.chronoxor.FBE.Json.ToJson(this);
            return json;
        }

        public static Account FromJson(string json)
        {
            var result = com.chronoxor.FBE.Json.FromJson<Account>(json);
            return result;
        }

        public static com.chronoxor.FBE.FieldModelValueType<Account> CreateFieldModel(com.chronoxor.FBE.Buffer buffer, long offset) { return new proto.FBE.FieldModelAccount(buffer, offset); }
    }

} // namespace com.chronoxor.proto

namespace com.chronoxor.proto.FBE {

    using global::com.chronoxor.proto;

    // Fast Binary Encoding Account field model
    public class FieldModelAccount : com.chronoxor.FBE.FieldModelValueType<Account>
    {
        public readonly com.chronoxor.FBE.FieldModelValueType<int> id;
        public readonly com.chronoxor.FBE.FieldModelReferenceType<string> name;
        public readonly com.chronoxor.proto.FBE.FieldModelState state;
        public readonly com.chronoxor.proto.FBE.FieldModelBalance wallet;
        public readonly com.chronoxor.FBE.FieldModelOptionalValueType<Balance, com.chronoxor.proto.FBE.FieldModelBalance> asset;
        public readonly com.chronoxor.FBE.FieldModelVectorValueType<Order, com.chronoxor.proto.FBE.FieldModelOrder> orders;

        public FieldModelAccount(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset)
        {
            id = com.chronoxor.FBE.FieldModelValueType<int>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.INT32, buffer, 4 + 4);
            name = com.chronoxor.FBE.FieldModelReferenceType<string>.CreateFieldModel(com.chronoxor.FBE.BaseTypes.STRING, buffer, id.FBEOffset + id.FBESize);
            state = new com.chronoxor.proto.FBE.FieldModelState(buffer, name.FBEOffset + name.FBESize);
            wallet = new com.chronoxor.proto.FBE.FieldModelBalance(buffer, state.FBEOffset + state.FBESize);
            asset = new com.chronoxor.FBE.FieldModelOptionalValueType<Balance, com.chronoxor.proto.FBE.FieldModelBalance>(new com.chronoxor.proto.FBE.FieldModelBalance(buffer, wallet.FBEOffset + wallet.FBESize), buffer, wallet.FBEOffset + wallet.FBESize);
            orders = new com.chronoxor.FBE.FieldModelVectorValueType<Order, com.chronoxor.proto.FBE.FieldModelOrder>(new com.chronoxor.proto.FBE.FieldModelOrder(buffer, asset.FBEOffset + asset.FBESize), buffer, asset.FBEOffset + asset.FBESize);
        }

        // Get the field size
        public override long FBESize => 4;
        // Get the field body size
        public long FBEBody
        {
            get
            {
                long fbeResult = 4 + 4
                    + id.FBESize
                    + name.FBESize
                    + state.FBESize
                    + wallet.FBESize
                    + asset.FBESize
                    + orders.FBESize
                    ;
                return fbeResult;
            }
        }
        // Get the field extra size
        public override long FBEExtra
        {
            get
            {
                if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                    return 0;

                uint fbeStructOffset = ReadUInt32(FBEOffset);
                if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4) > _buffer.Size))
                    return 0;

                _buffer.Shift(fbeStructOffset);

                long fbeResult = FBEBody
                    + id.FBEExtra
                    + name.FBEExtra
                    + state.FBEExtra
                    + wallet.FBEExtra
                    + asset.FBEExtra
                    + orders.FBEExtra
                    ;

                _buffer.Unshift(fbeStructOffset);

                return fbeResult;
            }
        }
        // Get the field type
        public const long FBETypeConst = 3;
        public long FBEType => FBETypeConst;

        // Clone the field model
        public override com.chronoxor.FBE.FieldModelValueType<Account> Clone() { return new FieldModelAccount(_buffer, _offset); }

        // Check if the struct value is valid
        public override bool Verify() { return Verify(true); }
        public bool Verify(bool fbeVerifyType)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return true;

            uint fbeStructOffset = ReadUInt32(FBEOffset);
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
                return false;

            uint fbeStructSize = ReadUInt32(fbeStructOffset);
            if (fbeStructSize < (4 + 4))
                return false;

            uint fbeStructType = ReadUInt32(fbeStructOffset + 4);
            if (fbeVerifyType && (fbeStructType != FBEType))
                return false;

            _buffer.Shift(fbeStructOffset);
            bool fbeResult = VerifyFields(fbeStructSize);
            _buffer.Unshift(fbeStructOffset);
            return fbeResult;
        }

        // Check if the struct fields are valid
        public bool VerifyFields(long fbeStructSize)
        {
            long fbeCurrentSize = 4 + 4;

            if ((fbeCurrentSize + id.FBESize) > fbeStructSize)
                return true;
            if (!id.Verify())
                return false;
            fbeCurrentSize += id.FBESize;

            if ((fbeCurrentSize + name.FBESize) > fbeStructSize)
                return true;
            if (!name.Verify())
                return false;
            fbeCurrentSize += name.FBESize;

            if ((fbeCurrentSize + state.FBESize) > fbeStructSize)
                return true;
            if (!state.Verify())
                return false;
            fbeCurrentSize += state.FBESize;

            if ((fbeCurrentSize + wallet.FBESize) > fbeStructSize)
                return true;
            if (!wallet.Verify())
                return false;
            fbeCurrentSize += wallet.FBESize;

            if ((fbeCurrentSize + asset.FBESize) > fbeStructSize)
                return true;
            if (!asset.Verify())
                return false;
            fbeCurrentSize += asset.FBESize;

            if ((fbeCurrentSize + orders.FBESize) > fbeStructSize)
                return true;
            if (!orders.Verify())
                return false;
            fbeCurrentSize += orders.FBESize;

            return true;
        }

        // Get the struct value (begin phase)
        public long GetBegin()
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            uint fbeStructOffset = ReadUInt32(FBEOffset);
            Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + 4 + 4) <= _buffer.Size)), "Model is broken!");
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
                return 0;

            uint fbeStructSize = ReadUInt32(fbeStructOffset);
            Debug.Assert((fbeStructSize >= (4 + 4)), "Model is broken!");
            if (fbeStructSize < (4 + 4))
                return 0;

            _buffer.Shift(fbeStructOffset);
            return fbeStructOffset;
        }

        // Get the struct value (end phase)
        public void GetEnd(long fbeBegin)
        {
            _buffer.Unshift(fbeBegin);
        }

        // Get the struct value
        public override void Get(out Account fbeValue) { Get(out fbeValue, Account.Default); }
        public override void Get(out Account fbeValue, Account defaults)
        {
            long fbeBegin = GetBegin();
            if (fbeBegin == 0)
            {
                fbeValue = defaults;
                return;
            }

            uint fbeStructSize = ReadUInt32(0);
            GetFields(out fbeValue, fbeStructSize);
            GetEnd(fbeBegin);
        }

        // Get the struct fields values
        public void GetFields(out Account fbeValue, long fbeStructSize)
        {
            long fbeCurrentSize = 4 + 4;

            fbeValue = Account.Default;

            if ((fbeCurrentSize + id.FBESize) <= fbeStructSize)
                id.Get(out fbeValue.id);
            else
                fbeValue.id = (int)0;
            fbeCurrentSize += id.FBESize;

            if ((fbeCurrentSize + name.FBESize) <= fbeStructSize)
                name.Get(out fbeValue.name);
            else
                fbeValue.name = "";
            fbeCurrentSize += name.FBESize;

            if ((fbeCurrentSize + state.FBESize) <= fbeStructSize)
                state.Get(out fbeValue.state, global::com.chronoxor.proto.State.initialized | global::com.chronoxor.proto.State.bad);
            else
                fbeValue.state = global::com.chronoxor.proto.State.initialized | global::com.chronoxor.proto.State.bad;
            fbeCurrentSize += state.FBESize;

            if ((fbeCurrentSize + wallet.FBESize) <= fbeStructSize)
                wallet.Get(out fbeValue.wallet);
            else
                fbeValue.wallet = global::com.chronoxor.proto.Balance.Default;
            fbeCurrentSize += wallet.FBESize;

            if ((fbeCurrentSize + asset.FBESize) <= fbeStructSize)
                asset.Get(out fbeValue.asset);
            else
                fbeValue.asset = null;
            fbeCurrentSize += asset.FBESize;

            if ((fbeCurrentSize + orders.FBESize) <= fbeStructSize)
                orders.Get(ref fbeValue.orders);
            else
                fbeValue.orders.Clear();
            fbeCurrentSize += orders.FBESize;
        }

        // Set the struct value (begin phase)
        public long SetBegin()
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            uint fbeStructSize = (uint)FBEBody;
            uint fbeStructOffset = (uint)(_buffer.Allocate(fbeStructSize) - _buffer.Offset);
            Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + fbeStructSize) <= _buffer.Size)), "Model is broken!");
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + fbeStructSize) > _buffer.Size))
                return 0;

            Write(FBEOffset, fbeStructOffset);
            Write(fbeStructOffset, fbeStructSize);
            Write(fbeStructOffset + 4, (uint)FBEType);

            _buffer.Shift(fbeStructOffset);
            return fbeStructOffset;
        }

        // Set the struct value (end phase)
        public void SetEnd(long fbeBegin)
        {
            _buffer.Unshift(fbeBegin);
        }

        // Set the struct value
        public override void Set(Account fbeValue)
        {
            long fbeBegin = SetBegin();
            if (fbeBegin == 0)
                return;

            SetFields(fbeValue);
            SetEnd(fbeBegin);
        }

        // Set the struct fields values
        public void SetFields(Account fbeValue)
        {
            id.Set(fbeValue.id);
            name.Set(fbeValue.name);
            state.Set(fbeValue.state);
            wallet.Set(fbeValue.wallet);
            asset.Set(fbeValue.asset);
            orders.Set(fbeValue.orders);
        }
    }

} // namespace com.chronoxor.proto.FBE

namespace com.chronoxor.proto.FBE {

    using global::com.chronoxor.proto;

    // Fast Binary Encoding Account model
    public class AccountModel : com.chronoxor.FBE.Model
    {
        public readonly FieldModelAccount model;

        public AccountModel() { model = new FieldModelAccount(Buffer, 4); }
        public AccountModel(com.chronoxor.FBE.Buffer buffer) : base(buffer) { model = new FieldModelAccount(Buffer, 4); }

        // Get the model size
        public long FBESize => model.FBESize + model.FBEExtra;
        // Get the model type
        public const long FBETypeConst = FieldModelAccount.FBETypeConst;
        public long FBEType => FBETypeConst;

        // Check if the struct value is valid
        public bool Verify()
        {
            if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
                return false;

            uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
            if (fbeFullSize < model.FBESize)
                return false;

            return model.Verify();
        }

        // Create a new model (begin phase)
        public long CreateBegin()
        {
            long fbeBegin = Buffer.Allocate(4 + model.FBESize);
            return fbeBegin;
        }

        // Create a new model (end phase)
        public long CreateEnd(long fbeBegin)
        {
            long fbeEnd = Buffer.Size;
            uint fbeFullSize = (uint)(fbeEnd - fbeBegin);
            Write(model.FBEOffset - 4, fbeFullSize);
            return fbeFullSize;
        }

        // Serialize the struct value
        public long Serialize(Account value)
        {
            long fbeBegin = CreateBegin();
            model.Set(value);
            long fbeFullSize = CreateEnd(fbeBegin);
            return fbeFullSize;
        }

        // Deserialize the struct value
        public long Deserialize(out Account value)
        {
            if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
            {
                value = Account.Default;
                return 0;
            }

            uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
            Debug.Assert((fbeFullSize >= model.FBESize), "Model is broken!");
            if (fbeFullSize < model.FBESize)
            {
                value = Account.Default;
                return 0;
            }

            model.Get(out value);
            return fbeFullSize;
        }

        // Move to the next struct value
        public void Next(long prev)
        {
            model.FBEShift(prev);
        }
    }

} // namespace com.chronoxor.proto.FBE

namespace com.chronoxor.proto.FBE {

    using global::com.chronoxor.proto;

    // Fast Binary Encoding Account final model
    public class FinalModelAccount : com.chronoxor.FBE.FinalModelValueType<Account>
    {
        public readonly com.chronoxor.FBE.FinalModelValueType<int> id;
        public readonly com.chronoxor.FBE.FinalModelReferenceType<string> name;
        public readonly com.chronoxor.proto.FBE.FinalModelState state;
        public readonly com.chronoxor.proto.FBE.FinalModelBalance wallet;
        public readonly com.chronoxor.FBE.FinalModelOptionalValueType<Balance, com.chronoxor.proto.FBE.FinalModelBalance> asset;
        public readonly com.chronoxor.FBE.FinalModelVectorValueType<Order, com.chronoxor.proto.FBE.FinalModelOrder> orders;

        public FinalModelAccount(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset)
        {
            id = com.chronoxor.FBE.FinalModelValueType<int>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.INT32, buffer, 0);
            name = com.chronoxor.FBE.FinalModelReferenceType<string>.CreateFinalModel(com.chronoxor.FBE.BaseTypes.STRING, buffer, 0);
            state = new com.chronoxor.proto.FBE.FinalModelState(buffer, 0);
            wallet = new com.chronoxor.proto.FBE.FinalModelBalance(buffer, 0);
            asset = new com.chronoxor.FBE.FinalModelOptionalValueType<Balance, com.chronoxor.proto.FBE.FinalModelBalance>(new com.chronoxor.proto.FBE.FinalModelBalance(buffer, 0), buffer, 0);
            orders = new com.chronoxor.FBE.FinalModelVectorValueType<Order, com.chronoxor.proto.FBE.FinalModelOrder>(new com.chronoxor.proto.FBE.FinalModelOrder(buffer, 0), buffer, 0);
        }

        // Get the allocation size
        public override long FBEAllocationSize(Account fbeValue)
        {
            long fbeResult = 0
                + id.FBEAllocationSize(fbeValue.id)
                + name.FBEAllocationSize(fbeValue.name)
                + state.FBEAllocationSize(fbeValue.state)
                + wallet.FBEAllocationSize(fbeValue.wallet)
                + asset.FBEAllocationSize(fbeValue.asset)
                + orders.FBEAllocationSize(fbeValue.orders)
                ;
            return fbeResult;
        }

        // Get the final type
        public const long FBETypeConst = 3;
        public long FBEType => FBETypeConst;

        // Clone the final model
        public override com.chronoxor.FBE.FinalModelValueType<Account> Clone() { return new FinalModelAccount(_buffer, _offset); }

        // Check if the struct value is valid
        public override long Verify()
        {
            _buffer.Shift(FBEOffset);
            long fbeResult = VerifyFields();
            _buffer.Unshift(FBEOffset);
            return fbeResult;
        }

        // Check if the struct fields are valid
        public long VerifyFields()
        {
            long fbeCurrentOffset = 0;
            long fbeFieldSize;

            id.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = id.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            name.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = name.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            state.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = state.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            wallet.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = wallet.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            asset.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = asset.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            orders.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = orders.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            return fbeCurrentOffset;
        }

        // Get the struct value
        public override long Get(out Account fbeValue)
        {
            _buffer.Shift(FBEOffset);
            long fbeSize = GetFields(out fbeValue);
            _buffer.Unshift(FBEOffset);
            return fbeSize;
        }

        // Get the struct fields values
        public long GetFields(out Account fbeValue)
        {
            long fbeCurrentOffset = 0;
            long fbeCurrentSize = 0;
            long fbeFieldSize;

            fbeValue = Account.Default;

            id.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = id.Get(out fbeValue.id);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            name.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = name.Get(out fbeValue.name);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            state.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = state.Get(out fbeValue.state);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            wallet.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = wallet.Get(out fbeValue.wallet);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            asset.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = asset.Get(out fbeValue.asset);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            orders.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = orders.Get(out fbeValue.orders);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            return fbeCurrentSize;
        }

        // Set the struct value
        public override long Set(Account fbeValue)
        {
            _buffer.Shift(FBEOffset);
            long fbeResult = SetFields(fbeValue);
            _buffer.Unshift(FBEOffset);
            return fbeResult;
        }

        // Set the struct fields values
        public long SetFields(Account fbeValue)
        {
            long fbeCurrentOffset = 0;
            long fbeCurrentSize = 0;
            long fbeFieldSize;

            id.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = id.Set(fbeValue.id);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            name.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = name.Set(fbeValue.name);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            state.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = state.Set(fbeValue.state);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            wallet.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = wallet.Set(fbeValue.wallet);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            asset.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = asset.Set(fbeValue.asset);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            orders.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = orders.Set(fbeValue.orders);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            return fbeCurrentSize;
        }
    }

} // namespace com.chronoxor.proto.FBE

namespace com.chronoxor.proto.FBE {

    using global::com.chronoxor.proto;

    // Fast Binary Encoding Account final model
    public class AccountFinalModel : com.chronoxor.FBE.Model
    {
        private readonly FinalModelAccount _model;

        public AccountFinalModel() { _model = new FinalModelAccount(Buffer, 8); }
        public AccountFinalModel(com.chronoxor.FBE.Buffer buffer) : base(buffer) { _model = new FinalModelAccount(Buffer, 8); }

        // Get the model type
        public const long FBETypeConst = FinalModelAccount.FBETypeConst;
        public long FBEType => FBETypeConst;

        // Check if the struct value is valid
        public bool Verify()
        {
            if ((Buffer.Offset + _model.FBEOffset) > Buffer.Size)
                return false;

            long fbeStructSize = ReadUInt32(_model.FBEOffset - 8);
            long fbeStructType = ReadUInt32(_model.FBEOffset - 4);
            if ((fbeStructSize <= 0) || (fbeStructType != FBEType))
                return false;

            return ((8 + _model.Verify()) == fbeStructSize);
        }

        // Serialize the struct value
        public long Serialize(Account value)
        {
            long fbeInitialSize = Buffer.Size;

            uint fbeStructType = (uint)FBEType;
            uint fbeStructSize = (uint)(8 + _model.FBEAllocationSize(value));
            uint fbeStructOffset = (uint)(Buffer.Allocate(fbeStructSize) - Buffer.Offset);
            Debug.Assert(((Buffer.Offset + fbeStructOffset + fbeStructSize) <= Buffer.Size), "Model is broken!");
            if ((Buffer.Offset + fbeStructOffset + fbeStructSize) > Buffer.Size)
                return 0;

            fbeStructSize = (uint)(8 + _model.Set(value));
            Buffer.Resize(fbeInitialSize + fbeStructSize);

            Write(_model.FBEOffset - 8, fbeStructSize);
            Write(_model.FBEOffset - 4, fbeStructType);

            return fbeStructSize;
        }

        // Deserialize the struct value
        public long Deserialize(out Account value)
        {
            Debug.Assert(((Buffer.Offset + _model.FBEOffset) <= Buffer.Size), "Model is broken!");
            if ((Buffer.Offset + _model.FBEOffset) > Buffer.Size)
            {
                value = Account.Default;
                return 0;
            }

            long fbeStructSize = ReadUInt32(_model.FBEOffset - 8);
            long fbeStructType = ReadUInt32(_model.FBEOffset - 4);
            Debug.Assert(((fbeStructSize > 0) && (fbeStructType == FBEType)), "Model is broken!");
            if ((fbeStructSize <= 0) || (fbeStructType != FBEType))
            {
                value = Account.Default;
                return 8;
            }

            return 8 + _model.Get(out value);
        }

        // Move to the next struct value
        public void Next(long prev)
        {
            _model.FBEShift(prev);
        }
    }

} // namespace com.chronoxor.proto.FBE

namespace com.chronoxor.proto {

    public struct OrderMessage : IComparable, IComparable<OrderMessage>, IEquatable<OrderMessage>
    {
        public Order body;
        public Guid id => Guid.Empty;

        public const long FBETypeConst = 1;
        #if UTF8JSON
        [IgnoreDataMember]
        #else
        [JsonIgnore]
        #endif
        public long FBEType => FBETypeConst;

        public static OrderMessage Default => new OrderMessage
        {
            body = global::com.chronoxor.proto.Order.Default
        };

        public OrderMessage(Order body)
        {
            this.body = body;
        }

        public OrderMessage Clone()
        {
            // Serialize the struct to the FBE stream
            var writer = new com.chronoxor.proto.FBE.OrderMessageModel();
            writer.Serialize(this);

            // Deserialize the struct from the FBE stream
            var reader = new com.chronoxor.proto.FBE.OrderMessageModel();
            reader.Attach(writer.Buffer);
            reader.Deserialize(out var result);
            return result;
        }

        public int CompareTo(object other)
        {
            int result = 0;
            return result;
        }

        public int CompareTo(OrderMessage other)
        {
            int result = 0;
            return result;
        }

        public override bool Equals(object other)
        {
            if (!(other is OrderMessage))
                return false;
            return true;
        }

        public bool Equals(OrderMessage other)
        {
            return true;
        }

        public override int GetHashCode()
        {
            int hash = 17;
            return hash;
        }

        public static bool operator==(OrderMessage lhs, OrderMessage rhs) => lhs.Equals(rhs);
        public static bool operator!=(OrderMessage lhs, OrderMessage rhs) => !(lhs == rhs);

        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("OrderMessage(");
            sb.Append("body="); sb.Append(body);
            sb.Append(")");
            return sb.ToString();
        }

        public string ToJson()
        {
            var json = com.chronoxor.FBE.Json.ToJson(this);
            return json;
        }

        public static OrderMessage FromJson(string json)
        {
            var result = com.chronoxor.FBE.Json.FromJson<OrderMessage>(json);
            return result;
        }

        public static com.chronoxor.FBE.FieldModelValueType<OrderMessage> CreateFieldModel(com.chronoxor.FBE.Buffer buffer, long offset) { return new proto.FBE.FieldModelOrderMessage(buffer, offset); }
    }

} // namespace com.chronoxor.proto

namespace com.chronoxor.proto.FBE {

    using global::com.chronoxor.proto;

    // Fast Binary Encoding OrderMessage field model
    public class FieldModelOrderMessage : com.chronoxor.FBE.FieldModelValueType<OrderMessage>
    {
        public readonly com.chronoxor.proto.FBE.FieldModelOrder body;

        public FieldModelOrderMessage(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset)
        {
            body = new com.chronoxor.proto.FBE.FieldModelOrder(buffer, 4 + 4);
        }

        // Get the field size
        public override long FBESize => 4;
        // Get the field body size
        public long FBEBody
        {
            get
            {
                long fbeResult = 4 + 4
                    + body.FBESize
                    ;
                return fbeResult;
            }
        }
        // Get the field extra size
        public override long FBEExtra
        {
            get
            {
                if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                    return 0;

                uint fbeStructOffset = ReadUInt32(FBEOffset);
                if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4) > _buffer.Size))
                    return 0;

                _buffer.Shift(fbeStructOffset);

                long fbeResult = FBEBody
                    + body.FBEExtra
                    ;

                _buffer.Unshift(fbeStructOffset);

                return fbeResult;
            }
        }
        // Get the field type
        public const long FBETypeConst = 1;
        public long FBEType => FBETypeConst;

        // Clone the field model
        public override com.chronoxor.FBE.FieldModelValueType<OrderMessage> Clone() { return new FieldModelOrderMessage(_buffer, _offset); }

        // Check if the struct value is valid
        public override bool Verify() { return Verify(true); }
        public bool Verify(bool fbeVerifyType)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return true;

            uint fbeStructOffset = ReadUInt32(FBEOffset);
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
                return false;

            uint fbeStructSize = ReadUInt32(fbeStructOffset);
            if (fbeStructSize < (4 + 4))
                return false;

            uint fbeStructType = ReadUInt32(fbeStructOffset + 4);
            if (fbeVerifyType && (fbeStructType != FBEType))
                return false;

            _buffer.Shift(fbeStructOffset);
            bool fbeResult = VerifyFields(fbeStructSize);
            _buffer.Unshift(fbeStructOffset);
            return fbeResult;
        }

        // Check if the struct fields are valid
        public bool VerifyFields(long fbeStructSize)
        {
            long fbeCurrentSize = 4 + 4;

            if ((fbeCurrentSize + body.FBESize) > fbeStructSize)
                return true;
            if (!body.Verify())
                return false;
            fbeCurrentSize += body.FBESize;

            return true;
        }

        // Get the struct value (begin phase)
        public long GetBegin()
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            uint fbeStructOffset = ReadUInt32(FBEOffset);
            Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + 4 + 4) <= _buffer.Size)), "Model is broken!");
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
                return 0;

            uint fbeStructSize = ReadUInt32(fbeStructOffset);
            Debug.Assert((fbeStructSize >= (4 + 4)), "Model is broken!");
            if (fbeStructSize < (4 + 4))
                return 0;

            _buffer.Shift(fbeStructOffset);
            return fbeStructOffset;
        }

        // Get the struct value (end phase)
        public void GetEnd(long fbeBegin)
        {
            _buffer.Unshift(fbeBegin);
        }

        // Get the struct value
        public override void Get(out OrderMessage fbeValue) { Get(out fbeValue, OrderMessage.Default); }
        public override void Get(out OrderMessage fbeValue, OrderMessage defaults)
        {
            long fbeBegin = GetBegin();
            if (fbeBegin == 0)
            {
                fbeValue = defaults;
                return;
            }

            uint fbeStructSize = ReadUInt32(0);
            GetFields(out fbeValue, fbeStructSize);
            GetEnd(fbeBegin);
        }

        // Get the struct fields values
        public void GetFields(out OrderMessage fbeValue, long fbeStructSize)
        {
            long fbeCurrentSize = 4 + 4;

            fbeValue = OrderMessage.Default;

            if ((fbeCurrentSize + body.FBESize) <= fbeStructSize)
                body.Get(out fbeValue.body);
            else
                fbeValue.body = global::com.chronoxor.proto.Order.Default;
            fbeCurrentSize += body.FBESize;
        }

        // Set the struct value (begin phase)
        public long SetBegin()
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            uint fbeStructSize = (uint)FBEBody;
            uint fbeStructOffset = (uint)(_buffer.Allocate(fbeStructSize) - _buffer.Offset);
            Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + fbeStructSize) <= _buffer.Size)), "Model is broken!");
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + fbeStructSize) > _buffer.Size))
                return 0;

            Write(FBEOffset, fbeStructOffset);
            Write(fbeStructOffset, fbeStructSize);
            Write(fbeStructOffset + 4, (uint)FBEType);

            _buffer.Shift(fbeStructOffset);
            return fbeStructOffset;
        }

        // Set the struct value (end phase)
        public void SetEnd(long fbeBegin)
        {
            _buffer.Unshift(fbeBegin);
        }

        // Set the struct value
        public override void Set(OrderMessage fbeValue)
        {
            long fbeBegin = SetBegin();
            if (fbeBegin == 0)
                return;

            SetFields(fbeValue);
            SetEnd(fbeBegin);
        }

        // Set the struct fields values
        public void SetFields(OrderMessage fbeValue)
        {
            body.Set(fbeValue.body);
        }
    }

} // namespace com.chronoxor.proto.FBE

namespace com.chronoxor.proto.FBE {

    using global::com.chronoxor.proto;

    // Fast Binary Encoding OrderMessage model
    public class OrderMessageModel : com.chronoxor.FBE.Model
    {
        public readonly FieldModelOrderMessage model;

        public OrderMessageModel() { model = new FieldModelOrderMessage(Buffer, 4); }
        public OrderMessageModel(com.chronoxor.FBE.Buffer buffer) : base(buffer) { model = new FieldModelOrderMessage(Buffer, 4); }

        // Get the model size
        public long FBESize => model.FBESize + model.FBEExtra;
        // Get the model type
        public const long FBETypeConst = FieldModelOrderMessage.FBETypeConst;
        public long FBEType => FBETypeConst;

        // Check if the struct value is valid
        public bool Verify()
        {
            if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
                return false;

            uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
            if (fbeFullSize < model.FBESize)
                return false;

            return model.Verify();
        }

        // Create a new model (begin phase)
        public long CreateBegin()
        {
            long fbeBegin = Buffer.Allocate(4 + model.FBESize);
            return fbeBegin;
        }

        // Create a new model (end phase)
        public long CreateEnd(long fbeBegin)
        {
            long fbeEnd = Buffer.Size;
            uint fbeFullSize = (uint)(fbeEnd - fbeBegin);
            Write(model.FBEOffset - 4, fbeFullSize);
            return fbeFullSize;
        }

        // Serialize the struct value
        public long Serialize(OrderMessage value)
        {
            long fbeBegin = CreateBegin();
            model.Set(value);
            long fbeFullSize = CreateEnd(fbeBegin);
            return fbeFullSize;
        }

        // Deserialize the struct value
        public long Deserialize(out OrderMessage value)
        {
            if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
            {
                value = OrderMessage.Default;
                return 0;
            }

            uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
            Debug.Assert((fbeFullSize >= model.FBESize), "Model is broken!");
            if (fbeFullSize < model.FBESize)
            {
                value = OrderMessage.Default;
                return 0;
            }

            model.Get(out value);
            return fbeFullSize;
        }

        // Move to the next struct value
        public void Next(long prev)
        {
            model.FBEShift(prev);
        }
    }

} // namespace com.chronoxor.proto.FBE

namespace com.chronoxor.proto.FBE {

    using global::com.chronoxor.proto;

    // Fast Binary Encoding OrderMessage final model
    public class FinalModelOrderMessage : com.chronoxor.FBE.FinalModelValueType<OrderMessage>
    {
        public readonly com.chronoxor.proto.FBE.FinalModelOrder body;

        public FinalModelOrderMessage(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset)
        {
            body = new com.chronoxor.proto.FBE.FinalModelOrder(buffer, 0);
        }

        // Get the allocation size
        public override long FBEAllocationSize(OrderMessage fbeValue)
        {
            long fbeResult = 0
                + body.FBEAllocationSize(fbeValue.body)
                ;
            return fbeResult;
        }

        // Get the final type
        public const long FBETypeConst = 1;
        public long FBEType => FBETypeConst;

        // Clone the final model
        public override com.chronoxor.FBE.FinalModelValueType<OrderMessage> Clone() { return new FinalModelOrderMessage(_buffer, _offset); }

        // Check if the struct value is valid
        public override long Verify()
        {
            _buffer.Shift(FBEOffset);
            long fbeResult = VerifyFields();
            _buffer.Unshift(FBEOffset);
            return fbeResult;
        }

        // Check if the struct fields are valid
        public long VerifyFields()
        {
            long fbeCurrentOffset = 0;
            long fbeFieldSize;

            body.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = body.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            return fbeCurrentOffset;
        }

        // Get the struct value
        public override long Get(out OrderMessage fbeValue)
        {
            _buffer.Shift(FBEOffset);
            long fbeSize = GetFields(out fbeValue);
            _buffer.Unshift(FBEOffset);
            return fbeSize;
        }

        // Get the struct fields values
        public long GetFields(out OrderMessage fbeValue)
        {
            long fbeCurrentOffset = 0;
            long fbeCurrentSize = 0;
            long fbeFieldSize;

            fbeValue = OrderMessage.Default;

            body.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = body.Get(out fbeValue.body);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            return fbeCurrentSize;
        }

        // Set the struct value
        public override long Set(OrderMessage fbeValue)
        {
            _buffer.Shift(FBEOffset);
            long fbeResult = SetFields(fbeValue);
            _buffer.Unshift(FBEOffset);
            return fbeResult;
        }

        // Set the struct fields values
        public long SetFields(OrderMessage fbeValue)
        {
            long fbeCurrentOffset = 0;
            long fbeCurrentSize = 0;
            long fbeFieldSize;

            body.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = body.Set(fbeValue.body);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            return fbeCurrentSize;
        }
    }

} // namespace com.chronoxor.proto.FBE

namespace com.chronoxor.proto.FBE {

    using global::com.chronoxor.proto;

    // Fast Binary Encoding OrderMessage final model
    public class OrderMessageFinalModel : com.chronoxor.FBE.Model
    {
        private readonly FinalModelOrderMessage _model;

        public OrderMessageFinalModel() { _model = new FinalModelOrderMessage(Buffer, 8); }
        public OrderMessageFinalModel(com.chronoxor.FBE.Buffer buffer) : base(buffer) { _model = new FinalModelOrderMessage(Buffer, 8); }

        // Get the model type
        public const long FBETypeConst = FinalModelOrderMessage.FBETypeConst;
        public long FBEType => FBETypeConst;

        // Check if the struct value is valid
        public bool Verify()
        {
            if ((Buffer.Offset + _model.FBEOffset) > Buffer.Size)
                return false;

            long fbeStructSize = ReadUInt32(_model.FBEOffset - 8);
            long fbeStructType = ReadUInt32(_model.FBEOffset - 4);
            if ((fbeStructSize <= 0) || (fbeStructType != FBEType))
                return false;

            return ((8 + _model.Verify()) == fbeStructSize);
        }

        // Serialize the struct value
        public long Serialize(OrderMessage value)
        {
            long fbeInitialSize = Buffer.Size;

            uint fbeStructType = (uint)FBEType;
            uint fbeStructSize = (uint)(8 + _model.FBEAllocationSize(value));
            uint fbeStructOffset = (uint)(Buffer.Allocate(fbeStructSize) - Buffer.Offset);
            Debug.Assert(((Buffer.Offset + fbeStructOffset + fbeStructSize) <= Buffer.Size), "Model is broken!");
            if ((Buffer.Offset + fbeStructOffset + fbeStructSize) > Buffer.Size)
                return 0;

            fbeStructSize = (uint)(8 + _model.Set(value));
            Buffer.Resize(fbeInitialSize + fbeStructSize);

            Write(_model.FBEOffset - 8, fbeStructSize);
            Write(_model.FBEOffset - 4, fbeStructType);

            return fbeStructSize;
        }

        // Deserialize the struct value
        public long Deserialize(out OrderMessage value)
        {
            Debug.Assert(((Buffer.Offset + _model.FBEOffset) <= Buffer.Size), "Model is broken!");
            if ((Buffer.Offset + _model.FBEOffset) > Buffer.Size)
            {
                value = OrderMessage.Default;
                return 0;
            }

            long fbeStructSize = ReadUInt32(_model.FBEOffset - 8);
            long fbeStructType = ReadUInt32(_model.FBEOffset - 4);
            Debug.Assert(((fbeStructSize > 0) && (fbeStructType == FBEType)), "Model is broken!");
            if ((fbeStructSize <= 0) || (fbeStructType != FBEType))
            {
                value = OrderMessage.Default;
                return 8;
            }

            return 8 + _model.Get(out value);
        }

        // Move to the next struct value
        public void Next(long prev)
        {
            _model.FBEShift(prev);
        }
    }

} // namespace com.chronoxor.proto.FBE

namespace com.chronoxor.proto {

    public struct BalanceMessage : IComparable, IComparable<BalanceMessage>, IEquatable<BalanceMessage>
    {
        public Balance body;
        public Guid id => Guid.Empty;

        public const long FBETypeConst = 2;
        #if UTF8JSON
        [IgnoreDataMember]
        #else
        [JsonIgnore]
        #endif
        public long FBEType => FBETypeConst;

        public static BalanceMessage Default => new BalanceMessage
        {
            body = global::com.chronoxor.proto.Balance.Default
        };

        public BalanceMessage(Balance body)
        {
            this.body = body;
        }

        public BalanceMessage Clone()
        {
            // Serialize the struct to the FBE stream
            var writer = new com.chronoxor.proto.FBE.BalanceMessageModel();
            writer.Serialize(this);

            // Deserialize the struct from the FBE stream
            var reader = new com.chronoxor.proto.FBE.BalanceMessageModel();
            reader.Attach(writer.Buffer);
            reader.Deserialize(out var result);
            return result;
        }

        public int CompareTo(object other)
        {
            int result = 0;
            return result;
        }

        public int CompareTo(BalanceMessage other)
        {
            int result = 0;
            return result;
        }

        public override bool Equals(object other)
        {
            if (!(other is BalanceMessage))
                return false;
            return true;
        }

        public bool Equals(BalanceMessage other)
        {
            return true;
        }

        public override int GetHashCode()
        {
            int hash = 17;
            return hash;
        }

        public static bool operator==(BalanceMessage lhs, BalanceMessage rhs) => lhs.Equals(rhs);
        public static bool operator!=(BalanceMessage lhs, BalanceMessage rhs) => !(lhs == rhs);

        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("BalanceMessage(");
            sb.Append("body="); sb.Append(body);
            sb.Append(")");
            return sb.ToString();
        }

        public string ToJson()
        {
            var json = com.chronoxor.FBE.Json.ToJson(this);
            return json;
        }

        public static BalanceMessage FromJson(string json)
        {
            var result = com.chronoxor.FBE.Json.FromJson<BalanceMessage>(json);
            return result;
        }

        public static com.chronoxor.FBE.FieldModelValueType<BalanceMessage> CreateFieldModel(com.chronoxor.FBE.Buffer buffer, long offset) { return new proto.FBE.FieldModelBalanceMessage(buffer, offset); }
    }

} // namespace com.chronoxor.proto

namespace com.chronoxor.proto.FBE {

    using global::com.chronoxor.proto;

    // Fast Binary Encoding BalanceMessage field model
    public class FieldModelBalanceMessage : com.chronoxor.FBE.FieldModelValueType<BalanceMessage>
    {
        public readonly com.chronoxor.proto.FBE.FieldModelBalance body;

        public FieldModelBalanceMessage(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset)
        {
            body = new com.chronoxor.proto.FBE.FieldModelBalance(buffer, 4 + 4);
        }

        // Get the field size
        public override long FBESize => 4;
        // Get the field body size
        public long FBEBody
        {
            get
            {
                long fbeResult = 4 + 4
                    + body.FBESize
                    ;
                return fbeResult;
            }
        }
        // Get the field extra size
        public override long FBEExtra
        {
            get
            {
                if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                    return 0;

                uint fbeStructOffset = ReadUInt32(FBEOffset);
                if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4) > _buffer.Size))
                    return 0;

                _buffer.Shift(fbeStructOffset);

                long fbeResult = FBEBody
                    + body.FBEExtra
                    ;

                _buffer.Unshift(fbeStructOffset);

                return fbeResult;
            }
        }
        // Get the field type
        public const long FBETypeConst = 2;
        public long FBEType => FBETypeConst;

        // Clone the field model
        public override com.chronoxor.FBE.FieldModelValueType<BalanceMessage> Clone() { return new FieldModelBalanceMessage(_buffer, _offset); }

        // Check if the struct value is valid
        public override bool Verify() { return Verify(true); }
        public bool Verify(bool fbeVerifyType)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return true;

            uint fbeStructOffset = ReadUInt32(FBEOffset);
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
                return false;

            uint fbeStructSize = ReadUInt32(fbeStructOffset);
            if (fbeStructSize < (4 + 4))
                return false;

            uint fbeStructType = ReadUInt32(fbeStructOffset + 4);
            if (fbeVerifyType && (fbeStructType != FBEType))
                return false;

            _buffer.Shift(fbeStructOffset);
            bool fbeResult = VerifyFields(fbeStructSize);
            _buffer.Unshift(fbeStructOffset);
            return fbeResult;
        }

        // Check if the struct fields are valid
        public bool VerifyFields(long fbeStructSize)
        {
            long fbeCurrentSize = 4 + 4;

            if ((fbeCurrentSize + body.FBESize) > fbeStructSize)
                return true;
            if (!body.Verify())
                return false;
            fbeCurrentSize += body.FBESize;

            return true;
        }

        // Get the struct value (begin phase)
        public long GetBegin()
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            uint fbeStructOffset = ReadUInt32(FBEOffset);
            Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + 4 + 4) <= _buffer.Size)), "Model is broken!");
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
                return 0;

            uint fbeStructSize = ReadUInt32(fbeStructOffset);
            Debug.Assert((fbeStructSize >= (4 + 4)), "Model is broken!");
            if (fbeStructSize < (4 + 4))
                return 0;

            _buffer.Shift(fbeStructOffset);
            return fbeStructOffset;
        }

        // Get the struct value (end phase)
        public void GetEnd(long fbeBegin)
        {
            _buffer.Unshift(fbeBegin);
        }

        // Get the struct value
        public override void Get(out BalanceMessage fbeValue) { Get(out fbeValue, BalanceMessage.Default); }
        public override void Get(out BalanceMessage fbeValue, BalanceMessage defaults)
        {
            long fbeBegin = GetBegin();
            if (fbeBegin == 0)
            {
                fbeValue = defaults;
                return;
            }

            uint fbeStructSize = ReadUInt32(0);
            GetFields(out fbeValue, fbeStructSize);
            GetEnd(fbeBegin);
        }

        // Get the struct fields values
        public void GetFields(out BalanceMessage fbeValue, long fbeStructSize)
        {
            long fbeCurrentSize = 4 + 4;

            fbeValue = BalanceMessage.Default;

            if ((fbeCurrentSize + body.FBESize) <= fbeStructSize)
                body.Get(out fbeValue.body);
            else
                fbeValue.body = global::com.chronoxor.proto.Balance.Default;
            fbeCurrentSize += body.FBESize;
        }

        // Set the struct value (begin phase)
        public long SetBegin()
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            uint fbeStructSize = (uint)FBEBody;
            uint fbeStructOffset = (uint)(_buffer.Allocate(fbeStructSize) - _buffer.Offset);
            Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + fbeStructSize) <= _buffer.Size)), "Model is broken!");
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + fbeStructSize) > _buffer.Size))
                return 0;

            Write(FBEOffset, fbeStructOffset);
            Write(fbeStructOffset, fbeStructSize);
            Write(fbeStructOffset + 4, (uint)FBEType);

            _buffer.Shift(fbeStructOffset);
            return fbeStructOffset;
        }

        // Set the struct value (end phase)
        public void SetEnd(long fbeBegin)
        {
            _buffer.Unshift(fbeBegin);
        }

        // Set the struct value
        public override void Set(BalanceMessage fbeValue)
        {
            long fbeBegin = SetBegin();
            if (fbeBegin == 0)
                return;

            SetFields(fbeValue);
            SetEnd(fbeBegin);
        }

        // Set the struct fields values
        public void SetFields(BalanceMessage fbeValue)
        {
            body.Set(fbeValue.body);
        }
    }

} // namespace com.chronoxor.proto.FBE

namespace com.chronoxor.proto.FBE {

    using global::com.chronoxor.proto;

    // Fast Binary Encoding BalanceMessage model
    public class BalanceMessageModel : com.chronoxor.FBE.Model
    {
        public readonly FieldModelBalanceMessage model;

        public BalanceMessageModel() { model = new FieldModelBalanceMessage(Buffer, 4); }
        public BalanceMessageModel(com.chronoxor.FBE.Buffer buffer) : base(buffer) { model = new FieldModelBalanceMessage(Buffer, 4); }

        // Get the model size
        public long FBESize => model.FBESize + model.FBEExtra;
        // Get the model type
        public const long FBETypeConst = FieldModelBalanceMessage.FBETypeConst;
        public long FBEType => FBETypeConst;

        // Check if the struct value is valid
        public bool Verify()
        {
            if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
                return false;

            uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
            if (fbeFullSize < model.FBESize)
                return false;

            return model.Verify();
        }

        // Create a new model (begin phase)
        public long CreateBegin()
        {
            long fbeBegin = Buffer.Allocate(4 + model.FBESize);
            return fbeBegin;
        }

        // Create a new model (end phase)
        public long CreateEnd(long fbeBegin)
        {
            long fbeEnd = Buffer.Size;
            uint fbeFullSize = (uint)(fbeEnd - fbeBegin);
            Write(model.FBEOffset - 4, fbeFullSize);
            return fbeFullSize;
        }

        // Serialize the struct value
        public long Serialize(BalanceMessage value)
        {
            long fbeBegin = CreateBegin();
            model.Set(value);
            long fbeFullSize = CreateEnd(fbeBegin);
            return fbeFullSize;
        }

        // Deserialize the struct value
        public long Deserialize(out BalanceMessage value)
        {
            if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
            {
                value = BalanceMessage.Default;
                return 0;
            }

            uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
            Debug.Assert((fbeFullSize >= model.FBESize), "Model is broken!");
            if (fbeFullSize < model.FBESize)
            {
                value = BalanceMessage.Default;
                return 0;
            }

            model.Get(out value);
            return fbeFullSize;
        }

        // Move to the next struct value
        public void Next(long prev)
        {
            model.FBEShift(prev);
        }
    }

} // namespace com.chronoxor.proto.FBE

namespace com.chronoxor.proto.FBE {

    using global::com.chronoxor.proto;

    // Fast Binary Encoding BalanceMessage final model
    public class FinalModelBalanceMessage : com.chronoxor.FBE.FinalModelValueType<BalanceMessage>
    {
        public readonly com.chronoxor.proto.FBE.FinalModelBalance body;

        public FinalModelBalanceMessage(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset)
        {
            body = new com.chronoxor.proto.FBE.FinalModelBalance(buffer, 0);
        }

        // Get the allocation size
        public override long FBEAllocationSize(BalanceMessage fbeValue)
        {
            long fbeResult = 0
                + body.FBEAllocationSize(fbeValue.body)
                ;
            return fbeResult;
        }

        // Get the final type
        public const long FBETypeConst = 2;
        public long FBEType => FBETypeConst;

        // Clone the final model
        public override com.chronoxor.FBE.FinalModelValueType<BalanceMessage> Clone() { return new FinalModelBalanceMessage(_buffer, _offset); }

        // Check if the struct value is valid
        public override long Verify()
        {
            _buffer.Shift(FBEOffset);
            long fbeResult = VerifyFields();
            _buffer.Unshift(FBEOffset);
            return fbeResult;
        }

        // Check if the struct fields are valid
        public long VerifyFields()
        {
            long fbeCurrentOffset = 0;
            long fbeFieldSize;

            body.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = body.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            return fbeCurrentOffset;
        }

        // Get the struct value
        public override long Get(out BalanceMessage fbeValue)
        {
            _buffer.Shift(FBEOffset);
            long fbeSize = GetFields(out fbeValue);
            _buffer.Unshift(FBEOffset);
            return fbeSize;
        }

        // Get the struct fields values
        public long GetFields(out BalanceMessage fbeValue)
        {
            long fbeCurrentOffset = 0;
            long fbeCurrentSize = 0;
            long fbeFieldSize;

            fbeValue = BalanceMessage.Default;

            body.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = body.Get(out fbeValue.body);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            return fbeCurrentSize;
        }

        // Set the struct value
        public override long Set(BalanceMessage fbeValue)
        {
            _buffer.Shift(FBEOffset);
            long fbeResult = SetFields(fbeValue);
            _buffer.Unshift(FBEOffset);
            return fbeResult;
        }

        // Set the struct fields values
        public long SetFields(BalanceMessage fbeValue)
        {
            long fbeCurrentOffset = 0;
            long fbeCurrentSize = 0;
            long fbeFieldSize;

            body.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = body.Set(fbeValue.body);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            return fbeCurrentSize;
        }
    }

} // namespace com.chronoxor.proto.FBE

namespace com.chronoxor.proto.FBE {

    using global::com.chronoxor.proto;

    // Fast Binary Encoding BalanceMessage final model
    public class BalanceMessageFinalModel : com.chronoxor.FBE.Model
    {
        private readonly FinalModelBalanceMessage _model;

        public BalanceMessageFinalModel() { _model = new FinalModelBalanceMessage(Buffer, 8); }
        public BalanceMessageFinalModel(com.chronoxor.FBE.Buffer buffer) : base(buffer) { _model = new FinalModelBalanceMessage(Buffer, 8); }

        // Get the model type
        public const long FBETypeConst = FinalModelBalanceMessage.FBETypeConst;
        public long FBEType => FBETypeConst;

        // Check if the struct value is valid
        public bool Verify()
        {
            if ((Buffer.Offset + _model.FBEOffset) > Buffer.Size)
                return false;

            long fbeStructSize = ReadUInt32(_model.FBEOffset - 8);
            long fbeStructType = ReadUInt32(_model.FBEOffset - 4);
            if ((fbeStructSize <= 0) || (fbeStructType != FBEType))
                return false;

            return ((8 + _model.Verify()) == fbeStructSize);
        }

        // Serialize the struct value
        public long Serialize(BalanceMessage value)
        {
            long fbeInitialSize = Buffer.Size;

            uint fbeStructType = (uint)FBEType;
            uint fbeStructSize = (uint)(8 + _model.FBEAllocationSize(value));
            uint fbeStructOffset = (uint)(Buffer.Allocate(fbeStructSize) - Buffer.Offset);
            Debug.Assert(((Buffer.Offset + fbeStructOffset + fbeStructSize) <= Buffer.Size), "Model is broken!");
            if ((Buffer.Offset + fbeStructOffset + fbeStructSize) > Buffer.Size)
                return 0;

            fbeStructSize = (uint)(8 + _model.Set(value));
            Buffer.Resize(fbeInitialSize + fbeStructSize);

            Write(_model.FBEOffset - 8, fbeStructSize);
            Write(_model.FBEOffset - 4, fbeStructType);

            return fbeStructSize;
        }

        // Deserialize the struct value
        public long Deserialize(out BalanceMessage value)
        {
            Debug.Assert(((Buffer.Offset + _model.FBEOffset) <= Buffer.Size), "Model is broken!");
            if ((Buffer.Offset + _model.FBEOffset) > Buffer.Size)
            {
                value = BalanceMessage.Default;
                return 0;
            }

            long fbeStructSize = ReadUInt32(_model.FBEOffset - 8);
            long fbeStructType = ReadUInt32(_model.FBEOffset - 4);
            Debug.Assert(((fbeStructSize > 0) && (fbeStructType == FBEType)), "Model is broken!");
            if ((fbeStructSize <= 0) || (fbeStructType != FBEType))
            {
                value = BalanceMessage.Default;
                return 8;
            }

            return 8 + _model.Get(out value);
        }

        // Move to the next struct value
        public void Next(long prev)
        {
            _model.FBEShift(prev);
        }
    }

} // namespace com.chronoxor.proto.FBE

namespace com.chronoxor.proto {

    public struct AccountMessage : IComparable, IComparable<AccountMessage>, IEquatable<AccountMessage>
    {
        public Account body;
        public Guid id => Guid.Empty;

        public const long FBETypeConst = 3;
        #if UTF8JSON
        [IgnoreDataMember]
        #else
        [JsonIgnore]
        #endif
        public long FBEType => FBETypeConst;

        public static AccountMessage Default => new AccountMessage
        {
            body = global::com.chronoxor.proto.Account.Default
        };

        public AccountMessage(Account body)
        {
            this.body = body;
        }

        public AccountMessage Clone()
        {
            // Serialize the struct to the FBE stream
            var writer = new com.chronoxor.proto.FBE.AccountMessageModel();
            writer.Serialize(this);

            // Deserialize the struct from the FBE stream
            var reader = new com.chronoxor.proto.FBE.AccountMessageModel();
            reader.Attach(writer.Buffer);
            reader.Deserialize(out var result);
            return result;
        }

        public int CompareTo(object other)
        {
            int result = 0;
            return result;
        }

        public int CompareTo(AccountMessage other)
        {
            int result = 0;
            return result;
        }

        public override bool Equals(object other)
        {
            if (!(other is AccountMessage))
                return false;
            return true;
        }

        public bool Equals(AccountMessage other)
        {
            return true;
        }

        public override int GetHashCode()
        {
            int hash = 17;
            return hash;
        }

        public static bool operator==(AccountMessage lhs, AccountMessage rhs) => lhs.Equals(rhs);
        public static bool operator!=(AccountMessage lhs, AccountMessage rhs) => !(lhs == rhs);

        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("AccountMessage(");
            sb.Append("body="); sb.Append(body);
            sb.Append(")");
            return sb.ToString();
        }

        public string ToJson()
        {
            var json = com.chronoxor.FBE.Json.ToJson(this);
            return json;
        }

        public static AccountMessage FromJson(string json)
        {
            var result = com.chronoxor.FBE.Json.FromJson<AccountMessage>(json);
            return result;
        }

        public static com.chronoxor.FBE.FieldModelValueType<AccountMessage> CreateFieldModel(com.chronoxor.FBE.Buffer buffer, long offset) { return new proto.FBE.FieldModelAccountMessage(buffer, offset); }
    }

} // namespace com.chronoxor.proto

namespace com.chronoxor.proto.FBE {

    using global::com.chronoxor.proto;

    // Fast Binary Encoding AccountMessage field model
    public class FieldModelAccountMessage : com.chronoxor.FBE.FieldModelValueType<AccountMessage>
    {
        public readonly com.chronoxor.proto.FBE.FieldModelAccount body;

        public FieldModelAccountMessage(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset)
        {
            body = new com.chronoxor.proto.FBE.FieldModelAccount(buffer, 4 + 4);
        }

        // Get the field size
        public override long FBESize => 4;
        // Get the field body size
        public long FBEBody
        {
            get
            {
                long fbeResult = 4 + 4
                    + body.FBESize
                    ;
                return fbeResult;
            }
        }
        // Get the field extra size
        public override long FBEExtra
        {
            get
            {
                if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                    return 0;

                uint fbeStructOffset = ReadUInt32(FBEOffset);
                if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4) > _buffer.Size))
                    return 0;

                _buffer.Shift(fbeStructOffset);

                long fbeResult = FBEBody
                    + body.FBEExtra
                    ;

                _buffer.Unshift(fbeStructOffset);

                return fbeResult;
            }
        }
        // Get the field type
        public const long FBETypeConst = 3;
        public long FBEType => FBETypeConst;

        // Clone the field model
        public override com.chronoxor.FBE.FieldModelValueType<AccountMessage> Clone() { return new FieldModelAccountMessage(_buffer, _offset); }

        // Check if the struct value is valid
        public override bool Verify() { return Verify(true); }
        public bool Verify(bool fbeVerifyType)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return true;

            uint fbeStructOffset = ReadUInt32(FBEOffset);
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
                return false;

            uint fbeStructSize = ReadUInt32(fbeStructOffset);
            if (fbeStructSize < (4 + 4))
                return false;

            uint fbeStructType = ReadUInt32(fbeStructOffset + 4);
            if (fbeVerifyType && (fbeStructType != FBEType))
                return false;

            _buffer.Shift(fbeStructOffset);
            bool fbeResult = VerifyFields(fbeStructSize);
            _buffer.Unshift(fbeStructOffset);
            return fbeResult;
        }

        // Check if the struct fields are valid
        public bool VerifyFields(long fbeStructSize)
        {
            long fbeCurrentSize = 4 + 4;

            if ((fbeCurrentSize + body.FBESize) > fbeStructSize)
                return true;
            if (!body.Verify())
                return false;
            fbeCurrentSize += body.FBESize;

            return true;
        }

        // Get the struct value (begin phase)
        public long GetBegin()
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            uint fbeStructOffset = ReadUInt32(FBEOffset);
            Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + 4 + 4) <= _buffer.Size)), "Model is broken!");
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
                return 0;

            uint fbeStructSize = ReadUInt32(fbeStructOffset);
            Debug.Assert((fbeStructSize >= (4 + 4)), "Model is broken!");
            if (fbeStructSize < (4 + 4))
                return 0;

            _buffer.Shift(fbeStructOffset);
            return fbeStructOffset;
        }

        // Get the struct value (end phase)
        public void GetEnd(long fbeBegin)
        {
            _buffer.Unshift(fbeBegin);
        }

        // Get the struct value
        public override void Get(out AccountMessage fbeValue) { Get(out fbeValue, AccountMessage.Default); }
        public override void Get(out AccountMessage fbeValue, AccountMessage defaults)
        {
            long fbeBegin = GetBegin();
            if (fbeBegin == 0)
            {
                fbeValue = defaults;
                return;
            }

            uint fbeStructSize = ReadUInt32(0);
            GetFields(out fbeValue, fbeStructSize);
            GetEnd(fbeBegin);
        }

        // Get the struct fields values
        public void GetFields(out AccountMessage fbeValue, long fbeStructSize)
        {
            long fbeCurrentSize = 4 + 4;

            fbeValue = AccountMessage.Default;

            if ((fbeCurrentSize + body.FBESize) <= fbeStructSize)
                body.Get(out fbeValue.body);
            else
                fbeValue.body = global::com.chronoxor.proto.Account.Default;
            fbeCurrentSize += body.FBESize;
        }

        // Set the struct value (begin phase)
        public long SetBegin()
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            uint fbeStructSize = (uint)FBEBody;
            uint fbeStructOffset = (uint)(_buffer.Allocate(fbeStructSize) - _buffer.Offset);
            Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + fbeStructSize) <= _buffer.Size)), "Model is broken!");
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + fbeStructSize) > _buffer.Size))
                return 0;

            Write(FBEOffset, fbeStructOffset);
            Write(fbeStructOffset, fbeStructSize);
            Write(fbeStructOffset + 4, (uint)FBEType);

            _buffer.Shift(fbeStructOffset);
            return fbeStructOffset;
        }

        // Set the struct value (end phase)
        public void SetEnd(long fbeBegin)
        {
            _buffer.Unshift(fbeBegin);
        }

        // Set the struct value
        public override void Set(AccountMessage fbeValue)
        {
            long fbeBegin = SetBegin();
            if (fbeBegin == 0)
                return;

            SetFields(fbeValue);
            SetEnd(fbeBegin);
        }

        // Set the struct fields values
        public void SetFields(AccountMessage fbeValue)
        {
            body.Set(fbeValue.body);
        }
    }

} // namespace com.chronoxor.proto.FBE

namespace com.chronoxor.proto.FBE {

    using global::com.chronoxor.proto;

    // Fast Binary Encoding AccountMessage model
    public class AccountMessageModel : com.chronoxor.FBE.Model
    {
        public readonly FieldModelAccountMessage model;

        public AccountMessageModel() { model = new FieldModelAccountMessage(Buffer, 4); }
        public AccountMessageModel(com.chronoxor.FBE.Buffer buffer) : base(buffer) { model = new FieldModelAccountMessage(Buffer, 4); }

        // Get the model size
        public long FBESize => model.FBESize + model.FBEExtra;
        // Get the model type
        public const long FBETypeConst = FieldModelAccountMessage.FBETypeConst;
        public long FBEType => FBETypeConst;

        // Check if the struct value is valid
        public bool Verify()
        {
            if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
                return false;

            uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
            if (fbeFullSize < model.FBESize)
                return false;

            return model.Verify();
        }

        // Create a new model (begin phase)
        public long CreateBegin()
        {
            long fbeBegin = Buffer.Allocate(4 + model.FBESize);
            return fbeBegin;
        }

        // Create a new model (end phase)
        public long CreateEnd(long fbeBegin)
        {
            long fbeEnd = Buffer.Size;
            uint fbeFullSize = (uint)(fbeEnd - fbeBegin);
            Write(model.FBEOffset - 4, fbeFullSize);
            return fbeFullSize;
        }

        // Serialize the struct value
        public long Serialize(AccountMessage value)
        {
            long fbeBegin = CreateBegin();
            model.Set(value);
            long fbeFullSize = CreateEnd(fbeBegin);
            return fbeFullSize;
        }

        // Deserialize the struct value
        public long Deserialize(out AccountMessage value)
        {
            if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
            {
                value = AccountMessage.Default;
                return 0;
            }

            uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
            Debug.Assert((fbeFullSize >= model.FBESize), "Model is broken!");
            if (fbeFullSize < model.FBESize)
            {
                value = AccountMessage.Default;
                return 0;
            }

            model.Get(out value);
            return fbeFullSize;
        }

        // Move to the next struct value
        public void Next(long prev)
        {
            model.FBEShift(prev);
        }
    }

} // namespace com.chronoxor.proto.FBE

namespace com.chronoxor.proto.FBE {

    using global::com.chronoxor.proto;

    // Fast Binary Encoding AccountMessage final model
    public class FinalModelAccountMessage : com.chronoxor.FBE.FinalModelValueType<AccountMessage>
    {
        public readonly com.chronoxor.proto.FBE.FinalModelAccount body;

        public FinalModelAccountMessage(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset)
        {
            body = new com.chronoxor.proto.FBE.FinalModelAccount(buffer, 0);
        }

        // Get the allocation size
        public override long FBEAllocationSize(AccountMessage fbeValue)
        {
            long fbeResult = 0
                + body.FBEAllocationSize(fbeValue.body)
                ;
            return fbeResult;
        }

        // Get the final type
        public const long FBETypeConst = 3;
        public long FBEType => FBETypeConst;

        // Clone the final model
        public override com.chronoxor.FBE.FinalModelValueType<AccountMessage> Clone() { return new FinalModelAccountMessage(_buffer, _offset); }

        // Check if the struct value is valid
        public override long Verify()
        {
            _buffer.Shift(FBEOffset);
            long fbeResult = VerifyFields();
            _buffer.Unshift(FBEOffset);
            return fbeResult;
        }

        // Check if the struct fields are valid
        public long VerifyFields()
        {
            long fbeCurrentOffset = 0;
            long fbeFieldSize;

            body.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = body.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            return fbeCurrentOffset;
        }

        // Get the struct value
        public override long Get(out AccountMessage fbeValue)
        {
            _buffer.Shift(FBEOffset);
            long fbeSize = GetFields(out fbeValue);
            _buffer.Unshift(FBEOffset);
            return fbeSize;
        }

        // Get the struct fields values
        public long GetFields(out AccountMessage fbeValue)
        {
            long fbeCurrentOffset = 0;
            long fbeCurrentSize = 0;
            long fbeFieldSize;

            fbeValue = AccountMessage.Default;

            body.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = body.Get(out fbeValue.body);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            return fbeCurrentSize;
        }

        // Set the struct value
        public override long Set(AccountMessage fbeValue)
        {
            _buffer.Shift(FBEOffset);
            long fbeResult = SetFields(fbeValue);
            _buffer.Unshift(FBEOffset);
            return fbeResult;
        }

        // Set the struct fields values
        public long SetFields(AccountMessage fbeValue)
        {
            long fbeCurrentOffset = 0;
            long fbeCurrentSize = 0;
            long fbeFieldSize;

            body.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = body.Set(fbeValue.body);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            return fbeCurrentSize;
        }
    }

} // namespace com.chronoxor.proto.FBE

namespace com.chronoxor.proto.FBE {

    using global::com.chronoxor.proto;

    // Fast Binary Encoding AccountMessage final model
    public class AccountMessageFinalModel : com.chronoxor.FBE.Model
    {
        private readonly FinalModelAccountMessage _model;

        public AccountMessageFinalModel() { _model = new FinalModelAccountMessage(Buffer, 8); }
        public AccountMessageFinalModel(com.chronoxor.FBE.Buffer buffer) : base(buffer) { _model = new FinalModelAccountMessage(Buffer, 8); }

        // Get the model type
        public const long FBETypeConst = FinalModelAccountMessage.FBETypeConst;
        public long FBEType => FBETypeConst;

        // Check if the struct value is valid
        public bool Verify()
        {
            if ((Buffer.Offset + _model.FBEOffset) > Buffer.Size)
                return false;

            long fbeStructSize = ReadUInt32(_model.FBEOffset - 8);
            long fbeStructType = ReadUInt32(_model.FBEOffset - 4);
            if ((fbeStructSize <= 0) || (fbeStructType != FBEType))
                return false;

            return ((8 + _model.Verify()) == fbeStructSize);
        }

        // Serialize the struct value
        public long Serialize(AccountMessage value)
        {
            long fbeInitialSize = Buffer.Size;

            uint fbeStructType = (uint)FBEType;
            uint fbeStructSize = (uint)(8 + _model.FBEAllocationSize(value));
            uint fbeStructOffset = (uint)(Buffer.Allocate(fbeStructSize) - Buffer.Offset);
            Debug.Assert(((Buffer.Offset + fbeStructOffset + fbeStructSize) <= Buffer.Size), "Model is broken!");
            if ((Buffer.Offset + fbeStructOffset + fbeStructSize) > Buffer.Size)
                return 0;

            fbeStructSize = (uint)(8 + _model.Set(value));
            Buffer.Resize(fbeInitialSize + fbeStructSize);

            Write(_model.FBEOffset - 8, fbeStructSize);
            Write(_model.FBEOffset - 4, fbeStructType);

            return fbeStructSize;
        }

        // Deserialize the struct value
        public long Deserialize(out AccountMessage value)
        {
            Debug.Assert(((Buffer.Offset + _model.FBEOffset) <= Buffer.Size), "Model is broken!");
            if ((Buffer.Offset + _model.FBEOffset) > Buffer.Size)
            {
                value = AccountMessage.Default;
                return 0;
            }

            long fbeStructSize = ReadUInt32(_model.FBEOffset - 8);
            long fbeStructType = ReadUInt32(_model.FBEOffset - 4);
            Debug.Assert(((fbeStructSize > 0) && (fbeStructType == FBEType)), "Model is broken!");
            if ((fbeStructSize <= 0) || (fbeStructType != FBEType))
            {
                value = AccountMessage.Default;
                return 8;
            }

            return 8 + _model.Get(out value);
        }

        // Move to the next struct value
        public void Next(long prev)
        {
            _model.FBEShift(prev);
        }
    }

} // namespace com.chronoxor.proto.FBE

namespace com.chronoxor.proto.FBE {

    // Fast Binary Encoding com.chronoxor.proto protocol version
    public static class ProtocolVersion
    {
        // Protocol major version
        public const int Major = 1;
        // Protocol minor version
        public const int Minor = 0;
    }

} // namespace com.chronoxor.proto.FBE

namespace com.chronoxor.proto.FBE {

    // Fast Binary Encoding com.chronoxor.proto sender listener interface
    public interface ISenderListener : com.chronoxor.FBE.ISenderListener
    {
    }

    // Fast Binary Encoding com.chronoxor.proto sender
    public class Sender : com.chronoxor.FBE.Sender, ISenderListener
    {
        // Sender models accessors
        public readonly OrderMessageModel OrderMessageModel;
        public readonly BalanceMessageModel BalanceMessageModel;
        public readonly AccountMessageModel AccountMessageModel;

        public Sender() : base(false)
        {
            OrderMessageModel = new OrderMessageModel(Buffer);
            BalanceMessageModel = new BalanceMessageModel(Buffer);
            AccountMessageModel = new AccountMessageModel(Buffer);
        }
        public Sender(com.chronoxor.FBE.Buffer buffer) : base(buffer, false)
        {
            OrderMessageModel = new OrderMessageModel(Buffer);
            BalanceMessageModel = new BalanceMessageModel(Buffer);
            AccountMessageModel = new AccountMessageModel(Buffer);
        }

        public long Send(object obj) { return SendListener(this, obj); }
        public long SendListener(ISenderListener listener, object obj)
        {
            switch (obj)
            {
                case global::com.chronoxor.proto.OrderMessage value when value.FBEType == global::com.chronoxor.proto.OrderMessage.FBETypeConst: return SendListener(listener, value);
                case global::com.chronoxor.proto.BalanceMessage value when value.FBEType == global::com.chronoxor.proto.BalanceMessage.FBETypeConst: return SendListener(listener, value);
                case global::com.chronoxor.proto.AccountMessage value when value.FBEType == global::com.chronoxor.proto.AccountMessage.FBETypeConst: return SendListener(listener, value);
                default: break;
            }

            return 0;
        }

        public long Send(global::com.chronoxor.proto.OrderMessage value) { return SendListener(this, value); }
        public long SendListener(ISenderListener listener, global::com.chronoxor.proto.OrderMessage value)
        {
            // Serialize the value into the FBE stream
            long serialized = OrderMessageModel.Serialize(value);
            Debug.Assert((serialized > 0), "com.chronoxor.proto.OrderMessage serialization failed!");
            Debug.Assert(OrderMessageModel.Verify(), "com.chronoxor.proto.OrderMessage validation failed!");

            // Log the value
            if (Logging)
            {
                string message = value.ToString();
                listener.OnSendLog(message);
            }

            // Send the serialized value
            return SendSerialized(listener, serialized);
        }
        public long Send(global::com.chronoxor.proto.BalanceMessage value) { return SendListener(this, value); }
        public long SendListener(ISenderListener listener, global::com.chronoxor.proto.BalanceMessage value)
        {
            // Serialize the value into the FBE stream
            long serialized = BalanceMessageModel.Serialize(value);
            Debug.Assert((serialized > 0), "com.chronoxor.proto.BalanceMessage serialization failed!");
            Debug.Assert(BalanceMessageModel.Verify(), "com.chronoxor.proto.BalanceMessage validation failed!");

            // Log the value
            if (Logging)
            {
                string message = value.ToString();
                listener.OnSendLog(message);
            }

            // Send the serialized value
            return SendSerialized(listener, serialized);
        }
        public long Send(global::com.chronoxor.proto.AccountMessage value) { return SendListener(this, value); }
        public long SendListener(ISenderListener listener, global::com.chronoxor.proto.AccountMessage value)
        {
            // Serialize the value into the FBE stream
            long serialized = AccountMessageModel.Serialize(value);
            Debug.Assert((serialized > 0), "com.chronoxor.proto.AccountMessage serialization failed!");
            Debug.Assert(AccountMessageModel.Verify(), "com.chronoxor.proto.AccountMessage validation failed!");

            // Log the value
            if (Logging)
            {
                string message = value.ToString();
                listener.OnSendLog(message);
            }

            // Send the serialized value
            return SendSerialized(listener, serialized);
        }
    }

} // namespace com.chronoxor.proto.FBE

namespace com.chronoxor.proto.FBE {

    // Fast Binary Encoding com.chronoxor.proto receiver listener interface
    public interface IReceiverListener : com.chronoxor.FBE.IReceiverListener
    {
        // Receive handlers
        void OnReceive(global::com.chronoxor.proto.OrderMessage value) {}
        void OnReceive(global::com.chronoxor.proto.BalanceMessage value) {}
        void OnReceive(global::com.chronoxor.proto.AccountMessage value) {}
    }

    // Fast Binary Encoding com.chronoxor.proto receiver
    public class Receiver : com.chronoxor.FBE.Receiver, IReceiverListener
    {
        // Receiver values accessors
        private global::com.chronoxor.proto.OrderMessage OrderMessageValue;
        private global::com.chronoxor.proto.BalanceMessage BalanceMessageValue;
        private global::com.chronoxor.proto.AccountMessage AccountMessageValue;

        // Receiver models accessors
        private readonly OrderMessageModel OrderMessageModel;
        private readonly BalanceMessageModel BalanceMessageModel;
        private readonly AccountMessageModel AccountMessageModel;

        public Receiver() : base(false)
        {
            OrderMessageValue = global::com.chronoxor.proto.OrderMessage.Default;
            OrderMessageModel = new OrderMessageModel();
            BalanceMessageValue = global::com.chronoxor.proto.BalanceMessage.Default;
            BalanceMessageModel = new BalanceMessageModel();
            AccountMessageValue = global::com.chronoxor.proto.AccountMessage.Default;
            AccountMessageModel = new AccountMessageModel();
        }
        public Receiver(com.chronoxor.FBE.Buffer buffer) : base(buffer, false)
        {
            OrderMessageValue = global::com.chronoxor.proto.OrderMessage.Default;
            OrderMessageModel = new OrderMessageModel();
            BalanceMessageValue = global::com.chronoxor.proto.BalanceMessage.Default;
            BalanceMessageModel = new BalanceMessageModel();
            AccountMessageValue = global::com.chronoxor.proto.AccountMessage.Default;
            AccountMessageModel = new AccountMessageModel();
        }

        internal override bool OnReceive(long type, byte[] buffer, long offset, long size) { return OnReceiveListener(this, type, buffer, offset, size); }
        internal bool OnReceiveListener(IReceiverListener listener, long type, byte[] buffer, long offset, long size)
        {
            switch (type)
            {
                case OrderMessageModel.FBETypeConst:
                {
                    // Deserialize the value from the FBE stream
                    OrderMessageModel.Attach(buffer, offset);
                    Debug.Assert(OrderMessageModel.Verify(), "com.chronoxor.proto.OrderMessage validation failed!");
                    long deserialized = OrderMessageModel.Deserialize(out OrderMessageValue);
                    Debug.Assert((deserialized > 0), "com.chronoxor.proto.OrderMessage deserialization failed!");

                    // Log the value
                    if (Logging)
                    {
                        string message = OrderMessageValue.ToString();
                        listener.OnReceiveLog(message);
                    }

                    // Call receive handler with deserialized value
                    listener.OnReceive(OrderMessageValue);
                    return true;
                }
                case BalanceMessageModel.FBETypeConst:
                {
                    // Deserialize the value from the FBE stream
                    BalanceMessageModel.Attach(buffer, offset);
                    Debug.Assert(BalanceMessageModel.Verify(), "com.chronoxor.proto.BalanceMessage validation failed!");
                    long deserialized = BalanceMessageModel.Deserialize(out BalanceMessageValue);
                    Debug.Assert((deserialized > 0), "com.chronoxor.proto.BalanceMessage deserialization failed!");

                    // Log the value
                    if (Logging)
                    {
                        string message = BalanceMessageValue.ToString();
                        listener.OnReceiveLog(message);
                    }

                    // Call receive handler with deserialized value
                    listener.OnReceive(BalanceMessageValue);
                    return true;
                }
                case AccountMessageModel.FBETypeConst:
                {
                    // Deserialize the value from the FBE stream
                    AccountMessageModel.Attach(buffer, offset);
                    Debug.Assert(AccountMessageModel.Verify(), "com.chronoxor.proto.AccountMessage validation failed!");
                    long deserialized = AccountMessageModel.Deserialize(out AccountMessageValue);
                    Debug.Assert((deserialized > 0), "com.chronoxor.proto.AccountMessage deserialization failed!");

                    // Log the value
                    if (Logging)
                    {
                        string message = AccountMessageValue.ToString();
                        listener.OnReceiveLog(message);
                    }

                    // Call receive handler with deserialized value
                    listener.OnReceive(AccountMessageValue);
                    return true;
                }
                default: break;
            }

            return false;
        }
    }

} // namespace com.chronoxor.proto.FBE

namespace com.chronoxor.proto.FBE {

    // Fast Binary Encoding com.chronoxor.proto proxy listener interface
    public interface IProxyListener : com.chronoxor.FBE.IReceiverListener
    {
        // Proxy handlers
        void OnProxy(OrderMessageModel model, long type, byte[] buffer, long offset, long size) {}
        void OnProxy(BalanceMessageModel model, long type, byte[] buffer, long offset, long size) {}
        void OnProxy(AccountMessageModel model, long type, byte[] buffer, long offset, long size) {}
    }

    // Fast Binary Encoding com.chronoxor.proto proxy
    public class Proxy : com.chronoxor.FBE.Receiver, IProxyListener
    {
        // Proxy models accessors
        private readonly OrderMessageModel OrderMessageModel;
        private readonly BalanceMessageModel BalanceMessageModel;
        private readonly AccountMessageModel AccountMessageModel;

        public Proxy() : base(false)
        {
            OrderMessageModel = new OrderMessageModel();
            BalanceMessageModel = new BalanceMessageModel();
            AccountMessageModel = new AccountMessageModel();
        }
        public Proxy(com.chronoxor.FBE.Buffer buffer) : base(buffer, false)
        {
            OrderMessageModel = new OrderMessageModel();
            BalanceMessageModel = new BalanceMessageModel();
            AccountMessageModel = new AccountMessageModel();
        }

        internal override bool OnReceive(long type, byte[] buffer, long offset, long size) { return OnReceiveListener(this, type, buffer, offset, size); }
        internal bool OnReceiveListener(IProxyListener listener, long type, byte[] buffer, long offset, long size)
        {
            switch (type)
            {
                case OrderMessageModel.FBETypeConst:
                {
                    // Attach the FBE stream to the proxy model
                    OrderMessageModel.Attach(buffer, offset);
                    Debug.Assert(OrderMessageModel.Verify(), "com.chronoxor.proto.OrderMessage validation failed!");

                    long fbeBegin = OrderMessageModel.model.GetBegin();
                    if (fbeBegin == 0)
                        return false;
                    // Call proxy handler
                    listener.OnProxy(OrderMessageModel, type, buffer, offset, size);
                    OrderMessageModel.model.GetEnd(fbeBegin);
                    return true;
                }
                case BalanceMessageModel.FBETypeConst:
                {
                    // Attach the FBE stream to the proxy model
                    BalanceMessageModel.Attach(buffer, offset);
                    Debug.Assert(BalanceMessageModel.Verify(), "com.chronoxor.proto.BalanceMessage validation failed!");

                    long fbeBegin = BalanceMessageModel.model.GetBegin();
                    if (fbeBegin == 0)
                        return false;
                    // Call proxy handler
                    listener.OnProxy(BalanceMessageModel, type, buffer, offset, size);
                    BalanceMessageModel.model.GetEnd(fbeBegin);
                    return true;
                }
                case AccountMessageModel.FBETypeConst:
                {
                    // Attach the FBE stream to the proxy model
                    AccountMessageModel.Attach(buffer, offset);
                    Debug.Assert(AccountMessageModel.Verify(), "com.chronoxor.proto.AccountMessage validation failed!");

                    long fbeBegin = AccountMessageModel.model.GetBegin();
                    if (fbeBegin == 0)
                        return false;
                    // Call proxy handler
                    listener.OnProxy(AccountMessageModel, type, buffer, offset, size);
                    AccountMessageModel.model.GetEnd(fbeBegin);
                    return true;
                }
                default: break;
            }

            return false;
        }
    }

} // namespace com.chronoxor.proto.FBE

namespace com.chronoxor.proto.FBE {

    // Fast Binary Encoding com.chronoxor.proto client listener interface
    public interface IClientListener : com.chronoxor.FBE.IClientListener, ISenderListener, IReceiverListener
    {
    }

    // Fast Binary Encoding com.chronoxor.proto client
    public class Client : com.chronoxor.FBE.Client, IClientListener
    {
        // Client sender models accessors
        public readonly OrderMessageModel OrderMessageSenderModel;
        public readonly BalanceMessageModel BalanceMessageSenderModel;
        public readonly AccountMessageModel AccountMessageSenderModel;

        // Client receiver values accessors
        private global::com.chronoxor.proto.OrderMessage OrderMessageReceiverValue;
        private global::com.chronoxor.proto.BalanceMessage BalanceMessageReceiverValue;
        private global::com.chronoxor.proto.AccountMessage AccountMessageReceiverValue;

        // Client receiver models accessors
        private readonly OrderMessageModel OrderMessageReceiverModel;
        private readonly BalanceMessageModel BalanceMessageReceiverModel;
        private readonly AccountMessageModel AccountMessageReceiverModel;

        public Client() : base(false)
        {
            OrderMessageSenderModel = new OrderMessageModel(SendBuffer);
            OrderMessageReceiverValue = global::com.chronoxor.proto.OrderMessage.Default;
            OrderMessageReceiverModel = new OrderMessageModel();
            BalanceMessageSenderModel = new BalanceMessageModel(SendBuffer);
            BalanceMessageReceiverValue = global::com.chronoxor.proto.BalanceMessage.Default;
            BalanceMessageReceiverModel = new BalanceMessageModel();
            AccountMessageSenderModel = new AccountMessageModel(SendBuffer);
            AccountMessageReceiverValue = global::com.chronoxor.proto.AccountMessage.Default;
            AccountMessageReceiverModel = new AccountMessageModel();
        }
        public Client(com.chronoxor.FBE.Buffer sendBuffer, com.chronoxor.FBE.Buffer receiveBuffer) : base(sendBuffer, receiveBuffer, false)
        {
            OrderMessageSenderModel = new OrderMessageModel(SendBuffer);
            OrderMessageReceiverValue = global::com.chronoxor.proto.OrderMessage.Default;
            OrderMessageReceiverModel = new OrderMessageModel();
            BalanceMessageSenderModel = new BalanceMessageModel(SendBuffer);
            BalanceMessageReceiverValue = global::com.chronoxor.proto.BalanceMessage.Default;
            BalanceMessageReceiverModel = new BalanceMessageModel();
            AccountMessageSenderModel = new AccountMessageModel(SendBuffer);
            AccountMessageReceiverValue = global::com.chronoxor.proto.AccountMessage.Default;
            AccountMessageReceiverModel = new AccountMessageModel();
        }

        public long Send(object obj) { return SendListener(this, obj); }
        public long SendListener(IClientListener listener, object obj)
        {
            switch (obj)
            {
                case global::com.chronoxor.proto.OrderMessage value when value.FBEType == global::com.chronoxor.proto.OrderMessage.FBETypeConst: return SendListener(listener, value);
                case global::com.chronoxor.proto.BalanceMessage value when value.FBEType == global::com.chronoxor.proto.BalanceMessage.FBETypeConst: return SendListener(listener, value);
                case global::com.chronoxor.proto.AccountMessage value when value.FBEType == global::com.chronoxor.proto.AccountMessage.FBETypeConst: return SendListener(listener, value);
                default: break;
            }

            return 0;
        }

        public long Send(global::com.chronoxor.proto.OrderMessage value) { return SendListener(this, value); }
        public long SendListener(IClientListener listener, global::com.chronoxor.proto.OrderMessage value)
        {
            // Serialize the value into the FBE stream
            long serialized = OrderMessageSenderModel.Serialize(value);
            Debug.Assert((serialized > 0), "com.chronoxor.proto.OrderMessage serialization failed!");
            Debug.Assert(OrderMessageSenderModel.Verify(), "com.chronoxor.proto.OrderMessage validation failed!");

            // Log the value
            if (Logging)
            {
                string message = value.ToString();
                listener.OnSendLog(message);
            }

            // Send the serialized value
            return SendSerialized(listener, serialized);
        }
        public long Send(global::com.chronoxor.proto.BalanceMessage value) { return SendListener(this, value); }
        public long SendListener(IClientListener listener, global::com.chronoxor.proto.BalanceMessage value)
        {
            // Serialize the value into the FBE stream
            long serialized = BalanceMessageSenderModel.Serialize(value);
            Debug.Assert((serialized > 0), "com.chronoxor.proto.BalanceMessage serialization failed!");
            Debug.Assert(BalanceMessageSenderModel.Verify(), "com.chronoxor.proto.BalanceMessage validation failed!");

            // Log the value
            if (Logging)
            {
                string message = value.ToString();
                listener.OnSendLog(message);
            }

            // Send the serialized value
            return SendSerialized(listener, serialized);
        }
        public long Send(global::com.chronoxor.proto.AccountMessage value) { return SendListener(this, value); }
        public long SendListener(IClientListener listener, global::com.chronoxor.proto.AccountMessage value)
        {
            // Serialize the value into the FBE stream
            long serialized = AccountMessageSenderModel.Serialize(value);
            Debug.Assert((serialized > 0), "com.chronoxor.proto.AccountMessage serialization failed!");
            Debug.Assert(AccountMessageSenderModel.Verify(), "com.chronoxor.proto.AccountMessage validation failed!");

            // Log the value
            if (Logging)
            {
                string message = value.ToString();
                listener.OnSendLog(message);
            }

            // Send the serialized value
            return SendSerialized(listener, serialized);
        }

        public bool OnReceiveResponse(global::com.chronoxor.proto.OrderMessage response) { ReceivedResponse_OrderMessage?.Invoke(response); return false; }
        public bool OnReceiveResponse(global::com.chronoxor.proto.BalanceMessage response) { ReceivedResponse_BalanceMessage?.Invoke(response); return false; }
        public bool OnReceiveResponse(global::com.chronoxor.proto.AccountMessage response) { ReceivedResponse_AccountMessage?.Invoke(response); return false; }

        public bool OnReceiveReject(global::com.chronoxor.proto.OrderMessage reject) { ReceivedReject_OrderMessage?.Invoke(reject); return false; }
        public bool OnReceiveReject(global::com.chronoxor.proto.BalanceMessage reject) { ReceivedReject_BalanceMessage?.Invoke(reject); return false; }
        public bool OnReceiveReject(global::com.chronoxor.proto.AccountMessage reject) { ReceivedReject_AccountMessage?.Invoke(reject); return false; }

        public void OnReceiveNotify(global::com.chronoxor.proto.OrderMessage notify) { ReceivedNotify_OrderMessage?.Invoke(notify); }
        public void OnReceiveNotify(global::com.chronoxor.proto.BalanceMessage notify) { ReceivedNotify_BalanceMessage?.Invoke(notify); }
        public void OnReceiveNotify(global::com.chronoxor.proto.AccountMessage notify) { ReceivedNotify_AccountMessage?.Invoke(notify); }

        public void OnReceive(global::com.chronoxor.proto.OrderMessage value) { if (!OnReceiveResponse(value) && !OnReceiveReject(value)) OnReceiveNotify(value); }
        public void OnReceive(global::com.chronoxor.proto.BalanceMessage value) { if (!OnReceiveResponse(value) && !OnReceiveReject(value)) OnReceiveNotify(value); }
        public void OnReceive(global::com.chronoxor.proto.AccountMessage value) { if (!OnReceiveResponse(value) && !OnReceiveReject(value)) OnReceiveNotify(value); }

        // Reset client requests
        internal override void ResetRequests()
        {
            base.ResetRequests();
        }

        // Watchdog client requests for timeouts
        internal override void WatchdogRequests(DateTime utc)
        {
            base.WatchdogRequests(utc);
        }

        internal override bool OnReceive(long type, byte[] buffer, long offset, long size) { return OnReceiveListener(this, type, buffer, offset, size); }
        internal bool OnReceiveListener(IClientListener listener, long type, byte[] buffer, long offset, long size)
        {
            switch (type)
            {
                case OrderMessageModel.FBETypeConst:
                {
                    // Deserialize the value from the FBE stream
                    OrderMessageReceiverModel.Attach(buffer, offset);
                    Debug.Assert(OrderMessageReceiverModel.Verify(), "com.chronoxor.proto.OrderMessage validation failed!");
                    long deserialized = OrderMessageReceiverModel.Deserialize(out OrderMessageReceiverValue);
                    Debug.Assert((deserialized > 0), "com.chronoxor.proto.OrderMessage deserialization failed!");

                    // Log the value
                    if (Logging)
                    {
                        string message = OrderMessageReceiverValue.ToString();
                        listener.OnReceiveLog(message);
                    }

                    // Call receive handler with deserialized value
                    listener.OnReceive(OrderMessageReceiverValue);
                    return true;
                }
                case BalanceMessageModel.FBETypeConst:
                {
                    // Deserialize the value from the FBE stream
                    BalanceMessageReceiverModel.Attach(buffer, offset);
                    Debug.Assert(BalanceMessageReceiverModel.Verify(), "com.chronoxor.proto.BalanceMessage validation failed!");
                    long deserialized = BalanceMessageReceiverModel.Deserialize(out BalanceMessageReceiverValue);
                    Debug.Assert((deserialized > 0), "com.chronoxor.proto.BalanceMessage deserialization failed!");

                    // Log the value
                    if (Logging)
                    {
                        string message = BalanceMessageReceiverValue.ToString();
                        listener.OnReceiveLog(message);
                    }

                    // Call receive handler with deserialized value
                    listener.OnReceive(BalanceMessageReceiverValue);
                    return true;
                }
                case AccountMessageModel.FBETypeConst:
                {
                    // Deserialize the value from the FBE stream
                    AccountMessageReceiverModel.Attach(buffer, offset);
                    Debug.Assert(AccountMessageReceiverModel.Verify(), "com.chronoxor.proto.AccountMessage validation failed!");
                    long deserialized = AccountMessageReceiverModel.Deserialize(out AccountMessageReceiverValue);
                    Debug.Assert((deserialized > 0), "com.chronoxor.proto.AccountMessage deserialization failed!");

                    // Log the value
                    if (Logging)
                    {
                        string message = AccountMessageReceiverValue.ToString();
                        listener.OnReceiveLog(message);
                    }

                    // Call receive handler with deserialized value
                    listener.OnReceive(AccountMessageReceiverValue);
                    return true;
                }
                default: break;
            }

            return false;
        }

        public delegate void ReceiveResponseHandler_OrderMessage(global::com.chronoxor.proto.OrderMessage response);
        public event ReceiveResponseHandler_OrderMessage ReceivedResponse_OrderMessage = (response) => {};
        public delegate void ReceiveResponseHandler_BalanceMessage(global::com.chronoxor.proto.BalanceMessage response);
        public event ReceiveResponseHandler_BalanceMessage ReceivedResponse_BalanceMessage = (response) => {};
        public delegate void ReceiveResponseHandler_AccountMessage(global::com.chronoxor.proto.AccountMessage response);
        public event ReceiveResponseHandler_AccountMessage ReceivedResponse_AccountMessage = (response) => {};
        public delegate void ReceiveRejectHandler_OrderMessage(global::com.chronoxor.proto.OrderMessage reject);
        public event ReceiveRejectHandler_OrderMessage ReceivedReject_OrderMessage = (reject) => {};
        public delegate void ReceiveRejectHandler_BalanceMessage(global::com.chronoxor.proto.BalanceMessage reject);
        public event ReceiveRejectHandler_BalanceMessage ReceivedReject_BalanceMessage = (reject) => {};
        public delegate void ReceiveRejectHandler_AccountMessage(global::com.chronoxor.proto.AccountMessage reject);
        public event ReceiveRejectHandler_AccountMessage ReceivedReject_AccountMessage = (reject) => {};
        public delegate void ReceiveNotifyHandler_OrderMessage(global::com.chronoxor.proto.OrderMessage notify);
        public event ReceiveNotifyHandler_OrderMessage ReceivedNotify_OrderMessage = (notify) => {};
        public delegate void ReceiveNotifyHandler_BalanceMessage(global::com.chronoxor.proto.BalanceMessage notify);
        public event ReceiveNotifyHandler_BalanceMessage ReceivedNotify_BalanceMessage = (notify) => {};
        public delegate void ReceiveNotifyHandler_AccountMessage(global::com.chronoxor.proto.AccountMessage notify);
        public event ReceiveNotifyHandler_AccountMessage ReceivedNotify_AccountMessage = (notify) => {};
    }

} // namespace com.chronoxor.proto.FBE

namespace com.chronoxor.proto.FBE {

    // Fast Binary Encoding com.chronoxor.proto final sender listener interface
    public interface IFinalSenderListener : com.chronoxor.FBE.ISenderListener
    {
    }

    // Fast Binary Encoding com.chronoxor.proto final sender
    public class FinalSender : com.chronoxor.FBE.Sender, IFinalSenderListener
    {
        // Sender models accessors
        public readonly OrderMessageFinalModel OrderMessageModel;
        public readonly BalanceMessageFinalModel BalanceMessageModel;
        public readonly AccountMessageFinalModel AccountMessageModel;

        public FinalSender() : base(true)
        {
            OrderMessageModel = new OrderMessageFinalModel(Buffer);
            BalanceMessageModel = new BalanceMessageFinalModel(Buffer);
            AccountMessageModel = new AccountMessageFinalModel(Buffer);
        }
        public FinalSender(com.chronoxor.FBE.Buffer buffer) : base(buffer, true)
        {
            OrderMessageModel = new OrderMessageFinalModel(Buffer);
            BalanceMessageModel = new BalanceMessageFinalModel(Buffer);
            AccountMessageModel = new AccountMessageFinalModel(Buffer);
        }

        public long Send(object obj) { return SendListener(this, obj); }
        public long SendListener(IFinalSenderListener listener, object obj)
        {
            switch (obj)
            {
                case global::com.chronoxor.proto.OrderMessage value when value.FBEType == global::com.chronoxor.proto.OrderMessage.FBETypeConst: return SendListener(listener, value);
                case global::com.chronoxor.proto.BalanceMessage value when value.FBEType == global::com.chronoxor.proto.BalanceMessage.FBETypeConst: return SendListener(listener, value);
                case global::com.chronoxor.proto.AccountMessage value when value.FBEType == global::com.chronoxor.proto.AccountMessage.FBETypeConst: return SendListener(listener, value);
                default: break;
            }

            return 0;
        }

        public long Send(global::com.chronoxor.proto.OrderMessage value) { return SendListener(this, value); }
        public long SendListener(IFinalSenderListener listener, global::com.chronoxor.proto.OrderMessage value)
        {
            // Serialize the value into the FBE stream
            long serialized = OrderMessageModel.Serialize(value);
            Debug.Assert((serialized > 0), "com.chronoxor.proto.OrderMessage serialization failed!");
            Debug.Assert(OrderMessageModel.Verify(), "com.chronoxor.proto.OrderMessage validation failed!");

            // Log the value
            if (Logging)
            {
                string message = value.ToString();
                listener.OnSendLog(message);
            }

            // Send the serialized value
            return SendSerialized(listener, serialized);
        }
        public long Send(global::com.chronoxor.proto.BalanceMessage value) { return SendListener(this, value); }
        public long SendListener(IFinalSenderListener listener, global::com.chronoxor.proto.BalanceMessage value)
        {
            // Serialize the value into the FBE stream
            long serialized = BalanceMessageModel.Serialize(value);
            Debug.Assert((serialized > 0), "com.chronoxor.proto.BalanceMessage serialization failed!");
            Debug.Assert(BalanceMessageModel.Verify(), "com.chronoxor.proto.BalanceMessage validation failed!");

            // Log the value
            if (Logging)
            {
                string message = value.ToString();
                listener.OnSendLog(message);
            }

            // Send the serialized value
            return SendSerialized(listener, serialized);
        }
        public long Send(global::com.chronoxor.proto.AccountMessage value) { return SendListener(this, value); }
        public long SendListener(IFinalSenderListener listener, global::com.chronoxor.proto.AccountMessage value)
        {
            // Serialize the value into the FBE stream
            long serialized = AccountMessageModel.Serialize(value);
            Debug.Assert((serialized > 0), "com.chronoxor.proto.AccountMessage serialization failed!");
            Debug.Assert(AccountMessageModel.Verify(), "com.chronoxor.proto.AccountMessage validation failed!");

            // Log the value
            if (Logging)
            {
                string message = value.ToString();
                listener.OnSendLog(message);
            }

            // Send the serialized value
            return SendSerialized(listener, serialized);
        }
    }

} // namespace com.chronoxor.proto.FBE

namespace com.chronoxor.proto.FBE {

    // Fast Binary Encoding com.chronoxor.proto final receiver listener interface
    public interface IFinalReceiverListener : com.chronoxor.FBE.IReceiverListener
    {
        // Receive handlers
        void OnReceive(global::com.chronoxor.proto.OrderMessage value) {}
        void OnReceive(global::com.chronoxor.proto.BalanceMessage value) {}
        void OnReceive(global::com.chronoxor.proto.AccountMessage value) {}
    }

    // Fast Binary Encoding com.chronoxor.proto final receiver
    public class FinalReceiver : com.chronoxor.FBE.Receiver, IFinalReceiverListener
    {
        // Receiver values accessors
        private global::com.chronoxor.proto.OrderMessage OrderMessageValue;
        private global::com.chronoxor.proto.BalanceMessage BalanceMessageValue;
        private global::com.chronoxor.proto.AccountMessage AccountMessageValue;

        // Receiver models accessors
        private readonly OrderMessageFinalModel OrderMessageModel;
        private readonly BalanceMessageFinalModel BalanceMessageModel;
        private readonly AccountMessageFinalModel AccountMessageModel;

        public FinalReceiver() : base(true)
        {
            OrderMessageValue = global::com.chronoxor.proto.OrderMessage.Default;
            OrderMessageModel = new OrderMessageFinalModel();
            BalanceMessageValue = global::com.chronoxor.proto.BalanceMessage.Default;
            BalanceMessageModel = new BalanceMessageFinalModel();
            AccountMessageValue = global::com.chronoxor.proto.AccountMessage.Default;
            AccountMessageModel = new AccountMessageFinalModel();
        }
        public FinalReceiver(com.chronoxor.FBE.Buffer buffer) : base(buffer, true)
        {
            OrderMessageValue = global::com.chronoxor.proto.OrderMessage.Default;
            OrderMessageModel = new OrderMessageFinalModel();
            BalanceMessageValue = global::com.chronoxor.proto.BalanceMessage.Default;
            BalanceMessageModel = new BalanceMessageFinalModel();
            AccountMessageValue = global::com.chronoxor.proto.AccountMessage.Default;
            AccountMessageModel = new AccountMessageFinalModel();
        }

        internal override bool OnReceive(long type, byte[] buffer, long offset, long size) { return OnReceiveListener(this, type, buffer, offset, size); }
        internal bool OnReceiveListener(IFinalReceiverListener listener, long type, byte[] buffer, long offset, long size)
        {
            switch (type)
            {
                case OrderMessageFinalModel.FBETypeConst:
                {
                    // Deserialize the value from the FBE stream
                    OrderMessageModel.Attach(buffer, offset);
                    Debug.Assert(OrderMessageModel.Verify(), "com.chronoxor.proto.OrderMessage validation failed!");
                    long deserialized = OrderMessageModel.Deserialize(out OrderMessageValue);
                    Debug.Assert((deserialized > 0), "com.chronoxor.proto.OrderMessage deserialization failed!");

                    // Log the value
                    if (Logging)
                    {
                        string message = OrderMessageValue.ToString();
                        listener.OnReceiveLog(message);
                    }

                    // Call receive handler with deserialized value
                    listener.OnReceive(OrderMessageValue);
                    return true;
                }
                case BalanceMessageFinalModel.FBETypeConst:
                {
                    // Deserialize the value from the FBE stream
                    BalanceMessageModel.Attach(buffer, offset);
                    Debug.Assert(BalanceMessageModel.Verify(), "com.chronoxor.proto.BalanceMessage validation failed!");
                    long deserialized = BalanceMessageModel.Deserialize(out BalanceMessageValue);
                    Debug.Assert((deserialized > 0), "com.chronoxor.proto.BalanceMessage deserialization failed!");

                    // Log the value
                    if (Logging)
                    {
                        string message = BalanceMessageValue.ToString();
                        listener.OnReceiveLog(message);
                    }

                    // Call receive handler with deserialized value
                    listener.OnReceive(BalanceMessageValue);
                    return true;
                }
                case AccountMessageFinalModel.FBETypeConst:
                {
                    // Deserialize the value from the FBE stream
                    AccountMessageModel.Attach(buffer, offset);
                    Debug.Assert(AccountMessageModel.Verify(), "com.chronoxor.proto.AccountMessage validation failed!");
                    long deserialized = AccountMessageModel.Deserialize(out AccountMessageValue);
                    Debug.Assert((deserialized > 0), "com.chronoxor.proto.AccountMessage deserialization failed!");

                    // Log the value
                    if (Logging)
                    {
                        string message = AccountMessageValue.ToString();
                        listener.OnReceiveLog(message);
                    }

                    // Call receive handler with deserialized value
                    listener.OnReceive(AccountMessageValue);
                    return true;
                }
                default: break;
            }

            return false;
        }
    }

} // namespace com.chronoxor.proto.FBE

namespace com.chronoxor.proto.FBE {

    // Fast Binary Encoding com.chronoxor.proto final client listener interface
    public interface IFinalClientListener : com.chronoxor.FBE.IClientListener, IFinalSenderListener, IFinalReceiverListener
    {
    }

    // Fast Binary Encoding com.chronoxor.proto final client
    public class FinalClient : com.chronoxor.FBE.Client, IFinalClientListener
    {
        // Client sender models accessors
        public readonly OrderMessageFinalModel OrderMessageSenderModel;
        public readonly BalanceMessageFinalModel BalanceMessageSenderModel;
        public readonly AccountMessageFinalModel AccountMessageSenderModel;

        // Client receiver values accessors
        private global::com.chronoxor.proto.OrderMessage OrderMessageReceiverValue;
        private global::com.chronoxor.proto.BalanceMessage BalanceMessageReceiverValue;
        private global::com.chronoxor.proto.AccountMessage AccountMessageReceiverValue;

        // Client receiver models accessors
        private readonly OrderMessageFinalModel OrderMessageReceiverModel;
        private readonly BalanceMessageFinalModel BalanceMessageReceiverModel;
        private readonly AccountMessageFinalModel AccountMessageReceiverModel;

        public FinalClient() : base(true)
        {
            OrderMessageSenderModel = new OrderMessageFinalModel(SendBuffer);
            OrderMessageReceiverValue = global::com.chronoxor.proto.OrderMessage.Default;
            OrderMessageReceiverModel = new OrderMessageFinalModel();
            BalanceMessageSenderModel = new BalanceMessageFinalModel(SendBuffer);
            BalanceMessageReceiverValue = global::com.chronoxor.proto.BalanceMessage.Default;
            BalanceMessageReceiverModel = new BalanceMessageFinalModel();
            AccountMessageSenderModel = new AccountMessageFinalModel(SendBuffer);
            AccountMessageReceiverValue = global::com.chronoxor.proto.AccountMessage.Default;
            AccountMessageReceiverModel = new AccountMessageFinalModel();
        }
        public FinalClient(com.chronoxor.FBE.Buffer sendBuffer, com.chronoxor.FBE.Buffer receiveBuffer) : base(sendBuffer, receiveBuffer, true)
        {
            OrderMessageSenderModel = new OrderMessageFinalModel(SendBuffer);
            OrderMessageReceiverValue = global::com.chronoxor.proto.OrderMessage.Default;
            OrderMessageReceiverModel = new OrderMessageFinalModel();
            BalanceMessageSenderModel = new BalanceMessageFinalModel(SendBuffer);
            BalanceMessageReceiverValue = global::com.chronoxor.proto.BalanceMessage.Default;
            BalanceMessageReceiverModel = new BalanceMessageFinalModel();
            AccountMessageSenderModel = new AccountMessageFinalModel(SendBuffer);
            AccountMessageReceiverValue = global::com.chronoxor.proto.AccountMessage.Default;
            AccountMessageReceiverModel = new AccountMessageFinalModel();
        }

        public long Send(object obj) { return SendListener(this, obj); }
        public long SendListener(IFinalClientListener listener, object obj)
        {
            switch (obj)
            {
                case global::com.chronoxor.proto.OrderMessage value when value.FBEType == global::com.chronoxor.proto.OrderMessage.FBETypeConst: return SendListener(listener, value);
                case global::com.chronoxor.proto.BalanceMessage value when value.FBEType == global::com.chronoxor.proto.BalanceMessage.FBETypeConst: return SendListener(listener, value);
                case global::com.chronoxor.proto.AccountMessage value when value.FBEType == global::com.chronoxor.proto.AccountMessage.FBETypeConst: return SendListener(listener, value);
                default: break;
            }

            return 0;
        }

        public long Send(global::com.chronoxor.proto.OrderMessage value) { return SendListener(this, value); }
        public long SendListener(IFinalClientListener listener, global::com.chronoxor.proto.OrderMessage value)
        {
            // Serialize the value into the FBE stream
            long serialized = OrderMessageSenderModel.Serialize(value);
            Debug.Assert((serialized > 0), "com.chronoxor.proto.OrderMessage serialization failed!");
            Debug.Assert(OrderMessageSenderModel.Verify(), "com.chronoxor.proto.OrderMessage validation failed!");

            // Log the value
            if (Logging)
            {
                string message = value.ToString();
                listener.OnSendLog(message);
            }

            // Send the serialized value
            return SendSerialized(listener, serialized);
        }
        public long Send(global::com.chronoxor.proto.BalanceMessage value) { return SendListener(this, value); }
        public long SendListener(IFinalClientListener listener, global::com.chronoxor.proto.BalanceMessage value)
        {
            // Serialize the value into the FBE stream
            long serialized = BalanceMessageSenderModel.Serialize(value);
            Debug.Assert((serialized > 0), "com.chronoxor.proto.BalanceMessage serialization failed!");
            Debug.Assert(BalanceMessageSenderModel.Verify(), "com.chronoxor.proto.BalanceMessage validation failed!");

            // Log the value
            if (Logging)
            {
                string message = value.ToString();
                listener.OnSendLog(message);
            }

            // Send the serialized value
            return SendSerialized(listener, serialized);
        }
        public long Send(global::com.chronoxor.proto.AccountMessage value) { return SendListener(this, value); }
        public long SendListener(IFinalClientListener listener, global::com.chronoxor.proto.AccountMessage value)
        {
            // Serialize the value into the FBE stream
            long serialized = AccountMessageSenderModel.Serialize(value);
            Debug.Assert((serialized > 0), "com.chronoxor.proto.AccountMessage serialization failed!");
            Debug.Assert(AccountMessageSenderModel.Verify(), "com.chronoxor.proto.AccountMessage validation failed!");

            // Log the value
            if (Logging)
            {
                string message = value.ToString();
                listener.OnSendLog(message);
            }

            // Send the serialized value
            return SendSerialized(listener, serialized);
        }

        public bool OnReceiveResponse(global::com.chronoxor.proto.OrderMessage response) { ReceivedResponse_OrderMessage?.Invoke(response); return false; }
        public bool OnReceiveResponse(global::com.chronoxor.proto.BalanceMessage response) { ReceivedResponse_BalanceMessage?.Invoke(response); return false; }
        public bool OnReceiveResponse(global::com.chronoxor.proto.AccountMessage response) { ReceivedResponse_AccountMessage?.Invoke(response); return false; }

        public bool OnReceiveReject(global::com.chronoxor.proto.OrderMessage reject) { ReceivedReject_OrderMessage?.Invoke(reject); return false; }
        public bool OnReceiveReject(global::com.chronoxor.proto.BalanceMessage reject) { ReceivedReject_BalanceMessage?.Invoke(reject); return false; }
        public bool OnReceiveReject(global::com.chronoxor.proto.AccountMessage reject) { ReceivedReject_AccountMessage?.Invoke(reject); return false; }

        public void OnReceiveNotify(global::com.chronoxor.proto.OrderMessage notify) { ReceivedNotify_OrderMessage?.Invoke(notify); }
        public void OnReceiveNotify(global::com.chronoxor.proto.BalanceMessage notify) { ReceivedNotify_BalanceMessage?.Invoke(notify); }
        public void OnReceiveNotify(global::com.chronoxor.proto.AccountMessage notify) { ReceivedNotify_AccountMessage?.Invoke(notify); }

        public void OnReceive(global::com.chronoxor.proto.OrderMessage value) { if (!OnReceiveResponse(value) && !OnReceiveReject(value)) OnReceiveNotify(value); }
        public void OnReceive(global::com.chronoxor.proto.BalanceMessage value) { if (!OnReceiveResponse(value) && !OnReceiveReject(value)) OnReceiveNotify(value); }
        public void OnReceive(global::com.chronoxor.proto.AccountMessage value) { if (!OnReceiveResponse(value) && !OnReceiveReject(value)) OnReceiveNotify(value); }

        // Reset client requests
        internal override void ResetRequests()
        {
            base.ResetRequests();
        }

        // Watchdog client requests for timeouts
        internal override void WatchdogRequests(DateTime utc)
        {
            base.WatchdogRequests(utc);
        }

        internal override bool OnReceive(long type, byte[] buffer, long offset, long size) { return OnReceiveListener(this, type, buffer, offset, size); }
        internal bool OnReceiveListener(IFinalClientListener listener, long type, byte[] buffer, long offset, long size)
        {
            switch (type)
            {
                case OrderMessageFinalModel.FBETypeConst:
                {
                    // Deserialize the value from the FBE stream
                    OrderMessageReceiverModel.Attach(buffer, offset);
                    Debug.Assert(OrderMessageReceiverModel.Verify(), "com.chronoxor.proto.OrderMessage validation failed!");
                    long deserialized = OrderMessageReceiverModel.Deserialize(out OrderMessageReceiverValue);
                    Debug.Assert((deserialized > 0), "com.chronoxor.proto.OrderMessage deserialization failed!");

                    // Log the value
                    if (Logging)
                    {
                        string message = OrderMessageReceiverValue.ToString();
                        listener.OnReceiveLog(message);
                    }

                    // Call receive handler with deserialized value
                    listener.OnReceive(OrderMessageReceiverValue);
                    return true;
                }
                case BalanceMessageFinalModel.FBETypeConst:
                {
                    // Deserialize the value from the FBE stream
                    BalanceMessageReceiverModel.Attach(buffer, offset);
                    Debug.Assert(BalanceMessageReceiverModel.Verify(), "com.chronoxor.proto.BalanceMessage validation failed!");
                    long deserialized = BalanceMessageReceiverModel.Deserialize(out BalanceMessageReceiverValue);
                    Debug.Assert((deserialized > 0), "com.chronoxor.proto.BalanceMessage deserialization failed!");

                    // Log the value
                    if (Logging)
                    {
                        string message = BalanceMessageReceiverValue.ToString();
                        listener.OnReceiveLog(message);
                    }

                    // Call receive handler with deserialized value
                    listener.OnReceive(BalanceMessageReceiverValue);
                    return true;
                }
                case AccountMessageFinalModel.FBETypeConst:
                {
                    // Deserialize the value from the FBE stream
                    AccountMessageReceiverModel.Attach(buffer, offset);
                    Debug.Assert(AccountMessageReceiverModel.Verify(), "com.chronoxor.proto.AccountMessage validation failed!");
                    long deserialized = AccountMessageReceiverModel.Deserialize(out AccountMessageReceiverValue);
                    Debug.Assert((deserialized > 0), "com.chronoxor.proto.AccountMessage deserialization failed!");

                    // Log the value
                    if (Logging)
                    {
                        string message = AccountMessageReceiverValue.ToString();
                        listener.OnReceiveLog(message);
                    }

                    // Call receive handler with deserialized value
                    listener.OnReceive(AccountMessageReceiverValue);
                    return true;
                }
                default: break;
            }

            return false;
        }

        public delegate void ReceiveResponseHandler_OrderMessage(global::com.chronoxor.proto.OrderMessage response);
        public event ReceiveResponseHandler_OrderMessage ReceivedResponse_OrderMessage = (response) => {};
        public delegate void ReceiveResponseHandler_BalanceMessage(global::com.chronoxor.proto.BalanceMessage response);
        public event ReceiveResponseHandler_BalanceMessage ReceivedResponse_BalanceMessage = (response) => {};
        public delegate void ReceiveResponseHandler_AccountMessage(global::com.chronoxor.proto.AccountMessage response);
        public event ReceiveResponseHandler_AccountMessage ReceivedResponse_AccountMessage = (response) => {};
        public delegate void ReceiveRejectHandler_OrderMessage(global::com.chronoxor.proto.OrderMessage reject);
        public event ReceiveRejectHandler_OrderMessage ReceivedReject_OrderMessage = (reject) => {};
        public delegate void ReceiveRejectHandler_BalanceMessage(global::com.chronoxor.proto.BalanceMessage reject);
        public event ReceiveRejectHandler_BalanceMessage ReceivedReject_BalanceMessage = (reject) => {};
        public delegate void ReceiveRejectHandler_AccountMessage(global::com.chronoxor.proto.AccountMessage reject);
        public event ReceiveRejectHandler_AccountMessage ReceivedReject_AccountMessage = (reject) => {};
        public delegate void ReceiveNotifyHandler_OrderMessage(global::com.chronoxor.proto.OrderMessage notify);
        public event ReceiveNotifyHandler_OrderMessage ReceivedNotify_OrderMessage = (notify) => {};
        public delegate void ReceiveNotifyHandler_BalanceMessage(global::com.chronoxor.proto.BalanceMessage notify);
        public event ReceiveNotifyHandler_BalanceMessage ReceivedNotify_BalanceMessage = (notify) => {};
        public delegate void ReceiveNotifyHandler_AccountMessage(global::com.chronoxor.proto.AccountMessage notify);
        public event ReceiveNotifyHandler_AccountMessage ReceivedNotify_AccountMessage = (notify) => {};
    }

} // namespace com.chronoxor.proto.FBE
